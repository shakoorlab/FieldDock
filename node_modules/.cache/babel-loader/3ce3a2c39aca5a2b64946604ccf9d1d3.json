{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nconst publish_1 = __importDefault(require(\"./publish\"));\nconst auth_1 = __importDefault(require(\"./auth\"));\nconst connack_1 = __importDefault(require(\"./connack\"));\nconst ack_1 = __importDefault(require(\"./ack\"));\nconst pubrel_1 = __importDefault(require(\"./pubrel\"));\nconst handle = (client, packet, done) => {\n  const {\n    options\n  } = client;\n  if (options.protocolVersion === 5 && options.properties && options.properties.maximumPacketSize && options.properties.maximumPacketSize < packet.length) {\n    client.emit('error', new Error(`exceeding packets size ${packet.cmd}`));\n    client.end({\n      reasonCode: 149,\n      properties: {\n        reasonString: 'Maximum packet size was exceeded'\n      }\n    });\n    return client;\n  }\n  client.log('_handlePacket :: emitting packetreceive');\n  client.emit('packetreceive', packet);\n  switch (packet.cmd) {\n    case 'publish':\n      (0, publish_1.default)(client, packet, done);\n      break;\n    case 'puback':\n    case 'pubrec':\n    case 'pubcomp':\n    case 'suback':\n    case 'unsuback':\n      (0, ack_1.default)(client, packet);\n      done();\n      break;\n    case 'pubrel':\n      (0, pubrel_1.default)(client, packet, done);\n      break;\n    case 'connack':\n      (0, connack_1.default)(client, packet);\n      done();\n      break;\n    case 'auth':\n      (0, auth_1.default)(client, packet);\n      done();\n      break;\n    case 'pingresp':\n      client.pingResp = true;\n      done();\n      break;\n    case 'disconnect':\n      client.emit('disconnect', packet);\n      done();\n      break;\n    default:\n      client.log('_handlePacket :: unknown command');\n      done();\n      break;\n  }\n};\nexports.default = handle;","map":{"version":3,"names":["publish_1","__importDefault","require","auth_1","connack_1","ack_1","pubrel_1","handle","client","packet","done","options","protocolVersion","properties","maximumPacketSize","length","emit","Error","cmd","end","reasonCode","reasonString","log","default","pingResp","exports"],"sources":["/Users/jstanton/Coding/FieldDock/FieldDockMain/node_modules/mqtt/src/lib/handlers/index.ts"],"sourcesContent":["import handlePublish from './publish'\nimport handleAuth from './auth'\nimport handleConnack from './connack'\nimport handleAck from './ack'\nimport handlePubrel from './pubrel'\nimport { PacketHandler } from '../shared'\n\nconst handle: PacketHandler = (client, packet, done) => {\n\tconst { options } = client\n\n\tif (\n\t\toptions.protocolVersion === 5 &&\n\t\toptions.properties &&\n\t\toptions.properties.maximumPacketSize &&\n\t\toptions.properties.maximumPacketSize < packet.length\n\t) {\n\t\tclient.emit('error', new Error(`exceeding packets size ${packet.cmd}`))\n\t\tclient.end({\n\t\t\treasonCode: 149,\n\t\t\tproperties: { reasonString: 'Maximum packet size was exceeded' },\n\t\t})\n\t\treturn client\n\t}\n\tclient.log('_handlePacket :: emitting packetreceive')\n\tclient.emit('packetreceive', packet)\n\n\tswitch (packet.cmd) {\n\t\tcase 'publish':\n\t\t\thandlePublish(client, packet, done)\n\t\t\tbreak\n\t\tcase 'puback':\n\t\tcase 'pubrec':\n\t\tcase 'pubcomp':\n\t\tcase 'suback':\n\t\tcase 'unsuback':\n\t\t\thandleAck(client, packet)\n\t\t\tdone()\n\t\t\tbreak\n\t\tcase 'pubrel':\n\t\t\thandlePubrel(client, packet, done)\n\t\t\tbreak\n\t\tcase 'connack':\n\t\t\thandleConnack(client, packet)\n\t\t\tdone()\n\t\t\tbreak\n\t\tcase 'auth':\n\t\t\thandleAuth(client, packet)\n\t\t\tdone()\n\t\t\tbreak\n\t\tcase 'pingresp':\n\t\t\t// this will be checked in _checkPing client method every keepalive interval\n\t\t\tclient.pingResp = true\n\t\t\tdone()\n\t\t\tbreak\n\t\tcase 'disconnect':\n\t\t\tclient.emit('disconnect', packet)\n\t\t\tdone()\n\t\t\tbreak\n\t\tdefault:\n\t\t\t// TODO: unknown packet received. Should we emit an error?\n\t\t\tclient.log('_handlePacket :: unknown command')\n\t\t\tdone()\n\t\t\tbreak\n\t}\n}\n\nexport default handle\n"],"mappings":";;;;;;;;;;AAAA,MAAAA,SAAA,GAAAC,eAAA,CAAAC,OAAA;AACA,MAAAC,MAAA,GAAAF,eAAA,CAAAC,OAAA;AACA,MAAAE,SAAA,GAAAH,eAAA,CAAAC,OAAA;AACA,MAAAG,KAAA,GAAAJ,eAAA,CAAAC,OAAA;AACA,MAAAI,QAAA,GAAAL,eAAA,CAAAC,OAAA;AAGA,MAAMK,MAAM,GAAkBA,CAACC,MAAM,EAAEC,MAAM,EAAEC,IAAI,KAAI;EACtD,MAAM;IAAEC;EAAO,CAAE,GAAGH,MAAM;EAE1B,IACCG,OAAO,CAACC,eAAe,KAAK,CAAC,IAC7BD,OAAO,CAACE,UAAU,IAClBF,OAAO,CAACE,UAAU,CAACC,iBAAiB,IACpCH,OAAO,CAACE,UAAU,CAACC,iBAAiB,GAAGL,MAAM,CAACM,MAAM,EACnD;IACDP,MAAM,CAACQ,IAAI,CAAC,OAAO,EAAE,IAAIC,KAAK,CAAC,0BAA0BR,MAAM,CAACS,GAAG,EAAE,CAAC,CAAC;IACvEV,MAAM,CAACW,GAAG,CAAC;MACVC,UAAU,EAAE,GAAG;MACfP,UAAU,EAAE;QAAEQ,YAAY,EAAE;MAAkC;KAC9D,CAAC;IACF,OAAOb,MAAM;;EAEdA,MAAM,CAACc,GAAG,CAAC,yCAAyC,CAAC;EACrDd,MAAM,CAACQ,IAAI,CAAC,eAAe,EAAEP,MAAM,CAAC;EAEpC,QAAQA,MAAM,CAACS,GAAG;IACjB,KAAK,SAAS;MACb,IAAAlB,SAAA,CAAAuB,OAAa,EAACf,MAAM,EAAEC,MAAM,EAAEC,IAAI,CAAC;MACnC;IACD,KAAK,QAAQ;IACb,KAAK,QAAQ;IACb,KAAK,SAAS;IACd,KAAK,QAAQ;IACb,KAAK,UAAU;MACd,IAAAL,KAAA,CAAAkB,OAAS,EAACf,MAAM,EAAEC,MAAM,CAAC;MACzBC,IAAI,EAAE;MACN;IACD,KAAK,QAAQ;MACZ,IAAAJ,QAAA,CAAAiB,OAAY,EAACf,MAAM,EAAEC,MAAM,EAAEC,IAAI,CAAC;MAClC;IACD,KAAK,SAAS;MACb,IAAAN,SAAA,CAAAmB,OAAa,EAACf,MAAM,EAAEC,MAAM,CAAC;MAC7BC,IAAI,EAAE;MACN;IACD,KAAK,MAAM;MACV,IAAAP,MAAA,CAAAoB,OAAU,EAACf,MAAM,EAAEC,MAAM,CAAC;MAC1BC,IAAI,EAAE;MACN;IACD,KAAK,UAAU;MAEdF,MAAM,CAACgB,QAAQ,GAAG,IAAI;MACtBd,IAAI,EAAE;MACN;IACD,KAAK,YAAY;MAChBF,MAAM,CAACQ,IAAI,CAAC,YAAY,EAAEP,MAAM,CAAC;MACjCC,IAAI,EAAE;MACN;IACD;MAECF,MAAM,CAACc,GAAG,CAAC,kCAAkC,CAAC;MAC9CZ,IAAI,EAAE;MACN;;AAEH,CAAC;AAEDe,OAAA,CAAAF,OAAA,GAAehB,MAAM"},"metadata":{},"sourceType":"script"}