{"ast":null,"code":"'use strict';\n\nconst {\n  ArrayIsArray,\n  ObjectSetPrototypeOf\n} = require('../../ours/primordials');\nconst {\n  EventEmitter: EE\n} = require('events');\nfunction Stream(opts) {\n  EE.call(this, opts);\n}\nObjectSetPrototypeOf(Stream.prototype, EE.prototype);\nObjectSetPrototypeOf(Stream, EE);\nStream.prototype.pipe = function (dest, options) {\n  const source = this;\n  function ondata(chunk) {\n    if (dest.writable && dest.write(chunk) === false && source.pause) {\n      source.pause();\n    }\n  }\n  source.on('data', ondata);\n  function ondrain() {\n    if (source.readable && source.resume) {\n      source.resume();\n    }\n  }\n  dest.on('drain', ondrain);\n\n  // If the 'end' option is not supplied, dest.end() will be called when\n  // source gets the 'end' or 'close' events.  Only dest.end() once.\n  if (!dest._isStdio && (!options || options.end !== false)) {\n    source.on('end', onend);\n    source.on('close', onclose);\n  }\n  let didOnEnd = false;\n  function onend() {\n    if (didOnEnd) return;\n    didOnEnd = true;\n    dest.end();\n  }\n  function onclose() {\n    if (didOnEnd) return;\n    didOnEnd = true;\n    if (typeof dest.destroy === 'function') dest.destroy();\n  }\n\n  // Don't leave dangling pipes when there are errors.\n  function onerror(er) {\n    cleanup();\n    if (EE.listenerCount(this, 'error') === 0) {\n      this.emit('error', er);\n    }\n  }\n  prependListener(source, 'error', onerror);\n  prependListener(dest, 'error', onerror);\n\n  // Remove all the event listeners that were added.\n  function cleanup() {\n    source.removeListener('data', ondata);\n    dest.removeListener('drain', ondrain);\n    source.removeListener('end', onend);\n    source.removeListener('close', onclose);\n    source.removeListener('error', onerror);\n    dest.removeListener('error', onerror);\n    source.removeListener('end', cleanup);\n    source.removeListener('close', cleanup);\n    dest.removeListener('close', cleanup);\n  }\n  source.on('end', cleanup);\n  source.on('close', cleanup);\n  dest.on('close', cleanup);\n  dest.emit('pipe', source);\n\n  // Allow for unix-like usage: A.pipe(B).pipe(C)\n  return dest;\n};\nfunction prependListener(emitter, event, fn) {\n  // Sadly this is not cacheable as some libraries bundle their own\n  // event emitter implementation with them.\n  if (typeof emitter.prependListener === 'function') return emitter.prependListener(event, fn);\n\n  // This is a hack to make sure that our error handler is attached before any\n  // userland ones.  NEVER DO THIS. This is here only because this code needs\n  // to continue to work with older versions of Node.js that do not include\n  // the prependListener() method. The goal is to eventually remove this hack.\n  if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);else if (ArrayIsArray(emitter._events[event])) emitter._events[event].unshift(fn);else emitter._events[event] = [fn, emitter._events[event]];\n}\nmodule.exports = {\n  Stream,\n  prependListener\n};","map":{"version":3,"names":["ArrayIsArray","ObjectSetPrototypeOf","require","EventEmitter","EE","Stream","opts","call","prototype","pipe","dest","options","source","ondata","chunk","writable","write","pause","on","ondrain","readable","resume","_isStdio","end","onend","onclose","didOnEnd","destroy","onerror","er","cleanup","listenerCount","emit","prependListener","removeListener","emitter","event","fn","_events","unshift","module","exports"],"sources":["/Users/jstanton/Coding/FieldDock/FieldDockMain/node_modules/mqtt/node_modules/readable-stream/lib/internal/streams/legacy.js"],"sourcesContent":["'use strict'\n\nconst { ArrayIsArray, ObjectSetPrototypeOf } = require('../../ours/primordials')\nconst { EventEmitter: EE } = require('events')\nfunction Stream(opts) {\n  EE.call(this, opts)\n}\nObjectSetPrototypeOf(Stream.prototype, EE.prototype)\nObjectSetPrototypeOf(Stream, EE)\nStream.prototype.pipe = function (dest, options) {\n  const source = this\n  function ondata(chunk) {\n    if (dest.writable && dest.write(chunk) === false && source.pause) {\n      source.pause()\n    }\n  }\n  source.on('data', ondata)\n  function ondrain() {\n    if (source.readable && source.resume) {\n      source.resume()\n    }\n  }\n  dest.on('drain', ondrain)\n\n  // If the 'end' option is not supplied, dest.end() will be called when\n  // source gets the 'end' or 'close' events.  Only dest.end() once.\n  if (!dest._isStdio && (!options || options.end !== false)) {\n    source.on('end', onend)\n    source.on('close', onclose)\n  }\n  let didOnEnd = false\n  function onend() {\n    if (didOnEnd) return\n    didOnEnd = true\n    dest.end()\n  }\n  function onclose() {\n    if (didOnEnd) return\n    didOnEnd = true\n    if (typeof dest.destroy === 'function') dest.destroy()\n  }\n\n  // Don't leave dangling pipes when there are errors.\n  function onerror(er) {\n    cleanup()\n    if (EE.listenerCount(this, 'error') === 0) {\n      this.emit('error', er)\n    }\n  }\n  prependListener(source, 'error', onerror)\n  prependListener(dest, 'error', onerror)\n\n  // Remove all the event listeners that were added.\n  function cleanup() {\n    source.removeListener('data', ondata)\n    dest.removeListener('drain', ondrain)\n    source.removeListener('end', onend)\n    source.removeListener('close', onclose)\n    source.removeListener('error', onerror)\n    dest.removeListener('error', onerror)\n    source.removeListener('end', cleanup)\n    source.removeListener('close', cleanup)\n    dest.removeListener('close', cleanup)\n  }\n  source.on('end', cleanup)\n  source.on('close', cleanup)\n  dest.on('close', cleanup)\n  dest.emit('pipe', source)\n\n  // Allow for unix-like usage: A.pipe(B).pipe(C)\n  return dest\n}\nfunction prependListener(emitter, event, fn) {\n  // Sadly this is not cacheable as some libraries bundle their own\n  // event emitter implementation with them.\n  if (typeof emitter.prependListener === 'function') return emitter.prependListener(event, fn)\n\n  // This is a hack to make sure that our error handler is attached before any\n  // userland ones.  NEVER DO THIS. This is here only because this code needs\n  // to continue to work with older versions of Node.js that do not include\n  // the prependListener() method. The goal is to eventually remove this hack.\n  if (!emitter._events || !emitter._events[event]) emitter.on(event, fn)\n  else if (ArrayIsArray(emitter._events[event])) emitter._events[event].unshift(fn)\n  else emitter._events[event] = [fn, emitter._events[event]]\n}\nmodule.exports = {\n  Stream,\n  prependListener\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}