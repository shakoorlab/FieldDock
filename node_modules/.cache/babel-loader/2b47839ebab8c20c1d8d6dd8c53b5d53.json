{"ast":null,"code":"var __extends = this && this.t || function () {\n  var extendStatics = function (e, r) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (e, r) {\n      e.__proto__ = r;\n    } || function (e, r) {\n      for (var i in r) if (Object.prototype.hasOwnProperty.call(r, i)) e[i] = r[i];\n    };\n    return extendStatics(e, r);\n  };\n  return function (e, r) {\n    if (typeof r !== \"function\" && r !== null) throw new TypeError(\"Class extends value \" + String(r) + \" is not a constructor or null\");\n    extendStatics(e, r);\n    function __() {\n      this.constructor = e;\n    }\n    e.prototype = r === null ? Object.create(r) : (__.prototype = r.prototype, new __());\n  };\n}();\nvar __read = this && this.q || function (e, r) {\n  var i = typeof Symbol === \"function\" && e[Symbol.iterator];\n  if (!i) return e;\n  var t = i.call(e),\n    n,\n    s = [],\n    f;\n  try {\n    while ((r === void 0 || r-- > 0) && !(n = t.next()).done) s.push(n.value);\n  } catch (e) {\n    f = {\n      error: e\n    };\n  } finally {\n    try {\n      if (n && !n.done && (i = t[\"return\"])) i.call(t);\n    } finally {\n      if (f) throw f.error;\n    }\n  }\n  return s;\n};\nvar __values = this && this.V || function (e) {\n  var r = typeof Symbol === \"function\" && Symbol.iterator,\n    i = r && e[r],\n    t = 0;\n  if (i) return i.call(e);\n  if (e && typeof e.length === \"number\") return {\n    next: function () {\n      if (e && t >= e.length) e = void 0;\n      return {\n        value: e && e[t++],\n        done: !e\n      };\n    }\n  };\n  throw new TypeError(r ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\nimport { TreeNode, TreeNodeEnableIndex } from \"./TreeNode\";\nimport { Container } from \"../../ContainerBase\";\nimport { throwIteratorAccessError } from \"../../../utils/throwError\";\nvar TreeContainer = function (e) {\n  __extends(TreeContainer, e);\n  function TreeContainer(r, i) {\n    if (r === void 0) {\n      r = function (e, r) {\n        if (e < r) return -1;\n        if (e > r) return 1;\n        return 0;\n      };\n    }\n    if (i === void 0) {\n      i = false;\n    }\n    var t = e.call(this) || this;\n    t.W = undefined;\n    t.$ = r;\n    if (i) {\n      t.re = TreeNodeEnableIndex;\n      t.v = function (e, r, i) {\n        var t = this.se(e, r, i);\n        if (t) {\n          var n = t.rr;\n          while (n !== this.h) {\n            n.tr += 1;\n            n = n.rr;\n          }\n          var s = this.fe(t);\n          if (s) {\n            var f = s,\n              h = f.parentNode,\n              u = f.grandParent,\n              a = f.curNode;\n            h.ie();\n            u.ie();\n            a.ie();\n          }\n        }\n        return this.M;\n      };\n      t.G = function (e) {\n        var r = this.he(e);\n        while (r !== this.h) {\n          r.tr -= 1;\n          r = r.rr;\n        }\n      };\n    } else {\n      t.re = TreeNode;\n      t.v = function (e, r, i) {\n        var t = this.se(e, r, i);\n        if (t) this.fe(t);\n        return this.M;\n      };\n      t.G = t.he;\n    }\n    t.h = new t.re();\n    return t;\n  }\n  TreeContainer.prototype.U = function (e, r) {\n    var i = this.h;\n    while (e) {\n      var t = this.$(e.u, r);\n      if (t < 0) {\n        e = e.N;\n      } else if (t > 0) {\n        i = e;\n        e = e.K;\n      } else return e;\n    }\n    return i;\n  };\n  TreeContainer.prototype.X = function (e, r) {\n    var i = this.h;\n    while (e) {\n      var t = this.$(e.u, r);\n      if (t <= 0) {\n        e = e.N;\n      } else {\n        i = e;\n        e = e.K;\n      }\n    }\n    return i;\n  };\n  TreeContainer.prototype.Y = function (e, r) {\n    var i = this.h;\n    while (e) {\n      var t = this.$(e.u, r);\n      if (t < 0) {\n        i = e;\n        e = e.N;\n      } else if (t > 0) {\n        e = e.K;\n      } else return e;\n    }\n    return i;\n  };\n  TreeContainer.prototype.Z = function (e, r) {\n    var i = this.h;\n    while (e) {\n      var t = this.$(e.u, r);\n      if (t < 0) {\n        i = e;\n        e = e.N;\n      } else {\n        e = e.K;\n      }\n    }\n    return i;\n  };\n  TreeContainer.prototype.ue = function (e) {\n    while (true) {\n      var r = e.rr;\n      if (r === this.h) return;\n      if (e.ee === 1) {\n        e.ee = 0;\n        return;\n      }\n      if (e === r.K) {\n        var i = r.N;\n        if (i.ee === 1) {\n          i.ee = 0;\n          r.ee = 1;\n          if (r === this.W) {\n            this.W = r.ne();\n          } else r.ne();\n        } else {\n          if (i.N && i.N.ee === 1) {\n            i.ee = r.ee;\n            r.ee = 0;\n            i.N.ee = 0;\n            if (r === this.W) {\n              this.W = r.ne();\n            } else r.ne();\n            return;\n          } else if (i.K && i.K.ee === 1) {\n            i.ee = 1;\n            i.K.ee = 0;\n            i.te();\n          } else {\n            i.ee = 1;\n            e = r;\n          }\n        }\n      } else {\n        var i = r.K;\n        if (i.ee === 1) {\n          i.ee = 0;\n          r.ee = 1;\n          if (r === this.W) {\n            this.W = r.te();\n          } else r.te();\n        } else {\n          if (i.K && i.K.ee === 1) {\n            i.ee = r.ee;\n            r.ee = 0;\n            i.K.ee = 0;\n            if (r === this.W) {\n              this.W = r.te();\n            } else r.te();\n            return;\n          } else if (i.N && i.N.ee === 1) {\n            i.ee = 1;\n            i.N.ee = 0;\n            i.ne();\n          } else {\n            i.ee = 1;\n            e = r;\n          }\n        }\n      }\n    }\n  };\n  TreeContainer.prototype.he = function (e) {\n    var r, i;\n    if (this.M === 1) {\n      this.clear();\n      return this.h;\n    }\n    var t = e;\n    while (t.K || t.N) {\n      if (t.N) {\n        t = t.N;\n        while (t.K) t = t.K;\n      } else {\n        t = t.K;\n      }\n      r = __read([t.u, e.u], 2), e.u = r[0], t.u = r[1];\n      i = __read([t.p, e.p], 2), e.p = i[0], t.p = i[1];\n      e = t;\n    }\n    if (this.h.K === t) {\n      this.h.K = t.rr;\n    } else if (this.h.N === t) {\n      this.h.N = t.rr;\n    }\n    this.ue(t);\n    var n = t.rr;\n    if (t === n.K) {\n      n.K = undefined;\n    } else n.N = undefined;\n    this.M -= 1;\n    this.W.ee = 0;\n    return n;\n  };\n  TreeContainer.prototype.ae = function (e, r) {\n    if (e === undefined) return false;\n    var i = this.ae(e.K, r);\n    if (i) return true;\n    if (r(e)) return true;\n    return this.ae(e.N, r);\n  };\n  TreeContainer.prototype.fe = function (e) {\n    while (true) {\n      var r = e.rr;\n      if (r.ee === 0) return;\n      var i = r.rr;\n      if (r === i.K) {\n        var t = i.N;\n        if (t && t.ee === 1) {\n          t.ee = r.ee = 0;\n          if (i === this.W) return;\n          i.ee = 1;\n          e = i;\n          continue;\n        } else if (e === r.N) {\n          e.ee = 0;\n          if (e.K) e.K.rr = r;\n          if (e.N) e.N.rr = i;\n          r.N = e.K;\n          i.K = e.N;\n          e.K = r;\n          e.N = i;\n          if (i === this.W) {\n            this.W = e;\n            this.h.rr = e;\n          } else {\n            var n = i.rr;\n            if (n.K === i) {\n              n.K = e;\n            } else n.N = e;\n          }\n          e.rr = i.rr;\n          r.rr = e;\n          i.rr = e;\n          i.ee = 1;\n          return {\n            parentNode: r,\n            grandParent: i,\n            curNode: e\n          };\n        } else {\n          r.ee = 0;\n          if (i === this.W) {\n            this.W = i.te();\n          } else i.te();\n          i.ee = 1;\n        }\n      } else {\n        var t = i.K;\n        if (t && t.ee === 1) {\n          t.ee = r.ee = 0;\n          if (i === this.W) return;\n          i.ee = 1;\n          e = i;\n          continue;\n        } else if (e === r.K) {\n          e.ee = 0;\n          if (e.K) e.K.rr = i;\n          if (e.N) e.N.rr = r;\n          i.N = e.K;\n          r.K = e.N;\n          e.K = i;\n          e.N = r;\n          if (i === this.W) {\n            this.W = e;\n            this.h.rr = e;\n          } else {\n            var n = i.rr;\n            if (n.K === i) {\n              n.K = e;\n            } else n.N = e;\n          }\n          e.rr = i.rr;\n          r.rr = e;\n          i.rr = e;\n          i.ee = 1;\n          return {\n            parentNode: r,\n            grandParent: i,\n            curNode: e\n          };\n        } else {\n          r.ee = 0;\n          if (i === this.W) {\n            this.W = i.ne();\n          } else i.ne();\n          i.ee = 1;\n        }\n      }\n      return;\n    }\n  };\n  TreeContainer.prototype.se = function (e, r, i) {\n    if (this.W === undefined) {\n      this.M += 1;\n      this.W = new this.re(e, r);\n      this.W.ee = 0;\n      this.W.rr = this.h;\n      this.h.rr = this.W;\n      this.h.K = this.W;\n      this.h.N = this.W;\n      return;\n    }\n    var t;\n    var n = this.h.K;\n    var s = this.$(n.u, e);\n    if (s === 0) {\n      n.p = r;\n      return;\n    } else if (s > 0) {\n      n.K = new this.re(e, r);\n      n.K.rr = n;\n      t = n.K;\n      this.h.K = t;\n    } else {\n      var f = this.h.N;\n      var h = this.$(f.u, e);\n      if (h === 0) {\n        f.p = r;\n        return;\n      } else if (h < 0) {\n        f.N = new this.re(e, r);\n        f.N.rr = f;\n        t = f.N;\n        this.h.N = t;\n      } else {\n        if (i !== undefined) {\n          var u = i.o;\n          if (u !== this.h) {\n            var a = this.$(u.u, e);\n            if (a === 0) {\n              u.p = r;\n              return;\n            } else if (a > 0) {\n              var o = u.L();\n              var l = this.$(o.u, e);\n              if (l === 0) {\n                o.p = r;\n                return;\n              } else if (l < 0) {\n                t = new this.re(e, r);\n                if (o.N === undefined) {\n                  o.N = t;\n                  t.rr = o;\n                } else {\n                  u.K = t;\n                  t.rr = u;\n                }\n              }\n            }\n          }\n        }\n        if (t === undefined) {\n          t = this.W;\n          while (true) {\n            var v = this.$(t.u, e);\n            if (v > 0) {\n              if (t.K === undefined) {\n                t.K = new this.re(e, r);\n                t.K.rr = t;\n                t = t.K;\n                break;\n              }\n              t = t.K;\n            } else if (v < 0) {\n              if (t.N === undefined) {\n                t.N = new this.re(e, r);\n                t.N.rr = t;\n                t = t.N;\n                break;\n              }\n              t = t.N;\n            } else {\n              t.p = r;\n              return;\n            }\n          }\n        }\n      }\n    }\n    this.M += 1;\n    return t;\n  };\n  TreeContainer.prototype.g = function (e, r) {\n    while (e) {\n      var i = this.$(e.u, r);\n      if (i < 0) {\n        e = e.N;\n      } else if (i > 0) {\n        e = e.K;\n      } else return e;\n    }\n    return e || this.h;\n  };\n  TreeContainer.prototype.clear = function () {\n    this.M = 0;\n    this.W = undefined;\n    this.h.rr = undefined;\n    this.h.K = this.h.N = undefined;\n  };\n  TreeContainer.prototype.updateKeyByIterator = function (e, r) {\n    var i = e.o;\n    if (i === this.h) {\n      throwIteratorAccessError();\n    }\n    if (this.M === 1) {\n      i.u = r;\n      return true;\n    }\n    if (i === this.h.K) {\n      if (this.$(i.m().u, r) > 0) {\n        i.u = r;\n        return true;\n      }\n      return false;\n    }\n    if (i === this.h.N) {\n      if (this.$(i.L().u, r) < 0) {\n        i.u = r;\n        return true;\n      }\n      return false;\n    }\n    var t = i.L().u;\n    if (this.$(t, r) >= 0) return false;\n    var n = i.m().u;\n    if (this.$(n, r) <= 0) return false;\n    i.u = r;\n    return true;\n  };\n  TreeContainer.prototype.eraseElementByPos = function (e) {\n    if (e < 0 || e > this.M - 1) {\n      throw new RangeError();\n    }\n    var r = 0;\n    var i = this;\n    this.ae(this.W, function (t) {\n      if (e === r) {\n        i.G(t);\n        return true;\n      }\n      r += 1;\n      return false;\n    });\n    return this.M;\n  };\n  TreeContainer.prototype.eraseElementByKey = function (e) {\n    if (this.M === 0) return false;\n    var r = this.g(this.W, e);\n    if (r === this.h) return false;\n    this.G(r);\n    return true;\n  };\n  TreeContainer.prototype.eraseElementByIterator = function (e) {\n    var r = e.o;\n    if (r === this.h) {\n      throwIteratorAccessError();\n    }\n    var i = r.N === undefined;\n    var t = e.iteratorType === 0;\n    if (t) {\n      if (i) e.next();\n    } else {\n      if (!i || r.K === undefined) e.next();\n    }\n    this.G(r);\n    return e;\n  };\n  TreeContainer.prototype.forEach = function (e) {\n    var r, i;\n    var t = 0;\n    try {\n      for (var n = __values(this), s = n.next(); !s.done; s = n.next()) {\n        var f = s.value;\n        e(f, t++, this);\n      }\n    } catch (e) {\n      r = {\n        error: e\n      };\n    } finally {\n      try {\n        if (s && !s.done && (i = n.return)) i.call(n);\n      } finally {\n        if (r) throw r.error;\n      }\n    }\n  };\n  TreeContainer.prototype.getElementByPos = function (e) {\n    var r, i;\n    if (e < 0 || e > this.M - 1) {\n      throw new RangeError();\n    }\n    var t;\n    var n = 0;\n    try {\n      for (var s = __values(this), f = s.next(); !f.done; f = s.next()) {\n        var h = f.value;\n        if (n === e) {\n          t = h;\n          break;\n        }\n        n += 1;\n      }\n    } catch (e) {\n      r = {\n        error: e\n      };\n    } finally {\n      try {\n        if (f && !f.done && (i = s.return)) i.call(s);\n      } finally {\n        if (r) throw r.error;\n      }\n    }\n    return t;\n  };\n  TreeContainer.prototype.getHeight = function () {\n    if (this.M === 0) return 0;\n    var traversal = function (e) {\n      if (!e) return 0;\n      return Math.max(traversal(e.K), traversal(e.N)) + 1;\n    };\n    return traversal(this.W);\n  };\n  return TreeContainer;\n}(Container);\nexport default TreeContainer;","map":{"version":3,"names":["__extends","t","extendStatics","e","r","Object","setPrototypeOf","__proto__","Array","i","prototype","hasOwnProperty","call","TypeError","String","__","constructor","create","__read","q","Symbol","iterator","n","s","f","next","done","push","value","error","__values","V","length","TreeNode","TreeNodeEnableIndex","Container","throwIteratorAccessError","TreeContainer","cmp","W","undefined","$","re","v","se","rr","h","tr","fe","parentNode","u","grandParent","a","curNode","ie","M","G","he","U","N","K","X","Y","Z","ue","ee","ne","te","clear","p","ae","o","L","l","g","updateKeyByIterator","m","eraseElementByPos","RangeError","eraseElementByKey","eraseElementByIterator","iteratorType","forEach","return","getElementByPos","getHeight","traversal","Math","max"],"sources":["/Users/jstanton/Coding/FieldDock/FieldDockMain/node_modules/js-sdsl/dist/esm/container/TreeContainer/Base/container/TreeContainer/Base/index.js","/Users/jstanton/Coding/FieldDock/FieldDockMain/node_modules/js-sdsl/dist/esm/container/src/container/TreeContainer/Base/index.ts"],"sourcesContent":["var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __read = (this && this.__read) || function (o, n) {\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n    if (!m) return o;\n    var i = m.call(o), r, ar = [], e;\n    try {\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n    }\n    catch (error) { e = { error: error }; }\n    finally {\n        try {\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\n        }\n        finally { if (e) throw e.error; }\n    }\n    return ar;\n};\nvar __values = (this && this.__values) || function(o) {\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\n    if (m) return m.call(o);\n    if (o && typeof o.length === \"number\") return {\n        next: function () {\n            if (o && i >= o.length) o = void 0;\n            return { value: o && o[i++], done: !o };\n        }\n    };\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\nimport { TreeNode, TreeNodeEnableIndex } from './TreeNode';\nimport { Container } from \"../../ContainerBase\";\nimport $checkWithinAccessParams from \"../../../utils/checkParams.macro\";\nimport { throwIteratorAccessError } from \"../../../utils/throwError\";\nvar TreeContainer = /** @class */ (function (_super) {\n    __extends(TreeContainer, _super);\n    /**\n     * @internal\n     */\n    function TreeContainer(cmp, enableIndex) {\n        if (cmp === void 0) { cmp = function (x, y) {\n            if (x < y)\n                return -1;\n            if (x > y)\n                return 1;\n            return 0;\n        }; }\n        if (enableIndex === void 0) { enableIndex = false; }\n        var _this = _super.call(this) || this;\n        /**\n         * @internal\n         */\n        _this._root = undefined;\n        _this._cmp = cmp;\n        if (enableIndex) {\n            _this._TreeNodeClass = TreeNodeEnableIndex;\n            _this._set = function (key, value, hint) {\n                var curNode = this._preSet(key, value, hint);\n                if (curNode) {\n                    var p = curNode._parent;\n                    while (p !== this._header) {\n                        p._subTreeSize += 1;\n                        p = p._parent;\n                    }\n                    var nodeList = this._insertNodeSelfBalance(curNode);\n                    if (nodeList) {\n                        var _a = nodeList, parentNode = _a.parentNode, grandParent = _a.grandParent, curNode_1 = _a.curNode;\n                        parentNode._recount();\n                        grandParent._recount();\n                        curNode_1._recount();\n                    }\n                }\n                return this._length;\n            };\n            _this._eraseNode = function (curNode) {\n                var p = this._preEraseNode(curNode);\n                while (p !== this._header) {\n                    p._subTreeSize -= 1;\n                    p = p._parent;\n                }\n            };\n        }\n        else {\n            _this._TreeNodeClass = TreeNode;\n            _this._set = function (key, value, hint) {\n                var curNode = this._preSet(key, value, hint);\n                if (curNode)\n                    this._insertNodeSelfBalance(curNode);\n                return this._length;\n            };\n            _this._eraseNode = _this._preEraseNode;\n        }\n        _this._header = new _this._TreeNodeClass();\n        return _this;\n    }\n    /**\n     * @internal\n     */\n    TreeContainer.prototype._lowerBound = function (curNode, key) {\n        var resNode = this._header;\n        while (curNode) {\n            var cmpResult = this._cmp(curNode._key, key);\n            if (cmpResult < 0) {\n                curNode = curNode._right;\n            }\n            else if (cmpResult > 0) {\n                resNode = curNode;\n                curNode = curNode._left;\n            }\n            else\n                return curNode;\n        }\n        return resNode;\n    };\n    /**\n     * @internal\n     */\n    TreeContainer.prototype._upperBound = function (curNode, key) {\n        var resNode = this._header;\n        while (curNode) {\n            var cmpResult = this._cmp(curNode._key, key);\n            if (cmpResult <= 0) {\n                curNode = curNode._right;\n            }\n            else {\n                resNode = curNode;\n                curNode = curNode._left;\n            }\n        }\n        return resNode;\n    };\n    /**\n     * @internal\n     */\n    TreeContainer.prototype._reverseLowerBound = function (curNode, key) {\n        var resNode = this._header;\n        while (curNode) {\n            var cmpResult = this._cmp(curNode._key, key);\n            if (cmpResult < 0) {\n                resNode = curNode;\n                curNode = curNode._right;\n            }\n            else if (cmpResult > 0) {\n                curNode = curNode._left;\n            }\n            else\n                return curNode;\n        }\n        return resNode;\n    };\n    /**\n     * @internal\n     */\n    TreeContainer.prototype._reverseUpperBound = function (curNode, key) {\n        var resNode = this._header;\n        while (curNode) {\n            var cmpResult = this._cmp(curNode._key, key);\n            if (cmpResult < 0) {\n                resNode = curNode;\n                curNode = curNode._right;\n            }\n            else {\n                curNode = curNode._left;\n            }\n        }\n        return resNode;\n    };\n    /**\n     * @internal\n     */\n    TreeContainer.prototype._eraseNodeSelfBalance = function (curNode) {\n        while (true) {\n            var parentNode = curNode._parent;\n            if (parentNode === this._header)\n                return;\n            if (curNode._color === 1 /* TreeNodeColor.RED */) {\n                curNode._color = 0 /* TreeNodeColor.BLACK */;\n                return;\n            }\n            if (curNode === parentNode._left) {\n                var brother = parentNode._right;\n                if (brother._color === 1 /* TreeNodeColor.RED */) {\n                    brother._color = 0 /* TreeNodeColor.BLACK */;\n                    parentNode._color = 1 /* TreeNodeColor.RED */;\n                    if (parentNode === this._root) {\n                        this._root = parentNode._rotateLeft();\n                    }\n                    else\n                        parentNode._rotateLeft();\n                }\n                else {\n                    if (brother._right && brother._right._color === 1 /* TreeNodeColor.RED */) {\n                        brother._color = parentNode._color;\n                        parentNode._color = 0 /* TreeNodeColor.BLACK */;\n                        brother._right._color = 0 /* TreeNodeColor.BLACK */;\n                        if (parentNode === this._root) {\n                            this._root = parentNode._rotateLeft();\n                        }\n                        else\n                            parentNode._rotateLeft();\n                        return;\n                    }\n                    else if (brother._left && brother._left._color === 1 /* TreeNodeColor.RED */) {\n                        brother._color = 1 /* TreeNodeColor.RED */;\n                        brother._left._color = 0 /* TreeNodeColor.BLACK */;\n                        brother._rotateRight();\n                    }\n                    else {\n                        brother._color = 1 /* TreeNodeColor.RED */;\n                        curNode = parentNode;\n                    }\n                }\n            }\n            else {\n                var brother = parentNode._left;\n                if (brother._color === 1 /* TreeNodeColor.RED */) {\n                    brother._color = 0 /* TreeNodeColor.BLACK */;\n                    parentNode._color = 1 /* TreeNodeColor.RED */;\n                    if (parentNode === this._root) {\n                        this._root = parentNode._rotateRight();\n                    }\n                    else\n                        parentNode._rotateRight();\n                }\n                else {\n                    if (brother._left && brother._left._color === 1 /* TreeNodeColor.RED */) {\n                        brother._color = parentNode._color;\n                        parentNode._color = 0 /* TreeNodeColor.BLACK */;\n                        brother._left._color = 0 /* TreeNodeColor.BLACK */;\n                        if (parentNode === this._root) {\n                            this._root = parentNode._rotateRight();\n                        }\n                        else\n                            parentNode._rotateRight();\n                        return;\n                    }\n                    else if (brother._right && brother._right._color === 1 /* TreeNodeColor.RED */) {\n                        brother._color = 1 /* TreeNodeColor.RED */;\n                        brother._right._color = 0 /* TreeNodeColor.BLACK */;\n                        brother._rotateLeft();\n                    }\n                    else {\n                        brother._color = 1 /* TreeNodeColor.RED */;\n                        curNode = parentNode;\n                    }\n                }\n            }\n        }\n    };\n    /**\n     * @internal\n     */\n    TreeContainer.prototype._preEraseNode = function (curNode) {\n        var _a, _b;\n        if (this._length === 1) {\n            this.clear();\n            return this._header;\n        }\n        var swapNode = curNode;\n        while (swapNode._left || swapNode._right) {\n            if (swapNode._right) {\n                swapNode = swapNode._right;\n                while (swapNode._left)\n                    swapNode = swapNode._left;\n            }\n            else {\n                swapNode = swapNode._left;\n            }\n            _a = __read([swapNode._key, curNode._key], 2), curNode._key = _a[0], swapNode._key = _a[1];\n            _b = __read([swapNode._value, curNode._value], 2), curNode._value = _b[0], swapNode._value = _b[1];\n            curNode = swapNode;\n        }\n        if (this._header._left === swapNode) {\n            this._header._left = swapNode._parent;\n        }\n        else if (this._header._right === swapNode) {\n            this._header._right = swapNode._parent;\n        }\n        this._eraseNodeSelfBalance(swapNode);\n        var _parent = swapNode._parent;\n        if (swapNode === _parent._left) {\n            _parent._left = undefined;\n        }\n        else\n            _parent._right = undefined;\n        this._length -= 1;\n        this._root._color = 0 /* TreeNodeColor.BLACK */;\n        return _parent;\n    };\n    /**\n     * @internal\n     */\n    TreeContainer.prototype._inOrderTraversal = function (curNode, callback) {\n        if (curNode === undefined)\n            return false;\n        var ifReturn = this._inOrderTraversal(curNode._left, callback);\n        if (ifReturn)\n            return true;\n        if (callback(curNode))\n            return true;\n        return this._inOrderTraversal(curNode._right, callback);\n    };\n    /**\n     * @internal\n     */\n    TreeContainer.prototype._insertNodeSelfBalance = function (curNode) {\n        while (true) {\n            var parentNode = curNode._parent;\n            if (parentNode._color === 0 /* TreeNodeColor.BLACK */)\n                return;\n            var grandParent = parentNode._parent;\n            if (parentNode === grandParent._left) {\n                var uncle = grandParent._right;\n                if (uncle && uncle._color === 1 /* TreeNodeColor.RED */) {\n                    uncle._color = parentNode._color = 0 /* TreeNodeColor.BLACK */;\n                    if (grandParent === this._root)\n                        return;\n                    grandParent._color = 1 /* TreeNodeColor.RED */;\n                    curNode = grandParent;\n                    continue;\n                }\n                else if (curNode === parentNode._right) {\n                    curNode._color = 0 /* TreeNodeColor.BLACK */;\n                    if (curNode._left)\n                        curNode._left._parent = parentNode;\n                    if (curNode._right)\n                        curNode._right._parent = grandParent;\n                    parentNode._right = curNode._left;\n                    grandParent._left = curNode._right;\n                    curNode._left = parentNode;\n                    curNode._right = grandParent;\n                    if (grandParent === this._root) {\n                        this._root = curNode;\n                        this._header._parent = curNode;\n                    }\n                    else {\n                        var GP = grandParent._parent;\n                        if (GP._left === grandParent) {\n                            GP._left = curNode;\n                        }\n                        else\n                            GP._right = curNode;\n                    }\n                    curNode._parent = grandParent._parent;\n                    parentNode._parent = curNode;\n                    grandParent._parent = curNode;\n                    grandParent._color = 1 /* TreeNodeColor.RED */;\n                    return { parentNode: parentNode, grandParent: grandParent, curNode: curNode };\n                }\n                else {\n                    parentNode._color = 0 /* TreeNodeColor.BLACK */;\n                    if (grandParent === this._root) {\n                        this._root = grandParent._rotateRight();\n                    }\n                    else\n                        grandParent._rotateRight();\n                    grandParent._color = 1 /* TreeNodeColor.RED */;\n                }\n            }\n            else {\n                var uncle = grandParent._left;\n                if (uncle && uncle._color === 1 /* TreeNodeColor.RED */) {\n                    uncle._color = parentNode._color = 0 /* TreeNodeColor.BLACK */;\n                    if (grandParent === this._root)\n                        return;\n                    grandParent._color = 1 /* TreeNodeColor.RED */;\n                    curNode = grandParent;\n                    continue;\n                }\n                else if (curNode === parentNode._left) {\n                    curNode._color = 0 /* TreeNodeColor.BLACK */;\n                    if (curNode._left)\n                        curNode._left._parent = grandParent;\n                    if (curNode._right)\n                        curNode._right._parent = parentNode;\n                    grandParent._right = curNode._left;\n                    parentNode._left = curNode._right;\n                    curNode._left = grandParent;\n                    curNode._right = parentNode;\n                    if (grandParent === this._root) {\n                        this._root = curNode;\n                        this._header._parent = curNode;\n                    }\n                    else {\n                        var GP = grandParent._parent;\n                        if (GP._left === grandParent) {\n                            GP._left = curNode;\n                        }\n                        else\n                            GP._right = curNode;\n                    }\n                    curNode._parent = grandParent._parent;\n                    parentNode._parent = curNode;\n                    grandParent._parent = curNode;\n                    grandParent._color = 1 /* TreeNodeColor.RED */;\n                    return { parentNode: parentNode, grandParent: grandParent, curNode: curNode };\n                }\n                else {\n                    parentNode._color = 0 /* TreeNodeColor.BLACK */;\n                    if (grandParent === this._root) {\n                        this._root = grandParent._rotateLeft();\n                    }\n                    else\n                        grandParent._rotateLeft();\n                    grandParent._color = 1 /* TreeNodeColor.RED */;\n                }\n            }\n            return;\n        }\n    };\n    /**\n     * @internal\n     */\n    TreeContainer.prototype._preSet = function (key, value, hint) {\n        if (this._root === undefined) {\n            this._length += 1;\n            this._root = new this._TreeNodeClass(key, value);\n            this._root._color = 0 /* TreeNodeColor.BLACK */;\n            this._root._parent = this._header;\n            this._header._parent = this._root;\n            this._header._left = this._root;\n            this._header._right = this._root;\n            return;\n        }\n        var curNode;\n        var minNode = this._header._left;\n        var compareToMin = this._cmp(minNode._key, key);\n        if (compareToMin === 0) {\n            minNode._value = value;\n            return;\n        }\n        else if (compareToMin > 0) {\n            minNode._left = new this._TreeNodeClass(key, value);\n            minNode._left._parent = minNode;\n            curNode = minNode._left;\n            this._header._left = curNode;\n        }\n        else {\n            var maxNode = this._header._right;\n            var compareToMax = this._cmp(maxNode._key, key);\n            if (compareToMax === 0) {\n                maxNode._value = value;\n                return;\n            }\n            else if (compareToMax < 0) {\n                maxNode._right = new this._TreeNodeClass(key, value);\n                maxNode._right._parent = maxNode;\n                curNode = maxNode._right;\n                this._header._right = curNode;\n            }\n            else {\n                if (hint !== undefined) {\n                    var iterNode = hint._node;\n                    if (iterNode !== this._header) {\n                        var iterCmpRes = this._cmp(iterNode._key, key);\n                        if (iterCmpRes === 0) {\n                            iterNode._value = value;\n                            return;\n                        }\n                        else /* istanbul ignore else */ if (iterCmpRes > 0) {\n                            var preNode = iterNode._pre();\n                            var preCmpRes = this._cmp(preNode._key, key);\n                            if (preCmpRes === 0) {\n                                preNode._value = value;\n                                return;\n                            }\n                            else if (preCmpRes < 0) {\n                                curNode = new this._TreeNodeClass(key, value);\n                                if (preNode._right === undefined) {\n                                    preNode._right = curNode;\n                                    curNode._parent = preNode;\n                                }\n                                else {\n                                    iterNode._left = curNode;\n                                    curNode._parent = iterNode;\n                                }\n                            }\n                        }\n                    }\n                }\n                if (curNode === undefined) {\n                    curNode = this._root;\n                    while (true) {\n                        var cmpResult = this._cmp(curNode._key, key);\n                        if (cmpResult > 0) {\n                            if (curNode._left === undefined) {\n                                curNode._left = new this._TreeNodeClass(key, value);\n                                curNode._left._parent = curNode;\n                                curNode = curNode._left;\n                                break;\n                            }\n                            curNode = curNode._left;\n                        }\n                        else if (cmpResult < 0) {\n                            if (curNode._right === undefined) {\n                                curNode._right = new this._TreeNodeClass(key, value);\n                                curNode._right._parent = curNode;\n                                curNode = curNode._right;\n                                break;\n                            }\n                            curNode = curNode._right;\n                        }\n                        else {\n                            curNode._value = value;\n                            return;\n                        }\n                    }\n                }\n            }\n        }\n        this._length += 1;\n        return curNode;\n    };\n    /**\n     * @internal\n     */\n    TreeContainer.prototype._findElementNode = function (curNode, key) {\n        while (curNode) {\n            var cmpResult = this._cmp(curNode._key, key);\n            if (cmpResult < 0) {\n                curNode = curNode._right;\n            }\n            else if (cmpResult > 0) {\n                curNode = curNode._left;\n            }\n            else\n                return curNode;\n        }\n        return curNode || this._header;\n    };\n    TreeContainer.prototype.clear = function () {\n        this._length = 0;\n        this._root = undefined;\n        this._header._parent = undefined;\n        this._header._left = this._header._right = undefined;\n    };\n    /**\n     * @description Update node's key by iterator.\n     * @param iter - The iterator you want to change.\n     * @param key - The key you want to update.\n     * @returns Whether the modification is successful.\n     * @example\n     * const st = new orderedSet([1, 2, 5]);\n     * const iter = st.find(2);\n     * st.updateKeyByIterator(iter, 3); // then st will become [1, 3, 5]\n     */\n    TreeContainer.prototype.updateKeyByIterator = function (iter, key) {\n        var node = iter._node;\n        if (node === this._header) {\n            throwIteratorAccessError();\n        }\n        if (this._length === 1) {\n            node._key = key;\n            return true;\n        }\n        if (node === this._header._left) {\n            if (this._cmp(node._next()._key, key) > 0) {\n                node._key = key;\n                return true;\n            }\n            return false;\n        }\n        if (node === this._header._right) {\n            if (this._cmp(node._pre()._key, key) < 0) {\n                node._key = key;\n                return true;\n            }\n            return false;\n        }\n        var preKey = node._pre()._key;\n        if (this._cmp(preKey, key) >= 0)\n            return false;\n        var nextKey = node._next()._key;\n        if (this._cmp(nextKey, key) <= 0)\n            return false;\n        node._key = key;\n        return true;\n    };\n    TreeContainer.prototype.eraseElementByPos = function (pos) {\n        if (pos < 0 || pos > this._length - 1) {\n            throw new RangeError();\n        }\n        var index = 0;\n        var self = this;\n        this._inOrderTraversal(this._root, function (curNode) {\n            if (pos === index) {\n                self._eraseNode(curNode);\n                return true;\n            }\n            index += 1;\n            return false;\n        });\n        return this._length;\n    };\n    /**\n     * @description Remove the element of the specified key.\n     * @param key - The key you want to remove.\n     * @returns Whether erase successfully.\n     */\n    TreeContainer.prototype.eraseElementByKey = function (key) {\n        if (this._length === 0)\n            return false;\n        var curNode = this._findElementNode(this._root, key);\n        if (curNode === this._header)\n            return false;\n        this._eraseNode(curNode);\n        return true;\n    };\n    TreeContainer.prototype.eraseElementByIterator = function (iter) {\n        var node = iter._node;\n        if (node === this._header) {\n            throwIteratorAccessError();\n        }\n        var hasNoRight = node._right === undefined;\n        var isNormal = iter.iteratorType === 0 /* IteratorType.NORMAL */;\n        // For the normal iterator, the `next` node will be swapped to `this` node when has right.\n        if (isNormal) {\n            // So we should move it to next when it's right is null.\n            if (hasNoRight)\n                iter.next();\n        }\n        else {\n            // For the reverse iterator, only when it doesn't have right and has left the `next` node will be swapped.\n            // So when it has right, or it is a leaf node we should move it to `next`.\n            if (!hasNoRight || node._left === undefined)\n                iter.next();\n        }\n        this._eraseNode(node);\n        return iter;\n    };\n    TreeContainer.prototype.forEach = function (callback) {\n        var e_1, _a;\n        var index = 0;\n        try {\n            for (var _b = __values(this), _c = _b.next(); !_c.done; _c = _b.next()) {\n                var element = _c.value;\n                callback(element, index++, this);\n            }\n        }\n        catch (e_1_1) { e_1 = { error: e_1_1 }; }\n        finally {\n            try {\n                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n            }\n            finally { if (e_1) throw e_1.error; }\n        }\n    };\n    TreeContainer.prototype.getElementByPos = function (pos) {\n        var e_2, _a;\n        if (pos < 0 || pos > this._length - 1) {\n            throw new RangeError();\n        }\n        var res;\n        var index = 0;\n        try {\n            for (var _b = __values(this), _c = _b.next(); !_c.done; _c = _b.next()) {\n                var element = _c.value;\n                if (index === pos) {\n                    res = element;\n                    break;\n                }\n                index += 1;\n            }\n        }\n        catch (e_2_1) { e_2 = { error: e_2_1 }; }\n        finally {\n            try {\n                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n            }\n            finally { if (e_2) throw e_2.error; }\n        }\n        return res;\n    };\n    /**\n     * @description Get the height of the tree.\n     * @returns Number about the height of the RB-tree.\n     */\n    TreeContainer.prototype.getHeight = function () {\n        if (this._length === 0)\n            return 0;\n        var traversal = function (curNode) {\n            if (!curNode)\n                return 0;\n            return Math.max(traversal(curNode._left), traversal(curNode._right)) + 1;\n        };\n        return traversal(this._root);\n    };\n    return TreeContainer;\n}(Container));\nexport default TreeContainer;\n","import type TreeIterator from './TreeIterator';\nimport { TreeNode, TreeNodeColor, TreeNodeEnableIndex } from './TreeNode';\nimport { Container, IteratorType } from '@/container/ContainerBase';\nimport $checkWithinAccessParams from '@/utils/checkParams.macro';\nimport { throwIteratorAccessError } from '@/utils/throwError';\n\nabstract class TreeContainer<K, V> extends Container<K | [K, V]> {\n  /**\n   * @internal\n   */\n  protected _root: TreeNode<K, V> | undefined = undefined;\n  /**\n   * @internal\n   */\n  protected _header: TreeNode<K, V>;\n  /**\n   * @internal\n   */\n  protected readonly _cmp: (x: K, y: K) => number;\n  /**\n   * @internal\n   */\n  protected readonly _TreeNodeClass: typeof TreeNode | typeof TreeNodeEnableIndex;\n  /**\n   * @internal\n   */\n  protected readonly _eraseNode: (curNode: TreeNode<K, V>) => void;\n  /**\n   * @internal\n   */\n  protected _set: (key: K, value: V, hint?: TreeIterator<K, V>) => number;\n  /**\n   * @internal\n   */\n  protected constructor(\n    cmp: (x: K, y: K) => number =\n    function (x: K, y: K) {\n      if (x < y) return -1;\n      if (x > y) return 1;\n      return 0;\n    },\n    enableIndex = false\n  ) {\n    super();\n    this._cmp = cmp;\n    if (enableIndex) {\n      this._TreeNodeClass = TreeNodeEnableIndex;\n      this._set = function (key, value, hint) {\n        const curNode = this._preSet(key, value, hint);\n        if (curNode) {\n          let p = curNode._parent as TreeNodeEnableIndex<K, V>;\n          while (p !== this._header) {\n            p._subTreeSize += 1;\n            p = p._parent as TreeNodeEnableIndex<K, V>;\n          }\n          const nodeList = this._insertNodeSelfBalance(curNode);\n          if (nodeList) {\n            const {\n              parentNode,\n              grandParent,\n              curNode\n            } = nodeList as unknown as Record<string, TreeNodeEnableIndex<K, V>>;\n            parentNode._recount();\n            grandParent._recount();\n            curNode._recount();\n          }\n        }\n        return this._length;\n      };\n      this._eraseNode = function (curNode) {\n        let p = this._preEraseNode(curNode) as TreeNodeEnableIndex<K, V>;\n        while (p !== this._header) {\n          p._subTreeSize -= 1;\n          p = p._parent as TreeNodeEnableIndex<K, V>;\n        }\n      };\n    } else {\n      this._TreeNodeClass = TreeNode;\n      this._set = function (key, value, hint) {\n        const curNode = this._preSet(key, value, hint);\n        if (curNode) this._insertNodeSelfBalance(curNode);\n        return this._length;\n      };\n      this._eraseNode = this._preEraseNode;\n    }\n    this._header = new this._TreeNodeClass();\n  }\n  /**\n   * @internal\n   */\n  protected _lowerBound(curNode: TreeNode<K, V> | undefined, key: K) {\n    let resNode = this._header;\n    while (curNode) {\n      const cmpResult = this._cmp(curNode._key!, key);\n      if (cmpResult < 0) {\n        curNode = curNode._right;\n      } else if (cmpResult > 0) {\n        resNode = curNode;\n        curNode = curNode._left;\n      } else return curNode;\n    }\n    return resNode;\n  }\n  /**\n   * @internal\n   */\n  protected _upperBound(curNode: TreeNode<K, V> | undefined, key: K) {\n    let resNode = this._header;\n    while (curNode) {\n      const cmpResult = this._cmp(curNode._key!, key);\n      if (cmpResult <= 0) {\n        curNode = curNode._right;\n      } else {\n        resNode = curNode;\n        curNode = curNode._left;\n      }\n    }\n    return resNode;\n  }\n  /**\n   * @internal\n   */\n  protected _reverseLowerBound(curNode: TreeNode<K, V> | undefined, key: K) {\n    let resNode = this._header;\n    while (curNode) {\n      const cmpResult = this._cmp(curNode._key!, key);\n      if (cmpResult < 0) {\n        resNode = curNode;\n        curNode = curNode._right;\n      } else if (cmpResult > 0) {\n        curNode = curNode._left;\n      } else return curNode;\n    }\n    return resNode;\n  }\n  /**\n   * @internal\n   */\n  protected _reverseUpperBound(curNode: TreeNode<K, V> | undefined, key: K) {\n    let resNode = this._header;\n    while (curNode) {\n      const cmpResult = this._cmp(curNode._key!, key);\n      if (cmpResult < 0) {\n        resNode = curNode;\n        curNode = curNode._right;\n      } else {\n        curNode = curNode._left;\n      }\n    }\n    return resNode;\n  }\n  /**\n   * @internal\n   */\n  protected _eraseNodeSelfBalance(curNode: TreeNode<K, V>) {\n    while (true) {\n      const parentNode = curNode._parent!;\n      if (parentNode === this._header) return;\n      if (curNode._color === TreeNodeColor.RED) {\n        curNode._color = TreeNodeColor.BLACK;\n        return;\n      }\n      if (curNode === parentNode._left) {\n        const brother = parentNode._right!;\n        if (brother._color === TreeNodeColor.RED) {\n          brother._color = TreeNodeColor.BLACK;\n          parentNode._color = TreeNodeColor.RED;\n          if (parentNode === this._root) {\n            this._root = parentNode._rotateLeft();\n          } else parentNode._rotateLeft();\n        } else {\n          if (brother._right && brother._right._color === TreeNodeColor.RED) {\n            brother._color = parentNode._color;\n            parentNode._color = TreeNodeColor.BLACK;\n            brother._right._color = TreeNodeColor.BLACK;\n            if (parentNode === this._root) {\n              this._root = parentNode._rotateLeft();\n            } else parentNode._rotateLeft();\n            return;\n          } else if (brother._left && brother._left._color === TreeNodeColor.RED) {\n            brother._color = TreeNodeColor.RED;\n            brother._left._color = TreeNodeColor.BLACK;\n            brother._rotateRight();\n          } else {\n            brother._color = TreeNodeColor.RED;\n            curNode = parentNode;\n          }\n        }\n      } else {\n        const brother = parentNode._left!;\n        if (brother._color === TreeNodeColor.RED) {\n          brother._color = TreeNodeColor.BLACK;\n          parentNode._color = TreeNodeColor.RED;\n          if (parentNode === this._root) {\n            this._root = parentNode._rotateRight();\n          } else parentNode._rotateRight();\n        } else {\n          if (brother._left && brother._left._color === TreeNodeColor.RED) {\n            brother._color = parentNode._color;\n            parentNode._color = TreeNodeColor.BLACK;\n            brother._left._color = TreeNodeColor.BLACK;\n            if (parentNode === this._root) {\n              this._root = parentNode._rotateRight();\n            } else parentNode._rotateRight();\n            return;\n          } else if (brother._right && brother._right._color === TreeNodeColor.RED) {\n            brother._color = TreeNodeColor.RED;\n            brother._right._color = TreeNodeColor.BLACK;\n            brother._rotateLeft();\n          } else {\n            brother._color = TreeNodeColor.RED;\n            curNode = parentNode;\n          }\n        }\n      }\n    }\n  }\n  /**\n   * @internal\n   */\n  protected _preEraseNode(curNode: TreeNode<K, V>) {\n    if (this._length === 1) {\n      this.clear();\n      return this._header;\n    }\n    let swapNode = curNode;\n    while (swapNode._left || swapNode._right) {\n      if (swapNode._right) {\n        swapNode = swapNode._right;\n        while (swapNode._left) swapNode = swapNode._left;\n      } else {\n        swapNode = swapNode._left!;\n      }\n      [curNode._key, swapNode._key] = [swapNode._key, curNode._key];\n      [curNode._value, swapNode._value] = [swapNode._value, curNode._value];\n      curNode = swapNode;\n    }\n    if (this._header._left === swapNode) {\n      this._header._left = swapNode._parent;\n    } else if (this._header._right === swapNode) {\n      this._header._right = swapNode._parent;\n    }\n    this._eraseNodeSelfBalance(swapNode);\n    const _parent = swapNode._parent!;\n    if (swapNode === _parent._left) {\n      _parent._left = undefined;\n    } else _parent._right = undefined;\n    this._length -= 1;\n    this._root!._color = TreeNodeColor.BLACK;\n    return _parent;\n  }\n  /**\n   * @internal\n   */\n  protected _inOrderTraversal(\n    curNode: TreeNode<K, V> | undefined,\n    callback: (curNode: TreeNode<K, V>) => boolean\n  ): boolean {\n    if (curNode === undefined) return false;\n    const ifReturn = this._inOrderTraversal(curNode._left, callback);\n    if (ifReturn) return true;\n    if (callback(curNode)) return true;\n    return this._inOrderTraversal(curNode._right, callback);\n  }\n  /**\n   * @internal\n   */\n  protected _insertNodeSelfBalance(curNode: TreeNode<K, V>) {\n    while (true) {\n      const parentNode = curNode._parent!;\n      if (parentNode._color === TreeNodeColor.BLACK) return;\n      const grandParent = parentNode._parent!;\n      if (parentNode === grandParent._left) {\n        const uncle = grandParent._right;\n        if (uncle && uncle._color === TreeNodeColor.RED) {\n          uncle._color = parentNode._color = TreeNodeColor.BLACK;\n          if (grandParent === this._root) return;\n          grandParent._color = TreeNodeColor.RED;\n          curNode = grandParent;\n          continue;\n        } else if (curNode === parentNode._right) {\n          curNode._color = TreeNodeColor.BLACK;\n          if (curNode._left) curNode._left._parent = parentNode;\n          if (curNode._right) curNode._right._parent = grandParent;\n          parentNode._right = curNode._left;\n          grandParent._left = curNode._right;\n          curNode._left = parentNode;\n          curNode._right = grandParent;\n          if (grandParent === this._root) {\n            this._root = curNode;\n            this._header._parent = curNode;\n          } else {\n            const GP = grandParent._parent!;\n            if (GP._left === grandParent) {\n              GP._left = curNode;\n            } else GP._right = curNode;\n          }\n          curNode._parent = grandParent._parent;\n          parentNode._parent = curNode;\n          grandParent._parent = curNode;\n          grandParent._color = TreeNodeColor.RED;\n          return { parentNode, grandParent, curNode };\n        } else {\n          parentNode._color = TreeNodeColor.BLACK;\n          if (grandParent === this._root) {\n            this._root = grandParent._rotateRight();\n          } else grandParent._rotateRight();\n          grandParent._color = TreeNodeColor.RED;\n        }\n      } else {\n        const uncle = grandParent._left;\n        if (uncle && uncle._color === TreeNodeColor.RED) {\n          uncle._color = parentNode._color = TreeNodeColor.BLACK;\n          if (grandParent === this._root) return;\n          grandParent._color = TreeNodeColor.RED;\n          curNode = grandParent;\n          continue;\n        } else if (curNode === parentNode._left) {\n          curNode._color = TreeNodeColor.BLACK;\n          if (curNode._left) curNode._left._parent = grandParent;\n          if (curNode._right) curNode._right._parent = parentNode;\n          grandParent._right = curNode._left;\n          parentNode._left = curNode._right;\n          curNode._left = grandParent;\n          curNode._right = parentNode;\n          if (grandParent === this._root) {\n            this._root = curNode;\n            this._header._parent = curNode;\n          } else {\n            const GP = grandParent._parent!;\n            if (GP._left === grandParent) {\n              GP._left = curNode;\n            } else GP._right = curNode;\n          }\n          curNode._parent = grandParent._parent;\n          parentNode._parent = curNode;\n          grandParent._parent = curNode;\n          grandParent._color = TreeNodeColor.RED;\n          return { parentNode, grandParent, curNode };\n        } else {\n          parentNode._color = TreeNodeColor.BLACK;\n          if (grandParent === this._root) {\n            this._root = grandParent._rotateLeft();\n          } else grandParent._rotateLeft();\n          grandParent._color = TreeNodeColor.RED;\n        }\n      }\n      return;\n    }\n  }\n  /**\n   * @internal\n   */\n  protected _preSet(key: K, value?: V, hint?: TreeIterator<K, V>) {\n    if (this._root === undefined) {\n      this._length += 1;\n      this._root = new this._TreeNodeClass(key, value);\n      this._root._color = TreeNodeColor.BLACK;\n      this._root._parent = this._header;\n      this._header._parent = this._root;\n      this._header._left = this._root;\n      this._header._right = this._root;\n      return;\n    }\n    let curNode;\n    const minNode = this._header._left!;\n    const compareToMin = this._cmp(minNode._key!, key);\n    if (compareToMin === 0) {\n      minNode._value = value;\n      return;\n    } else if (compareToMin > 0) {\n      minNode._left = new this._TreeNodeClass(key, value);\n      minNode._left._parent = minNode;\n      curNode = minNode._left;\n      this._header._left = curNode;\n    } else {\n      const maxNode = this._header._right!;\n      const compareToMax = this._cmp(maxNode._key!, key);\n      if (compareToMax === 0) {\n        maxNode._value = value;\n        return;\n      } else if (compareToMax < 0) {\n        maxNode._right = new this._TreeNodeClass(key, value);\n        maxNode._right._parent = maxNode;\n        curNode = maxNode._right;\n        this._header._right = curNode;\n      } else {\n        if (hint !== undefined) {\n          const iterNode = hint._node;\n          if (iterNode !== this._header) {\n            const iterCmpRes = this._cmp(iterNode._key!, key);\n            if (iterCmpRes === 0) {\n              iterNode._value = value;\n              return;\n            } else /* istanbul ignore else */ if (iterCmpRes > 0) {\n              const preNode = iterNode._pre();\n              const preCmpRes = this._cmp(preNode._key!, key);\n              if (preCmpRes === 0) {\n                preNode._value = value;\n                return;\n              } else if (preCmpRes < 0) {\n                curNode = new this._TreeNodeClass(key, value);\n                if (preNode._right === undefined) {\n                  preNode._right = curNode;\n                  curNode._parent = preNode;\n                } else {\n                  iterNode._left = curNode;\n                  curNode._parent = iterNode;\n                }\n              }\n            }\n          }\n        }\n        if (curNode === undefined) {\n          curNode = this._root;\n          while (true) {\n            const cmpResult = this._cmp(curNode._key!, key);\n            if (cmpResult > 0) {\n              if (curNode._left === undefined) {\n                curNode._left = new this._TreeNodeClass(key, value);\n                curNode._left._parent = curNode;\n                curNode = curNode._left;\n                break;\n              }\n              curNode = curNode._left;\n            } else if (cmpResult < 0) {\n              if (curNode._right === undefined) {\n                curNode._right = new this._TreeNodeClass(key, value);\n                curNode._right._parent = curNode;\n                curNode = curNode._right;\n                break;\n              }\n              curNode = curNode._right;\n            } else {\n              curNode._value = value;\n              return;\n            }\n          }\n        }\n      }\n    }\n    this._length += 1;\n    return curNode;\n  }\n  /**\n   * @internal\n   */\n  protected _findElementNode(curNode: TreeNode<K, V> | undefined, key: K) {\n    while (curNode) {\n      const cmpResult = this._cmp(curNode._key!, key);\n      if (cmpResult < 0) {\n        curNode = curNode._right;\n      } else if (cmpResult > 0) {\n        curNode = curNode._left;\n      } else return curNode;\n    }\n    return curNode || this._header;\n  }\n  clear() {\n    this._length = 0;\n    this._root = undefined;\n    this._header._parent = undefined;\n    this._header._left = this._header._right = undefined;\n  }\n  /**\n   * @description Update node's key by iterator.\n   * @param iter - The iterator you want to change.\n   * @param key - The key you want to update.\n   * @returns Whether the modification is successful.\n   * @example\n   * const st = new orderedSet([1, 2, 5]);\n   * const iter = st.find(2);\n   * st.updateKeyByIterator(iter, 3); // then st will become [1, 3, 5]\n   */\n  updateKeyByIterator(iter: TreeIterator<K, V>, key: K): boolean {\n    const node = iter._node;\n    if (node === this._header) {\n      throwIteratorAccessError();\n    }\n    if (this._length === 1) {\n      node._key = key;\n      return true;\n    }\n    if (node === this._header._left) {\n      if (this._cmp(node._next()._key!, key) > 0) {\n        node._key = key;\n        return true;\n      }\n      return false;\n    }\n    if (node === this._header._right) {\n      if (this._cmp(node._pre()._key!, key) < 0) {\n        node._key = key;\n        return true;\n      }\n      return false;\n    }\n    const preKey = node._pre()._key!;\n    if (this._cmp(preKey, key) >= 0) return false;\n    const nextKey = node._next()._key!;\n    if (this._cmp(nextKey, key) <= 0) return false;\n    node._key = key;\n    return true;\n  }\n  eraseElementByPos(pos: number) {\n    $checkWithinAccessParams!(pos, 0, this._length - 1);\n    let index = 0;\n    const self = this;\n    this._inOrderTraversal(\n      this._root,\n      function (curNode) {\n        if (pos === index) {\n          self._eraseNode(curNode);\n          return true;\n        }\n        index += 1;\n        return false;\n      });\n    return this._length;\n  }\n  /**\n   * @description Remove the element of the specified key.\n   * @param key - The key you want to remove.\n   * @returns Whether erase successfully.\n   */\n  eraseElementByKey(key: K) {\n    if (this._length === 0) return false;\n    const curNode = this._findElementNode(this._root, key);\n    if (curNode === this._header) return false;\n    this._eraseNode(curNode);\n    return true;\n  }\n  eraseElementByIterator(iter: TreeIterator<K, V>) {\n    const node = iter._node;\n    if (node === this._header) {\n      throwIteratorAccessError();\n    }\n    const hasNoRight = node._right === undefined;\n    const isNormal = iter.iteratorType === IteratorType.NORMAL;\n    // For the normal iterator, the `next` node will be swapped to `this` node when has right.\n    if (isNormal) {\n      // So we should move it to next when it's right is null.\n      if (hasNoRight) iter.next();\n    } else {\n      // For the reverse iterator, only when it doesn't have right and has left the `next` node will be swapped.\n      // So when it has right, or it is a leaf node we should move it to `next`.\n      if (!hasNoRight || node._left === undefined) iter.next();\n    }\n    this._eraseNode(node);\n    return iter;\n  }\n  forEach(callback: (element: K | [K, V], index: number, tree: TreeContainer<K, V>) => void) {\n    let index = 0;\n    for (const element of this) callback(element, index++, this);\n  }\n  getElementByPos(pos: number) {\n    $checkWithinAccessParams!(pos, 0, this._length - 1);\n    let res;\n    let index = 0;\n    for (const element of this) {\n      if (index === pos) {\n        res = element;\n        break;\n      }\n      index += 1;\n    }\n    return <K | [K, V]>res;\n  }\n  /**\n   * @description Get the height of the tree.\n   * @returns Number about the height of the RB-tree.\n   */\n  getHeight() {\n    if (this._length === 0) return 0;\n    const traversal =\n      function (curNode: TreeNode<K, V> | undefined): number {\n        if (!curNode) return 0;\n        return Math.max(traversal(curNode._left), traversal(curNode._right)) + 1;\n      };\n    return traversal(this._root);\n  }\n  /**\n   * @param key - The given key you want to compare.\n   * @returns An iterator to the first element less than the given key.\n   */\n  abstract reverseUpperBound(key: K): TreeIterator<K, V>;\n  /**\n   * @description Union the other tree to self.\n   * @param other - The other tree container you want to merge.\n   * @returns The size of the tree after union.\n   */\n  abstract union(other: TreeContainer<K, V>): number;\n  /**\n   * @param key - The given key you want to compare.\n   * @returns An iterator to the first element not greater than the given key.\n   */\n  abstract reverseLowerBound(key: K): TreeIterator<K, V>;\n  /**\n   * @param key - The given key you want to compare.\n   * @returns An iterator to the first element not less than the given key.\n   */\n  abstract lowerBound(key: K): TreeIterator<K, V>;\n  /**\n   * @param key - The given key you want to compare.\n   * @returns An iterator to the first element greater than the given key.\n   */\n  abstract upperBound(key: K): TreeIterator<K, V>;\n}\n\nexport default TreeContainer;\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}