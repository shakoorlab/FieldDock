{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nconst buffer_1 = require(\"buffer\");\nconst readable_stream_1 = require(\"readable-stream\");\nconst duplexify_1 = __importDefault(require(\"duplexify\"));\nlet my;\nlet proxy;\nlet stream;\nlet isInitialized = false;\nfunction buildProxy() {\n  const _proxy = new readable_stream_1.Transform();\n  _proxy._write = (chunk, encoding, next) => {\n    my.sendSocketMessage({\n      data: chunk.buffer,\n      success() {\n        next();\n      },\n      fail() {\n        next(new Error());\n      }\n    });\n  };\n  _proxy._flush = done => {\n    my.closeSocket({\n      success() {\n        done();\n      }\n    });\n  };\n  return _proxy;\n}\nfunction setDefaultOpts(opts) {\n  if (!opts.hostname) {\n    opts.hostname = 'localhost';\n  }\n  if (!opts.path) {\n    opts.path = '/';\n  }\n  if (!opts.wsOptions) {\n    opts.wsOptions = {};\n  }\n}\nfunction buildUrl(opts, client) {\n  const protocol = opts.protocol === 'alis' ? 'wss' : 'ws';\n  let url = `${protocol}://${opts.hostname}${opts.path}`;\n  if (opts.port && opts.port !== 80 && opts.port !== 443) {\n    url = `${protocol}://${opts.hostname}:${opts.port}${opts.path}`;\n  }\n  if (typeof opts.transformWsUrl === 'function') {\n    url = opts.transformWsUrl(url, opts, client);\n  }\n  return url;\n}\nfunction bindEventHandler() {\n  if (isInitialized) return;\n  isInitialized = true;\n  my.onSocketOpen(() => {\n    stream.setReadable(proxy);\n    stream.setWritable(proxy);\n    stream.emit('connect');\n  });\n  my.onSocketMessage(res => {\n    if (typeof res.data === 'string') {\n      const buffer = buffer_1.Buffer.from(res.data, 'base64');\n      proxy.push(buffer);\n    } else {\n      const reader = new FileReader();\n      reader.addEventListener('load', () => {\n        let data = reader.result;\n        if (data instanceof ArrayBuffer) data = buffer_1.Buffer.from(data);else data = buffer_1.Buffer.from(data, 'utf8');\n        proxy.push(data);\n      });\n      reader.readAsArrayBuffer(res.data);\n    }\n  });\n  my.onSocketClose(() => {\n    stream.end();\n    stream.destroy();\n  });\n  my.onSocketError(res => {\n    stream.destroy(res);\n  });\n}\nconst buildStream = (client, opts) => {\n  opts.hostname = opts.hostname || opts.host;\n  if (!opts.hostname) {\n    throw new Error('Could not determine host. Specify host manually.');\n  }\n  const websocketSubProtocol = opts.protocolId === 'MQIsdp' && opts.protocolVersion === 3 ? 'mqttv3.1' : 'mqtt';\n  setDefaultOpts(opts);\n  const url = buildUrl(opts, client);\n  my = opts.my;\n  my.connectSocket({\n    url,\n    protocols: websocketSubProtocol\n  });\n  proxy = buildProxy();\n  stream = duplexify_1.default.obj();\n  bindEventHandler();\n  return stream;\n};\nexports.default = buildStream;","map":{"version":3,"names":["buffer_1","require","readable_stream_1","duplexify_1","__importDefault","my","proxy","stream","isInitialized","buildProxy","_proxy","Transform","_write","chunk","encoding","next","sendSocketMessage","data","buffer","success","fail","Error","_flush","done","closeSocket","setDefaultOpts","opts","hostname","path","wsOptions","buildUrl","client","protocol","url","port","transformWsUrl","bindEventHandler","onSocketOpen","setReadable","setWritable","emit","onSocketMessage","res","Buffer","from","push","reader","FileReader","addEventListener","result","ArrayBuffer","readAsArrayBuffer","onSocketClose","end","destroy","onSocketError","buildStream","host","websocketSubProtocol","protocolId","protocolVersion","connectSocket","protocols","default","obj","exports"],"sources":["/Users/jstanton/Coding/FieldDock/FieldDockMain/node_modules/mqtt/src/lib/connect/ali.ts"],"sourcesContent":["import { Buffer } from 'buffer'\nimport { Transform } from 'readable-stream'\nimport duplexify, { Duplexify } from 'duplexify'\nimport { StreamBuilder } from '../shared'\nimport MqttClient, { IClientOptions } from '../client'\n\nlet my: any\nlet proxy: Transform\nlet stream: Duplexify\nlet isInitialized = false\n\nfunction buildProxy() {\n\tconst _proxy = new Transform()\n\t_proxy._write = (chunk, encoding, next) => {\n\t\tmy.sendSocketMessage({\n\t\t\tdata: chunk.buffer,\n\t\t\tsuccess() {\n\t\t\t\tnext()\n\t\t\t},\n\t\t\tfail() {\n\t\t\t\tnext(new Error())\n\t\t\t},\n\t\t})\n\t}\n\t_proxy._flush = (done) => {\n\t\tmy.closeSocket({\n\t\t\tsuccess() {\n\t\t\t\tdone()\n\t\t\t},\n\t\t})\n\t}\n\n\treturn _proxy\n}\n\nfunction setDefaultOpts(opts: IClientOptions) {\n\tif (!opts.hostname) {\n\t\topts.hostname = 'localhost'\n\t}\n\tif (!opts.path) {\n\t\topts.path = '/'\n\t}\n\n\tif (!opts.wsOptions) {\n\t\topts.wsOptions = {}\n\t}\n}\n\nfunction buildUrl(opts: IClientOptions, client: MqttClient) {\n\tconst protocol = opts.protocol === 'alis' ? 'wss' : 'ws'\n\tlet url = `${protocol}://${opts.hostname}${opts.path}`\n\tif (opts.port && opts.port !== 80 && opts.port !== 443) {\n\t\turl = `${protocol}://${opts.hostname}:${opts.port}${opts.path}`\n\t}\n\tif (typeof opts.transformWsUrl === 'function') {\n\t\turl = opts.transformWsUrl(url, opts, client)\n\t}\n\treturn url\n}\n\nfunction bindEventHandler() {\n\tif (isInitialized) return\n\n\tisInitialized = true\n\n\tmy.onSocketOpen(() => {\n\t\tstream.setReadable(proxy)\n\t\tstream.setWritable(proxy)\n\t\tstream.emit('connect')\n\t})\n\n\tmy.onSocketMessage((res) => {\n\t\tif (typeof res.data === 'string') {\n\t\t\tconst buffer = Buffer.from(res.data, 'base64')\n\t\t\tproxy.push(buffer)\n\t\t} else {\n\t\t\tconst reader = new FileReader()\n\t\t\treader.addEventListener('load', () => {\n\t\t\t\tlet data = reader.result\n\n\t\t\t\tif (data instanceof ArrayBuffer) data = Buffer.from(data)\n\t\t\t\telse data = Buffer.from(data, 'utf8')\n\t\t\t\tproxy.push(data)\n\t\t\t})\n\t\t\treader.readAsArrayBuffer(res.data)\n\t\t}\n\t})\n\n\tmy.onSocketClose(() => {\n\t\tstream.end()\n\t\tstream.destroy()\n\t})\n\n\tmy.onSocketError((res) => {\n\t\tstream.destroy(res)\n\t})\n}\n\nconst buildStream: StreamBuilder = (client, opts) => {\n\topts.hostname = opts.hostname || opts.host\n\n\tif (!opts.hostname) {\n\t\tthrow new Error('Could not determine host. Specify host manually.')\n\t}\n\n\tconst websocketSubProtocol =\n\t\topts.protocolId === 'MQIsdp' && opts.protocolVersion === 3\n\t\t\t? 'mqttv3.1'\n\t\t\t: 'mqtt'\n\n\tsetDefaultOpts(opts)\n\n\tconst url = buildUrl(opts, client)\n\tmy = opts.my\n\tmy.connectSocket({\n\t\turl,\n\t\tprotocols: websocketSubProtocol,\n\t})\n\n\tproxy = buildProxy()\n\tstream = duplexify.obj()\n\n\tbindEventHandler()\n\n\treturn stream\n}\n\nexport default buildStream\n"],"mappings":";;;;;;;;;;AAAA,MAAAA,QAAA,GAAAC,OAAA;AACA,MAAAC,iBAAA,GAAAD,OAAA;AACA,MAAAE,WAAA,GAAAC,eAAA,CAAAH,OAAA;AAIA,IAAII,EAAO;AACX,IAAIC,KAAgB;AACpB,IAAIC,MAAiB;AACrB,IAAIC,aAAa,GAAG,KAAK;AAEzB,SAASC,UAAUA,CAAA;EAClB,MAAMC,MAAM,GAAG,IAAIR,iBAAA,CAAAS,SAAS,EAAE;EAC9BD,MAAM,CAACE,MAAM,GAAG,CAACC,KAAK,EAAEC,QAAQ,EAAEC,IAAI,KAAI;IACzCV,EAAE,CAACW,iBAAiB,CAAC;MACpBC,IAAI,EAAEJ,KAAK,CAACK,MAAM;MAClBC,OAAOA,CAAA;QACNJ,IAAI,EAAE;MACP,CAAC;MACDK,IAAIA,CAAA;QACHL,IAAI,CAAC,IAAIM,KAAK,EAAE,CAAC;MAClB;KACA,CAAC;EACH,CAAC;EACDX,MAAM,CAACY,MAAM,GAAIC,IAAI,IAAI;IACxBlB,EAAE,CAACmB,WAAW,CAAC;MACdL,OAAOA,CAAA;QACNI,IAAI,EAAE;MACP;KACA,CAAC;EACH,CAAC;EAED,OAAOb,MAAM;AACd;AAEA,SAASe,cAAcA,CAACC,IAAoB;EAC3C,IAAI,CAACA,IAAI,CAACC,QAAQ,EAAE;IACnBD,IAAI,CAACC,QAAQ,GAAG,WAAW;;EAE5B,IAAI,CAACD,IAAI,CAACE,IAAI,EAAE;IACfF,IAAI,CAACE,IAAI,GAAG,GAAG;;EAGhB,IAAI,CAACF,IAAI,CAACG,SAAS,EAAE;IACpBH,IAAI,CAACG,SAAS,GAAG,EAAE;;AAErB;AAEA,SAASC,QAAQA,CAACJ,IAAoB,EAAEK,MAAkB;EACzD,MAAMC,QAAQ,GAAGN,IAAI,CAACM,QAAQ,KAAK,MAAM,GAAG,KAAK,GAAG,IAAI;EACxD,IAAIC,GAAG,GAAG,GAAGD,QAAQ,MAAMN,IAAI,CAACC,QAAQ,GAAGD,IAAI,CAACE,IAAI,EAAE;EACtD,IAAIF,IAAI,CAACQ,IAAI,IAAIR,IAAI,CAACQ,IAAI,KAAK,EAAE,IAAIR,IAAI,CAACQ,IAAI,KAAK,GAAG,EAAE;IACvDD,GAAG,GAAG,GAAGD,QAAQ,MAAMN,IAAI,CAACC,QAAQ,IAAID,IAAI,CAACQ,IAAI,GAAGR,IAAI,CAACE,IAAI,EAAE;;EAEhE,IAAI,OAAOF,IAAI,CAACS,cAAc,KAAK,UAAU,EAAE;IAC9CF,GAAG,GAAGP,IAAI,CAACS,cAAc,CAACF,GAAG,EAAEP,IAAI,EAAEK,MAAM,CAAC;;EAE7C,OAAOE,GAAG;AACX;AAEA,SAASG,gBAAgBA,CAAA;EACxB,IAAI5B,aAAa,EAAE;EAEnBA,aAAa,GAAG,IAAI;EAEpBH,EAAE,CAACgC,YAAY,CAAC,MAAK;IACpB9B,MAAM,CAAC+B,WAAW,CAAChC,KAAK,CAAC;IACzBC,MAAM,CAACgC,WAAW,CAACjC,KAAK,CAAC;IACzBC,MAAM,CAACiC,IAAI,CAAC,SAAS,CAAC;EACvB,CAAC,CAAC;EAEFnC,EAAE,CAACoC,eAAe,CAAEC,GAAG,IAAI;IAC1B,IAAI,OAAOA,GAAG,CAACzB,IAAI,KAAK,QAAQ,EAAE;MACjC,MAAMC,MAAM,GAAGlB,QAAA,CAAA2C,MAAM,CAACC,IAAI,CAACF,GAAG,CAACzB,IAAI,EAAE,QAAQ,CAAC;MAC9CX,KAAK,CAACuC,IAAI,CAAC3B,MAAM,CAAC;KAClB,MAAM;MACN,MAAM4B,MAAM,GAAG,IAAIC,UAAU,EAAE;MAC/BD,MAAM,CAACE,gBAAgB,CAAC,MAAM,EAAE,MAAK;QACpC,IAAI/B,IAAI,GAAG6B,MAAM,CAACG,MAAM;QAExB,IAAIhC,IAAI,YAAYiC,WAAW,EAAEjC,IAAI,GAAGjB,QAAA,CAAA2C,MAAM,CAACC,IAAI,CAAC3B,IAAI,CAAC,MACpDA,IAAI,GAAGjB,QAAA,CAAA2C,MAAM,CAACC,IAAI,CAAC3B,IAAI,EAAE,MAAM,CAAC;QACrCX,KAAK,CAACuC,IAAI,CAAC5B,IAAI,CAAC;MACjB,CAAC,CAAC;MACF6B,MAAM,CAACK,iBAAiB,CAACT,GAAG,CAACzB,IAAI,CAAC;;EAEpC,CAAC,CAAC;EAEFZ,EAAE,CAAC+C,aAAa,CAAC,MAAK;IACrB7C,MAAM,CAAC8C,GAAG,EAAE;IACZ9C,MAAM,CAAC+C,OAAO,EAAE;EACjB,CAAC,CAAC;EAEFjD,EAAE,CAACkD,aAAa,CAAEb,GAAG,IAAI;IACxBnC,MAAM,CAAC+C,OAAO,CAACZ,GAAG,CAAC;EACpB,CAAC,CAAC;AACH;AAEA,MAAMc,WAAW,GAAkBA,CAACzB,MAAM,EAAEL,IAAI,KAAI;EACnDA,IAAI,CAACC,QAAQ,GAAGD,IAAI,CAACC,QAAQ,IAAID,IAAI,CAAC+B,IAAI;EAE1C,IAAI,CAAC/B,IAAI,CAACC,QAAQ,EAAE;IACnB,MAAM,IAAIN,KAAK,CAAC,kDAAkD,CAAC;;EAGpE,MAAMqC,oBAAoB,GACzBhC,IAAI,CAACiC,UAAU,KAAK,QAAQ,IAAIjC,IAAI,CAACkC,eAAe,KAAK,CAAC,GACvD,UAAU,GACV,MAAM;EAEVnC,cAAc,CAACC,IAAI,CAAC;EAEpB,MAAMO,GAAG,GAAGH,QAAQ,CAACJ,IAAI,EAAEK,MAAM,CAAC;EAClC1B,EAAE,GAAGqB,IAAI,CAACrB,EAAE;EACZA,EAAE,CAACwD,aAAa,CAAC;IAChB5B,GAAG;IACH6B,SAAS,EAAEJ;GACX,CAAC;EAEFpD,KAAK,GAAGG,UAAU,EAAE;EACpBF,MAAM,GAAGJ,WAAA,CAAA4D,OAAS,CAACC,GAAG,EAAE;EAExB5B,gBAAgB,EAAE;EAElB,OAAO7B,MAAM;AACd,CAAC;AAED0D,OAAA,CAAAF,OAAA,GAAeP,WAAW"},"metadata":{},"sourceType":"script"}