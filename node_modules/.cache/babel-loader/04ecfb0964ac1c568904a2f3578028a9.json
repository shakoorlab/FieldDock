{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.connectAsync = void 0;\nconst debug_1 = __importDefault(require(\"debug\"));\nconst url_1 = __importDefault(require(\"url\"));\nconst client_1 = __importDefault(require(\"../client\"));\nconst is_browser_1 = __importDefault(require(\"../is-browser\"));\nconst debug = (0, debug_1.default)('mqttjs');\nconst protocols = {};\nif (!is_browser_1.default) {\n  protocols.mqtt = require('./tcp').default;\n  protocols.tcp = require('./tcp').default;\n  protocols.ssl = require('./tls').default;\n  protocols.tls = protocols.ssl;\n  protocols.mqtts = require('./tls').default;\n} else {\n  protocols.wx = require('./wx').default;\n  protocols.wxs = require('./wx').default;\n  protocols.ali = require('./ali').default;\n  protocols.alis = require('./ali').default;\n}\nprotocols.ws = require('./ws').default;\nprotocols.wss = require('./ws').default;\nfunction parseAuthOptions(opts) {\n  let matches;\n  if (opts.auth) {\n    matches = opts.auth.match(/^(.+):(.+)$/);\n    if (matches) {\n      opts.username = matches[1];\n      opts.password = matches[2];\n    } else {\n      opts.username = opts.auth;\n    }\n  }\n}\nfunction connect(brokerUrl, opts) {\n  debug('connecting to an MQTT broker...');\n  if (typeof brokerUrl === 'object' && !opts) {\n    opts = brokerUrl;\n    brokerUrl = '';\n  }\n  opts = opts || {};\n  if (brokerUrl && typeof brokerUrl === 'string') {\n    const parsed = url_1.default.parse(brokerUrl, true);\n    if (parsed.port != null) {\n      parsed.port = Number(parsed.port);\n    }\n    opts = Object.assign(Object.assign({}, parsed), opts);\n    if (opts.protocol === null) {\n      throw new Error('Missing protocol');\n    }\n    opts.protocol = opts.protocol.replace(/:$/, '');\n  }\n  parseAuthOptions(opts);\n  if (opts.query && typeof opts.query.clientId === 'string') {\n    opts.clientId = opts.query.clientId;\n  }\n  if (opts.cert && opts.key) {\n    if (opts.protocol) {\n      if (['mqtts', 'wss', 'wxs', 'alis'].indexOf(opts.protocol) === -1) {\n        switch (opts.protocol) {\n          case 'mqtt':\n            opts.protocol = 'mqtts';\n            break;\n          case 'ws':\n            opts.protocol = 'wss';\n            break;\n          case 'wx':\n            opts.protocol = 'wxs';\n            break;\n          case 'ali':\n            opts.protocol = 'alis';\n            break;\n          default:\n            throw new Error(`Unknown protocol for secure connection: \"${opts.protocol}\"!`);\n        }\n      }\n    } else {\n      throw new Error('Missing secure protocol key');\n    }\n  }\n  if (!protocols[opts.protocol]) {\n    const isSecure = ['mqtts', 'wss'].indexOf(opts.protocol) !== -1;\n    opts.protocol = ['mqtt', 'mqtts', 'ws', 'wss', 'wx', 'wxs', 'ali', 'alis'].filter((key, index) => {\n      if (isSecure && index % 2 === 0) {\n        return false;\n      }\n      return typeof protocols[key] === 'function';\n    })[0];\n  }\n  if (opts.clean === false && !opts.clientId) {\n    throw new Error('Missing clientId for unclean clients');\n  }\n  if (opts.protocol) {\n    opts.defaultProtocol = opts.protocol;\n  }\n  function wrapper(client) {\n    if (opts.servers) {\n      if (!client._reconnectCount || client._reconnectCount === opts.servers.length) {\n        client._reconnectCount = 0;\n      }\n      opts.host = opts.servers[client._reconnectCount].host;\n      opts.port = opts.servers[client._reconnectCount].port;\n      opts.protocol = !opts.servers[client._reconnectCount].protocol ? opts.defaultProtocol : opts.servers[client._reconnectCount].protocol;\n      opts.hostname = opts.host;\n      client._reconnectCount++;\n    }\n    debug('calling streambuilder for', opts.protocol);\n    return protocols[opts.protocol](client, opts);\n  }\n  const client = new client_1.default(wrapper, opts);\n  client.on('error', () => {});\n  return client;\n}\nfunction connectAsync(brokerUrl, opts) {\n  let allowRetries = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n  return new Promise((resolve, reject) => {\n    const client = connect(brokerUrl, opts);\n    const promiseResolutionListeners = {\n      connect: connack => {\n        removePromiseResolutionListeners();\n        resolve(client);\n      },\n      end: () => {\n        removePromiseResolutionListeners();\n        resolve(client);\n      },\n      error: err => {\n        removePromiseResolutionListeners();\n        client.end();\n        reject(err);\n      }\n    };\n    if (allowRetries === false) {\n      promiseResolutionListeners.close = () => {\n        promiseResolutionListeners.error(new Error(\"Couldn't connect to server\"));\n      };\n    }\n    function removePromiseResolutionListeners() {\n      Object.keys(promiseResolutionListeners).forEach(eventName => {\n        client.off(eventName, promiseResolutionListeners[eventName]);\n      });\n    }\n    Object.keys(promiseResolutionListeners).forEach(eventName => {\n      client.on(eventName, promiseResolutionListeners[eventName]);\n    });\n  });\n}\nexports.connectAsync = connectAsync;\nexports.default = connect;","map":{"version":3,"names":["debug_1","__importDefault","require","url_1","client_1","is_browser_1","debug","default","protocols","mqtt","tcp","ssl","tls","mqtts","wx","wxs","ali","alis","ws","wss","parseAuthOptions","opts","matches","auth","match","username","password","connect","brokerUrl","parsed","parse","port","Number","Object","assign","protocol","Error","replace","query","clientId","cert","key","indexOf","isSecure","filter","index","clean","defaultProtocol","wrapper","client","servers","_reconnectCount","length","host","hostname","on","connectAsync","allowRetries","arguments","undefined","Promise","resolve","reject","promiseResolutionListeners","connack","removePromiseResolutionListeners","end","error","err","close","keys","forEach","eventName","off","exports"],"sources":["/Users/jstanton/Coding/FieldDock/FieldDockMain/node_modules/mqtt/src/lib/connect/index.ts"],"sourcesContent":["/* eslint-disable @typescript-eslint/no-var-requires */\nimport _debug from 'debug'\nimport url from 'url'\nimport MqttClient, {\n\tIClientOptions,\n\tMqttClientEventCallbacks,\n\tMqttProtocol,\n} from '../client'\nimport IS_BROWSER from '../is-browser'\nimport { StreamBuilder } from '../shared'\n\nconst debug = _debug('mqttjs')\n\nconst protocols: Record<string, StreamBuilder> = {}\n\nif (!IS_BROWSER) {\n\tprotocols.mqtt = require('./tcp').default\n\tprotocols.tcp = require('./tcp').default\n\tprotocols.ssl = require('./tls').default\n\tprotocols.tls = protocols.ssl\n\tprotocols.mqtts = require('./tls').default\n} else {\n\tprotocols.wx = require('./wx').default\n\tprotocols.wxs = require('./wx').default\n\n\tprotocols.ali = require('./ali').default\n\tprotocols.alis = require('./ali').default\n}\n\nprotocols.ws = require('./ws').default\nprotocols.wss = require('./ws').default\n\n/**\n * Parse the auth attribute and merge username and password in the options object.\n *\n * @param {Object} [opts] option object\n */\nfunction parseAuthOptions(opts: IClientOptions) {\n\tlet matches: RegExpMatchArray | null\n\tif (opts.auth) {\n\t\tmatches = opts.auth.match(/^(.+):(.+)$/)\n\t\tif (matches) {\n\t\t\topts.username = matches[1]\n\t\t\topts.password = matches[2]\n\t\t} else {\n\t\t\topts.username = opts.auth\n\t\t}\n\t}\n}\n\n/**\n * connect - connect to an MQTT broker.\n */\nfunction connect(brokerUrl: string): MqttClient\nfunction connect(opts: IClientOptions): MqttClient\nfunction connect(brokerUrl: string, opts?: IClientOptions): MqttClient\nfunction connect(\n\tbrokerUrl: string | IClientOptions,\n\topts?: IClientOptions,\n): MqttClient {\n\tdebug('connecting to an MQTT broker...')\n\tif (typeof brokerUrl === 'object' && !opts) {\n\t\topts = brokerUrl\n\t\tbrokerUrl = ''\n\t}\n\n\topts = opts || {}\n\n\tif (brokerUrl && typeof brokerUrl === 'string') {\n\t\t// eslint-disable-next-line\n\t\tconst parsed = url.parse(brokerUrl, true)\n\t\tif (parsed.port != null) {\n\t\t\t// eslint-disable-next-line @typescript-eslint/ban-ts-comment\n\t\t\t// @ts-ignore\n\t\t\tparsed.port = Number(parsed.port)\n\t\t}\n\n\t\topts = { ...parsed, ...opts } as IClientOptions\n\n\t\tif (opts.protocol === null) {\n\t\t\tthrow new Error('Missing protocol')\n\t\t}\n\n\t\topts.protocol = opts.protocol.replace(/:$/, '') as MqttProtocol\n\t}\n\n\t// merge in the auth options if supplied\n\tparseAuthOptions(opts)\n\n\t// support clientId passed in the query string of the url\n\tif (opts.query && typeof opts.query.clientId === 'string') {\n\t\topts.clientId = opts.query.clientId\n\t}\n\n\tif (opts.cert && opts.key) {\n\t\tif (opts.protocol) {\n\t\t\tif (['mqtts', 'wss', 'wxs', 'alis'].indexOf(opts.protocol) === -1) {\n\t\t\t\tswitch (opts.protocol) {\n\t\t\t\t\tcase 'mqtt':\n\t\t\t\t\t\topts.protocol = 'mqtts'\n\t\t\t\t\t\tbreak\n\t\t\t\t\tcase 'ws':\n\t\t\t\t\t\topts.protocol = 'wss'\n\t\t\t\t\t\tbreak\n\t\t\t\t\tcase 'wx':\n\t\t\t\t\t\topts.protocol = 'wxs'\n\t\t\t\t\t\tbreak\n\t\t\t\t\tcase 'ali':\n\t\t\t\t\t\topts.protocol = 'alis'\n\t\t\t\t\t\tbreak\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t\t`Unknown protocol for secure connection: \"${opts.protocol}\"!`,\n\t\t\t\t\t\t)\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\t// A cert and key was provided, however no protocol was specified, so we will throw an error.\n\t\t\tthrow new Error('Missing secure protocol key')\n\t\t}\n\t}\n\n\tif (!protocols[opts.protocol]) {\n\t\tconst isSecure = ['mqtts', 'wss'].indexOf(opts.protocol) !== -1\n\t\topts.protocol = [\n\t\t\t'mqtt',\n\t\t\t'mqtts',\n\t\t\t'ws',\n\t\t\t'wss',\n\t\t\t'wx',\n\t\t\t'wxs',\n\t\t\t'ali',\n\t\t\t'alis',\n\t\t].filter((key, index) => {\n\t\t\tif (isSecure && index % 2 === 0) {\n\t\t\t\t// Skip insecure protocols when requesting a secure one.\n\t\t\t\treturn false\n\t\t\t}\n\t\t\treturn typeof protocols[key] === 'function'\n\t\t})[0] as MqttProtocol\n\t}\n\n\tif (opts.clean === false && !opts.clientId) {\n\t\tthrow new Error('Missing clientId for unclean clients')\n\t}\n\n\tif (opts.protocol) {\n\t\topts.defaultProtocol = opts.protocol\n\t}\n\n\tfunction wrapper(client: MqttClient) {\n\t\tif (opts.servers) {\n\t\t\tif (\n\t\t\t\t!client._reconnectCount ||\n\t\t\t\tclient._reconnectCount === opts.servers.length\n\t\t\t) {\n\t\t\t\tclient._reconnectCount = 0\n\t\t\t}\n\n\t\t\topts.host = opts.servers[client._reconnectCount].host\n\t\t\topts.port = opts.servers[client._reconnectCount].port\n\t\t\topts.protocol = !opts.servers[client._reconnectCount].protocol\n\t\t\t\t? opts.defaultProtocol\n\t\t\t\t: opts.servers[client._reconnectCount].protocol\n\t\t\topts.hostname = opts.host\n\n\t\t\tclient._reconnectCount++\n\t\t}\n\n\t\tdebug('calling streambuilder for', opts.protocol)\n\t\treturn protocols[opts.protocol](client, opts)\n\t}\n\tconst client = new MqttClient(wrapper, opts)\n\tclient.on('error', () => {\n\t\t/* Automatically set up client error handling */\n\t})\n\n\treturn client\n}\n\nfunction connectAsync(brokerUrl: string): Promise<MqttClient>\nfunction connectAsync(opts: IClientOptions): Promise<MqttClient>\nfunction connectAsync(\n\tbrokerUrl: string,\n\topts?: IClientOptions,\n): Promise<MqttClient>\nfunction connectAsync(\n\tbrokerUrl: string | IClientOptions,\n\topts?: IClientOptions,\n\tallowRetries = true,\n): Promise<MqttClient> {\n\treturn new Promise((resolve, reject) => {\n\t\tconst client = connect(brokerUrl as string, opts)\n\n\t\tconst promiseResolutionListeners: Partial<MqttClientEventCallbacks> = {\n\t\t\tconnect: (connack) => {\n\t\t\t\tremovePromiseResolutionListeners()\n\t\t\t\tresolve(client) // Resolve on connect\n\t\t\t},\n\t\t\tend: () => {\n\t\t\t\tremovePromiseResolutionListeners()\n\t\t\t\tresolve(client) // Resolve on end\n\t\t\t},\n\t\t\terror: (err) => {\n\t\t\t\tremovePromiseResolutionListeners()\n\t\t\t\tclient.end()\n\t\t\t\treject(err) // Reject on error\n\t\t\t},\n\t\t}\n\n\t\t// If retries are not allowed, reject on close\n\t\tif (allowRetries === false) {\n\t\t\tpromiseResolutionListeners.close = () => {\n\t\t\t\tpromiseResolutionListeners.error(\n\t\t\t\t\tnew Error(\"Couldn't connect to server\"),\n\t\t\t\t)\n\t\t\t}\n\t\t}\n\n\t\t// Remove listeners added to client by this promise\n\t\tfunction removePromiseResolutionListeners() {\n\t\t\tObject.keys(promiseResolutionListeners).forEach((eventName) => {\n\t\t\t\tclient.off(\n\t\t\t\t\teventName as keyof MqttClientEventCallbacks,\n\t\t\t\t\tpromiseResolutionListeners[eventName],\n\t\t\t\t)\n\t\t\t})\n\t\t}\n\n\t\t// Add listeners to client\n\t\tObject.keys(promiseResolutionListeners).forEach((eventName) => {\n\t\t\tclient.on(\n\t\t\t\teventName as keyof MqttClientEventCallbacks,\n\t\t\t\tpromiseResolutionListeners[eventName],\n\t\t\t)\n\t\t})\n\t})\n}\n\nexport default connect\nexport { connectAsync }\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}