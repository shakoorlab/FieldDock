{"ast":null,"code":"'use strict';\n\nconst {\n  pipeline\n} = require('./pipeline');\nconst Duplex = require('./duplex');\nconst {\n  destroyer\n} = require('./destroy');\nconst {\n  isNodeStream,\n  isReadable,\n  isWritable,\n  isWebStream,\n  isTransformStream,\n  isWritableStream,\n  isReadableStream\n} = require('./utils');\nconst {\n  AbortError,\n  codes: {\n    ERR_INVALID_ARG_VALUE,\n    ERR_MISSING_ARGS\n  }\n} = require('../../ours/errors');\nconst eos = require('./end-of-stream');\nmodule.exports = function compose() {\n  for (var _len = arguments.length, streams = new Array(_len), _key = 0; _key < _len; _key++) {\n    streams[_key] = arguments[_key];\n  }\n  if (streams.length === 0) {\n    throw new ERR_MISSING_ARGS('streams');\n  }\n  if (streams.length === 1) {\n    return Duplex.from(streams[0]);\n  }\n  const orgStreams = [...streams];\n  if (typeof streams[0] === 'function') {\n    streams[0] = Duplex.from(streams[0]);\n  }\n  if (typeof streams[streams.length - 1] === 'function') {\n    const idx = streams.length - 1;\n    streams[idx] = Duplex.from(streams[idx]);\n  }\n  for (let n = 0; n < streams.length; ++n) {\n    if (!isNodeStream(streams[n]) && !isWebStream(streams[n])) {\n      // TODO(ronag): Add checks for non streams.\n      continue;\n    }\n    if (n < streams.length - 1 && !(isReadable(streams[n]) || isReadableStream(streams[n]) || isTransformStream(streams[n]))) {\n      throw new ERR_INVALID_ARG_VALUE(`streams[${n}]`, orgStreams[n], 'must be readable');\n    }\n    if (n > 0 && !(isWritable(streams[n]) || isWritableStream(streams[n]) || isTransformStream(streams[n]))) {\n      throw new ERR_INVALID_ARG_VALUE(`streams[${n}]`, orgStreams[n], 'must be writable');\n    }\n  }\n  let ondrain;\n  let onfinish;\n  let onreadable;\n  let onclose;\n  let d;\n  function onfinished(err) {\n    const cb = onclose;\n    onclose = null;\n    if (cb) {\n      cb(err);\n    } else if (err) {\n      d.destroy(err);\n    } else if (!readable && !writable) {\n      d.destroy();\n    }\n  }\n  const head = streams[0];\n  const tail = pipeline(streams, onfinished);\n  const writable = !!(isWritable(head) || isWritableStream(head) || isTransformStream(head));\n  const readable = !!(isReadable(tail) || isReadableStream(tail) || isTransformStream(tail));\n\n  // TODO(ronag): Avoid double buffering.\n  // Implement Writable/Readable/Duplex traits.\n  // See, https://github.com/nodejs/node/pull/33515.\n  d = new Duplex({\n    // TODO (ronag): highWaterMark?\n    writableObjectMode: !!(head !== null && head !== undefined && head.writableObjectMode),\n    readableObjectMode: !!(tail !== null && tail !== undefined && tail.writableObjectMode),\n    writable,\n    readable\n  });\n  if (writable) {\n    if (isNodeStream(head)) {\n      d._write = function (chunk, encoding, callback) {\n        if (head.write(chunk, encoding)) {\n          callback();\n        } else {\n          ondrain = callback;\n        }\n      };\n      d._final = function (callback) {\n        head.end();\n        onfinish = callback;\n      };\n      head.on('drain', function () {\n        if (ondrain) {\n          const cb = ondrain;\n          ondrain = null;\n          cb();\n        }\n      });\n    } else if (isWebStream(head)) {\n      const writable = isTransformStream(head) ? head.writable : head;\n      const writer = writable.getWriter();\n      d._write = async function (chunk, encoding, callback) {\n        try {\n          await writer.ready;\n          writer.write(chunk).catch(() => {});\n          callback();\n        } catch (err) {\n          callback(err);\n        }\n      };\n      d._final = async function (callback) {\n        try {\n          await writer.ready;\n          writer.close().catch(() => {});\n          onfinish = callback;\n        } catch (err) {\n          callback(err);\n        }\n      };\n    }\n    const toRead = isTransformStream(tail) ? tail.readable : tail;\n    eos(toRead, () => {\n      if (onfinish) {\n        const cb = onfinish;\n        onfinish = null;\n        cb();\n      }\n    });\n  }\n  if (readable) {\n    if (isNodeStream(tail)) {\n      tail.on('readable', function () {\n        if (onreadable) {\n          const cb = onreadable;\n          onreadable = null;\n          cb();\n        }\n      });\n      tail.on('end', function () {\n        d.push(null);\n      });\n      d._read = function () {\n        while (true) {\n          const buf = tail.read();\n          if (buf === null) {\n            onreadable = d._read;\n            return;\n          }\n          if (!d.push(buf)) {\n            return;\n          }\n        }\n      };\n    } else if (isWebStream(tail)) {\n      const readable = isTransformStream(tail) ? tail.readable : tail;\n      const reader = readable.getReader();\n      d._read = async function () {\n        while (true) {\n          try {\n            const {\n              value,\n              done\n            } = await reader.read();\n            if (!d.push(value)) {\n              return;\n            }\n            if (done) {\n              d.push(null);\n              return;\n            }\n          } catch {\n            return;\n          }\n        }\n      };\n    }\n  }\n  d._destroy = function (err, callback) {\n    if (!err && onclose !== null) {\n      err = new AbortError();\n    }\n    onreadable = null;\n    ondrain = null;\n    onfinish = null;\n    if (onclose === null) {\n      callback(err);\n    } else {\n      onclose = callback;\n      if (isNodeStream(tail)) {\n        destroyer(tail, err);\n      }\n    }\n  };\n  return d;\n};","map":{"version":3,"names":["pipeline","require","Duplex","destroyer","isNodeStream","isReadable","isWritable","isWebStream","isTransformStream","isWritableStream","isReadableStream","AbortError","codes","ERR_INVALID_ARG_VALUE","ERR_MISSING_ARGS","eos","module","exports","compose","_len","arguments","length","streams","Array","_key","from","orgStreams","idx","n","ondrain","onfinish","onreadable","onclose","d","onfinished","err","cb","destroy","readable","writable","head","tail","writableObjectMode","undefined","readableObjectMode","_write","chunk","encoding","callback","write","_final","end","on","writer","getWriter","ready","catch","close","toRead","push","_read","buf","read","reader","getReader","value","done","_destroy"],"sources":["/Users/jstanton/Coding/FieldDock/FieldDockMain/node_modules/mqtt/node_modules/readable-stream/lib/internal/streams/compose.js"],"sourcesContent":["'use strict'\n\nconst { pipeline } = require('./pipeline')\nconst Duplex = require('./duplex')\nconst { destroyer } = require('./destroy')\nconst {\n  isNodeStream,\n  isReadable,\n  isWritable,\n  isWebStream,\n  isTransformStream,\n  isWritableStream,\n  isReadableStream\n} = require('./utils')\nconst {\n  AbortError,\n  codes: { ERR_INVALID_ARG_VALUE, ERR_MISSING_ARGS }\n} = require('../../ours/errors')\nconst eos = require('./end-of-stream')\nmodule.exports = function compose(...streams) {\n  if (streams.length === 0) {\n    throw new ERR_MISSING_ARGS('streams')\n  }\n  if (streams.length === 1) {\n    return Duplex.from(streams[0])\n  }\n  const orgStreams = [...streams]\n  if (typeof streams[0] === 'function') {\n    streams[0] = Duplex.from(streams[0])\n  }\n  if (typeof streams[streams.length - 1] === 'function') {\n    const idx = streams.length - 1\n    streams[idx] = Duplex.from(streams[idx])\n  }\n  for (let n = 0; n < streams.length; ++n) {\n    if (!isNodeStream(streams[n]) && !isWebStream(streams[n])) {\n      // TODO(ronag): Add checks for non streams.\n      continue\n    }\n    if (\n      n < streams.length - 1 &&\n      !(isReadable(streams[n]) || isReadableStream(streams[n]) || isTransformStream(streams[n]))\n    ) {\n      throw new ERR_INVALID_ARG_VALUE(`streams[${n}]`, orgStreams[n], 'must be readable')\n    }\n    if (n > 0 && !(isWritable(streams[n]) || isWritableStream(streams[n]) || isTransformStream(streams[n]))) {\n      throw new ERR_INVALID_ARG_VALUE(`streams[${n}]`, orgStreams[n], 'must be writable')\n    }\n  }\n  let ondrain\n  let onfinish\n  let onreadable\n  let onclose\n  let d\n  function onfinished(err) {\n    const cb = onclose\n    onclose = null\n    if (cb) {\n      cb(err)\n    } else if (err) {\n      d.destroy(err)\n    } else if (!readable && !writable) {\n      d.destroy()\n    }\n  }\n  const head = streams[0]\n  const tail = pipeline(streams, onfinished)\n  const writable = !!(isWritable(head) || isWritableStream(head) || isTransformStream(head))\n  const readable = !!(isReadable(tail) || isReadableStream(tail) || isTransformStream(tail))\n\n  // TODO(ronag): Avoid double buffering.\n  // Implement Writable/Readable/Duplex traits.\n  // See, https://github.com/nodejs/node/pull/33515.\n  d = new Duplex({\n    // TODO (ronag): highWaterMark?\n    writableObjectMode: !!(head !== null && head !== undefined && head.writableObjectMode),\n    readableObjectMode: !!(tail !== null && tail !== undefined && tail.writableObjectMode),\n    writable,\n    readable\n  })\n  if (writable) {\n    if (isNodeStream(head)) {\n      d._write = function (chunk, encoding, callback) {\n        if (head.write(chunk, encoding)) {\n          callback()\n        } else {\n          ondrain = callback\n        }\n      }\n      d._final = function (callback) {\n        head.end()\n        onfinish = callback\n      }\n      head.on('drain', function () {\n        if (ondrain) {\n          const cb = ondrain\n          ondrain = null\n          cb()\n        }\n      })\n    } else if (isWebStream(head)) {\n      const writable = isTransformStream(head) ? head.writable : head\n      const writer = writable.getWriter()\n      d._write = async function (chunk, encoding, callback) {\n        try {\n          await writer.ready\n          writer.write(chunk).catch(() => {})\n          callback()\n        } catch (err) {\n          callback(err)\n        }\n      }\n      d._final = async function (callback) {\n        try {\n          await writer.ready\n          writer.close().catch(() => {})\n          onfinish = callback\n        } catch (err) {\n          callback(err)\n        }\n      }\n    }\n    const toRead = isTransformStream(tail) ? tail.readable : tail\n    eos(toRead, () => {\n      if (onfinish) {\n        const cb = onfinish\n        onfinish = null\n        cb()\n      }\n    })\n  }\n  if (readable) {\n    if (isNodeStream(tail)) {\n      tail.on('readable', function () {\n        if (onreadable) {\n          const cb = onreadable\n          onreadable = null\n          cb()\n        }\n      })\n      tail.on('end', function () {\n        d.push(null)\n      })\n      d._read = function () {\n        while (true) {\n          const buf = tail.read()\n          if (buf === null) {\n            onreadable = d._read\n            return\n          }\n          if (!d.push(buf)) {\n            return\n          }\n        }\n      }\n    } else if (isWebStream(tail)) {\n      const readable = isTransformStream(tail) ? tail.readable : tail\n      const reader = readable.getReader()\n      d._read = async function () {\n        while (true) {\n          try {\n            const { value, done } = await reader.read()\n            if (!d.push(value)) {\n              return\n            }\n            if (done) {\n              d.push(null)\n              return\n            }\n          } catch {\n            return\n          }\n        }\n      }\n    }\n  }\n  d._destroy = function (err, callback) {\n    if (!err && onclose !== null) {\n      err = new AbortError()\n    }\n    onreadable = null\n    ondrain = null\n    onfinish = null\n    if (onclose === null) {\n      callback(err)\n    } else {\n      onclose = callback\n      if (isNodeStream(tail)) {\n        destroyer(tail, err)\n      }\n    }\n  }\n  return d\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}