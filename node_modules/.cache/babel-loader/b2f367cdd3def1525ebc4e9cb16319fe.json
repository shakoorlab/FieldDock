{"ast":null,"code":"const perf = typeof performance === 'object' && performance && typeof performance.now === 'function' ? performance : Date;\nconst hasAbortController = typeof AbortController === 'function';\n\n// minimal backwards-compatibility polyfill\n// this doesn't have nearly all the checks and whatnot that\n// actual AbortController/Signal has, but it's enough for\n// our purposes, and if used properly, behaves the same.\nconst AC = hasAbortController ? AbortController : class AbortController {\n  constructor() {\n    this.signal = new AS();\n  }\n  abort() {\n    let reason = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Error('This operation was aborted');\n    this.signal.reason = this.signal.reason || reason;\n    this.signal.aborted = true;\n    this.signal.dispatchEvent({\n      type: 'abort',\n      target: this.signal\n    });\n  }\n};\nconst hasAbortSignal = typeof AbortSignal === 'function';\n// Some polyfills put this on the AC class, not global\nconst hasACAbortSignal = typeof AC.AbortSignal === 'function';\nconst AS = hasAbortSignal ? AbortSignal : hasACAbortSignal ? AC.AbortController : class AbortSignal {\n  constructor() {\n    this.reason = undefined;\n    this.aborted = false;\n    this._listeners = [];\n  }\n  dispatchEvent(e) {\n    if (e.type === 'abort') {\n      this.aborted = true;\n      this.onabort(e);\n      this._listeners.forEach(f => f(e), this);\n    }\n  }\n  onabort() {}\n  addEventListener(ev, fn) {\n    if (ev === 'abort') {\n      this._listeners.push(fn);\n    }\n  }\n  removeEventListener(ev, fn) {\n    if (ev === 'abort') {\n      this._listeners = this._listeners.filter(f => f !== fn);\n    }\n  }\n};\nconst warned = new Set();\nconst deprecatedOption = (opt, instead) => {\n  const code = `LRU_CACHE_OPTION_${opt}`;\n  if (shouldWarn(code)) {\n    warn(code, `${opt} option`, `options.${instead}`, LRUCache);\n  }\n};\nconst deprecatedMethod = (method, instead) => {\n  const code = `LRU_CACHE_METHOD_${method}`;\n  if (shouldWarn(code)) {\n    const {\n      prototype\n    } = LRUCache;\n    const {\n      get\n    } = Object.getOwnPropertyDescriptor(prototype, method);\n    warn(code, `${method} method`, `cache.${instead}()`, get);\n  }\n};\nconst deprecatedProperty = (field, instead) => {\n  const code = `LRU_CACHE_PROPERTY_${field}`;\n  if (shouldWarn(code)) {\n    const {\n      prototype\n    } = LRUCache;\n    const {\n      get\n    } = Object.getOwnPropertyDescriptor(prototype, field);\n    warn(code, `${field} property`, `cache.${instead}`, get);\n  }\n};\nconst emitWarning = function () {\n  typeof process === 'object' && process && typeof process.emitWarning === 'function' ? process.emitWarning(...arguments) : console.error(...arguments);\n};\nconst shouldWarn = code => !warned.has(code);\nconst warn = (code, what, instead, fn) => {\n  warned.add(code);\n  const msg = `The ${what} is deprecated. Please use ${instead} instead.`;\n  emitWarning(msg, 'DeprecationWarning', code, fn);\n};\nconst isPosInt = n => n && n === Math.floor(n) && n > 0 && isFinite(n);\n\n/* istanbul ignore next - This is a little bit ridiculous, tbh.\n * The maximum array length is 2^32-1 or thereabouts on most JS impls.\n * And well before that point, you're caching the entire world, I mean,\n * that's ~32GB of just integers for the next/prev links, plus whatever\n * else to hold that many keys and values.  Just filling the memory with\n * zeroes at init time is brutal when you get that big.\n * But why not be complete?\n * Maybe in the future, these limits will have expanded. */\nconst getUintArray = max => !isPosInt(max) ? null : max <= Math.pow(2, 8) ? Uint8Array : max <= Math.pow(2, 16) ? Uint16Array : max <= Math.pow(2, 32) ? Uint32Array : max <= Number.MAX_SAFE_INTEGER ? ZeroArray : null;\nclass ZeroArray extends Array {\n  constructor(size) {\n    super(size);\n    this.fill(0);\n  }\n}\nclass Stack {\n  constructor(max) {\n    if (max === 0) {\n      return [];\n    }\n    const UintArray = getUintArray(max);\n    this.heap = new UintArray(max);\n    this.length = 0;\n  }\n  push(n) {\n    this.heap[this.length++] = n;\n  }\n  pop() {\n    return this.heap[--this.length];\n  }\n}\nclass LRUCache {\n  constructor() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const {\n      max = 0,\n      ttl,\n      ttlResolution = 1,\n      ttlAutopurge,\n      updateAgeOnGet,\n      updateAgeOnHas,\n      allowStale,\n      dispose,\n      disposeAfter,\n      noDisposeOnSet,\n      noUpdateTTL,\n      maxSize = 0,\n      maxEntrySize = 0,\n      sizeCalculation,\n      fetchMethod,\n      fetchContext,\n      noDeleteOnFetchRejection,\n      noDeleteOnStaleGet,\n      allowStaleOnFetchRejection,\n      allowStaleOnFetchAbort,\n      ignoreFetchAbort\n    } = options;\n\n    // deprecated options, don't trigger a warning for getting them if\n    // the thing being passed in is another LRUCache we're copying.\n    const {\n      length,\n      maxAge,\n      stale\n    } = options instanceof LRUCache ? {} : options;\n    if (max !== 0 && !isPosInt(max)) {\n      throw new TypeError('max option must be a nonnegative integer');\n    }\n    const UintArray = max ? getUintArray(max) : Array;\n    if (!UintArray) {\n      throw new Error('invalid max value: ' + max);\n    }\n    this.max = max;\n    this.maxSize = maxSize;\n    this.maxEntrySize = maxEntrySize || this.maxSize;\n    this.sizeCalculation = sizeCalculation || length;\n    if (this.sizeCalculation) {\n      if (!this.maxSize && !this.maxEntrySize) {\n        throw new TypeError('cannot set sizeCalculation without setting maxSize or maxEntrySize');\n      }\n      if (typeof this.sizeCalculation !== 'function') {\n        throw new TypeError('sizeCalculation set to non-function');\n      }\n    }\n    this.fetchMethod = fetchMethod || null;\n    if (this.fetchMethod && typeof this.fetchMethod !== 'function') {\n      throw new TypeError('fetchMethod must be a function if specified');\n    }\n    this.fetchContext = fetchContext;\n    if (!this.fetchMethod && fetchContext !== undefined) {\n      throw new TypeError('cannot set fetchContext without fetchMethod');\n    }\n    this.keyMap = new Map();\n    this.keyList = new Array(max).fill(null);\n    this.valList = new Array(max).fill(null);\n    this.next = new UintArray(max);\n    this.prev = new UintArray(max);\n    this.head = 0;\n    this.tail = 0;\n    this.free = new Stack(max);\n    this.initialFill = 1;\n    this.size = 0;\n    if (typeof dispose === 'function') {\n      this.dispose = dispose;\n    }\n    if (typeof disposeAfter === 'function') {\n      this.disposeAfter = disposeAfter;\n      this.disposed = [];\n    } else {\n      this.disposeAfter = null;\n      this.disposed = null;\n    }\n    this.noDisposeOnSet = !!noDisposeOnSet;\n    this.noUpdateTTL = !!noUpdateTTL;\n    this.noDeleteOnFetchRejection = !!noDeleteOnFetchRejection;\n    this.allowStaleOnFetchRejection = !!allowStaleOnFetchRejection;\n    this.allowStaleOnFetchAbort = !!allowStaleOnFetchAbort;\n    this.ignoreFetchAbort = !!ignoreFetchAbort;\n\n    // NB: maxEntrySize is set to maxSize if it's set\n    if (this.maxEntrySize !== 0) {\n      if (this.maxSize !== 0) {\n        if (!isPosInt(this.maxSize)) {\n          throw new TypeError('maxSize must be a positive integer if specified');\n        }\n      }\n      if (!isPosInt(this.maxEntrySize)) {\n        throw new TypeError('maxEntrySize must be a positive integer if specified');\n      }\n      this.initializeSizeTracking();\n    }\n    this.allowStale = !!allowStale || !!stale;\n    this.noDeleteOnStaleGet = !!noDeleteOnStaleGet;\n    this.updateAgeOnGet = !!updateAgeOnGet;\n    this.updateAgeOnHas = !!updateAgeOnHas;\n    this.ttlResolution = isPosInt(ttlResolution) || ttlResolution === 0 ? ttlResolution : 1;\n    this.ttlAutopurge = !!ttlAutopurge;\n    this.ttl = ttl || maxAge || 0;\n    if (this.ttl) {\n      if (!isPosInt(this.ttl)) {\n        throw new TypeError('ttl must be a positive integer if specified');\n      }\n      this.initializeTTLTracking();\n    }\n\n    // do not allow completely unbounded caches\n    if (this.max === 0 && this.ttl === 0 && this.maxSize === 0) {\n      throw new TypeError('At least one of max, maxSize, or ttl is required');\n    }\n    if (!this.ttlAutopurge && !this.max && !this.maxSize) {\n      const code = 'LRU_CACHE_UNBOUNDED';\n      if (shouldWarn(code)) {\n        warned.add(code);\n        const msg = 'TTL caching without ttlAutopurge, max, or maxSize can ' + 'result in unbounded memory consumption.';\n        emitWarning(msg, 'UnboundedCacheWarning', code, LRUCache);\n      }\n    }\n    if (stale) {\n      deprecatedOption('stale', 'allowStale');\n    }\n    if (maxAge) {\n      deprecatedOption('maxAge', 'ttl');\n    }\n    if (length) {\n      deprecatedOption('length', 'sizeCalculation');\n    }\n  }\n  getRemainingTTL(key) {\n    return this.has(key, {\n      updateAgeOnHas: false\n    }) ? Infinity : 0;\n  }\n  initializeTTLTracking() {\n    var _this = this;\n    this.ttls = new ZeroArray(this.max);\n    this.starts = new ZeroArray(this.max);\n    this.setItemTTL = function (index, ttl) {\n      let start = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : perf.now();\n      _this.starts[index] = ttl !== 0 ? start : 0;\n      _this.ttls[index] = ttl;\n      if (ttl !== 0 && _this.ttlAutopurge) {\n        const t = setTimeout(() => {\n          if (_this.isStale(index)) {\n            _this.delete(_this.keyList[index]);\n          }\n        }, ttl + 1);\n        /* istanbul ignore else - unref() not supported on all platforms */\n        if (t.unref) {\n          t.unref();\n        }\n      }\n    };\n    this.updateItemAge = index => {\n      this.starts[index] = this.ttls[index] !== 0 ? perf.now() : 0;\n    };\n    this.statusTTL = (status, index) => {\n      if (status) {\n        status.ttl = this.ttls[index];\n        status.start = this.starts[index];\n        status.now = cachedNow || getNow();\n        status.remainingTTL = status.now + status.ttl - status.start;\n      }\n    };\n\n    // debounce calls to perf.now() to 1s so we're not hitting\n    // that costly call repeatedly.\n    let cachedNow = 0;\n    const getNow = () => {\n      const n = perf.now();\n      if (this.ttlResolution > 0) {\n        cachedNow = n;\n        const t = setTimeout(() => cachedNow = 0, this.ttlResolution);\n        /* istanbul ignore else - not available on all platforms */\n        if (t.unref) {\n          t.unref();\n        }\n      }\n      return n;\n    };\n    this.getRemainingTTL = key => {\n      const index = this.keyMap.get(key);\n      if (index === undefined) {\n        return 0;\n      }\n      return this.ttls[index] === 0 || this.starts[index] === 0 ? Infinity : this.starts[index] + this.ttls[index] - (cachedNow || getNow());\n    };\n    this.isStale = index => {\n      return this.ttls[index] !== 0 && this.starts[index] !== 0 && (cachedNow || getNow()) - this.starts[index] > this.ttls[index];\n    };\n  }\n  updateItemAge(_index) {}\n  statusTTL(_status, _index) {}\n  setItemTTL(_index, _ttl, _start) {}\n  isStale(_index) {\n    return false;\n  }\n  initializeSizeTracking() {\n    this.calculatedSize = 0;\n    this.sizes = new ZeroArray(this.max);\n    this.removeItemSize = index => {\n      this.calculatedSize -= this.sizes[index];\n      this.sizes[index] = 0;\n    };\n    this.requireSize = (k, v, size, sizeCalculation) => {\n      // provisionally accept background fetches.\n      // actual value size will be checked when they return.\n      if (this.isBackgroundFetch(v)) {\n        return 0;\n      }\n      if (!isPosInt(size)) {\n        if (sizeCalculation) {\n          if (typeof sizeCalculation !== 'function') {\n            throw new TypeError('sizeCalculation must be a function');\n          }\n          size = sizeCalculation(v, k);\n          if (!isPosInt(size)) {\n            throw new TypeError('sizeCalculation return invalid (expect positive integer)');\n          }\n        } else {\n          throw new TypeError('invalid size value (must be positive integer). ' + 'When maxSize or maxEntrySize is used, sizeCalculation or size ' + 'must be set.');\n        }\n      }\n      return size;\n    };\n    this.addItemSize = (index, size, status) => {\n      this.sizes[index] = size;\n      if (this.maxSize) {\n        const maxSize = this.maxSize - this.sizes[index];\n        while (this.calculatedSize > maxSize) {\n          this.evict(true);\n        }\n      }\n      this.calculatedSize += this.sizes[index];\n      if (status) {\n        status.entrySize = size;\n        status.totalCalculatedSize = this.calculatedSize;\n      }\n    };\n  }\n  removeItemSize(_index) {}\n  addItemSize(_index, _size) {}\n  requireSize(_k, _v, size, sizeCalculation) {\n    if (size || sizeCalculation) {\n      throw new TypeError('cannot set size without setting maxSize or maxEntrySize on cache');\n    }\n  }\n  indexes() {\n    var _this2 = this;\n    let {\n      allowStale = this.allowStale\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    return function* () {\n      if (_this2.size) {\n        for (let i = _this2.tail; true;) {\n          if (!_this2.isValidIndex(i)) {\n            break;\n          }\n          if (allowStale || !_this2.isStale(i)) {\n            yield i;\n          }\n          if (i === _this2.head) {\n            break;\n          } else {\n            i = _this2.prev[i];\n          }\n        }\n      }\n    }();\n  }\n  rindexes() {\n    var _this3 = this;\n    let {\n      allowStale = this.allowStale\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    return function* () {\n      if (_this3.size) {\n        for (let i = _this3.head; true;) {\n          if (!_this3.isValidIndex(i)) {\n            break;\n          }\n          if (allowStale || !_this3.isStale(i)) {\n            yield i;\n          }\n          if (i === _this3.tail) {\n            break;\n          } else {\n            i = _this3.next[i];\n          }\n        }\n      }\n    }();\n  }\n  isValidIndex(index) {\n    return index !== undefined && this.keyMap.get(this.keyList[index]) === index;\n  }\n  *entries() {\n    for (const i of this.indexes()) {\n      if (this.valList[i] !== undefined && this.keyList[i] !== undefined && !this.isBackgroundFetch(this.valList[i])) {\n        yield [this.keyList[i], this.valList[i]];\n      }\n    }\n  }\n  *rentries() {\n    for (const i of this.rindexes()) {\n      if (this.valList[i] !== undefined && this.keyList[i] !== undefined && !this.isBackgroundFetch(this.valList[i])) {\n        yield [this.keyList[i], this.valList[i]];\n      }\n    }\n  }\n  *keys() {\n    for (const i of this.indexes()) {\n      if (this.keyList[i] !== undefined && !this.isBackgroundFetch(this.valList[i])) {\n        yield this.keyList[i];\n      }\n    }\n  }\n  *rkeys() {\n    for (const i of this.rindexes()) {\n      if (this.keyList[i] !== undefined && !this.isBackgroundFetch(this.valList[i])) {\n        yield this.keyList[i];\n      }\n    }\n  }\n  *values() {\n    for (const i of this.indexes()) {\n      if (this.valList[i] !== undefined && !this.isBackgroundFetch(this.valList[i])) {\n        yield this.valList[i];\n      }\n    }\n  }\n  *rvalues() {\n    for (const i of this.rindexes()) {\n      if (this.valList[i] !== undefined && !this.isBackgroundFetch(this.valList[i])) {\n        yield this.valList[i];\n      }\n    }\n  }\n  [Symbol.iterator]() {\n    return this.entries();\n  }\n  find(fn, getOptions) {\n    for (const i of this.indexes()) {\n      const v = this.valList[i];\n      const value = this.isBackgroundFetch(v) ? v.__staleWhileFetching : v;\n      if (value === undefined) continue;\n      if (fn(value, this.keyList[i], this)) {\n        return this.get(this.keyList[i], getOptions);\n      }\n    }\n  }\n  forEach(fn) {\n    let thisp = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this;\n    for (const i of this.indexes()) {\n      const v = this.valList[i];\n      const value = this.isBackgroundFetch(v) ? v.__staleWhileFetching : v;\n      if (value === undefined) continue;\n      fn.call(thisp, value, this.keyList[i], this);\n    }\n  }\n  rforEach(fn) {\n    let thisp = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this;\n    for (const i of this.rindexes()) {\n      const v = this.valList[i];\n      const value = this.isBackgroundFetch(v) ? v.__staleWhileFetching : v;\n      if (value === undefined) continue;\n      fn.call(thisp, value, this.keyList[i], this);\n    }\n  }\n  get prune() {\n    deprecatedMethod('prune', 'purgeStale');\n    return this.purgeStale;\n  }\n  purgeStale() {\n    let deleted = false;\n    for (const i of this.rindexes({\n      allowStale: true\n    })) {\n      if (this.isStale(i)) {\n        this.delete(this.keyList[i]);\n        deleted = true;\n      }\n    }\n    return deleted;\n  }\n  dump() {\n    const arr = [];\n    for (const i of this.indexes({\n      allowStale: true\n    })) {\n      const key = this.keyList[i];\n      const v = this.valList[i];\n      const value = this.isBackgroundFetch(v) ? v.__staleWhileFetching : v;\n      if (value === undefined) continue;\n      const entry = {\n        value\n      };\n      if (this.ttls) {\n        entry.ttl = this.ttls[i];\n        // always dump the start relative to a portable timestamp\n        // it's ok for this to be a bit slow, it's a rare operation.\n        const age = perf.now() - this.starts[i];\n        entry.start = Math.floor(Date.now() - age);\n      }\n      if (this.sizes) {\n        entry.size = this.sizes[i];\n      }\n      arr.unshift([key, entry]);\n    }\n    return arr;\n  }\n  load(arr) {\n    this.clear();\n    for (const [key, entry] of arr) {\n      if (entry.start) {\n        // entry.start is a portable timestamp, but we may be using\n        // node's performance.now(), so calculate the offset.\n        // it's ok for this to be a bit slow, it's a rare operation.\n        const age = Date.now() - entry.start;\n        entry.start = perf.now() - age;\n      }\n      this.set(key, entry.value, entry);\n    }\n  }\n  dispose(_v, _k, _reason) {}\n  set(k, v) {\n    let {\n      ttl = this.ttl,\n      start,\n      noDisposeOnSet = this.noDisposeOnSet,\n      size = 0,\n      sizeCalculation = this.sizeCalculation,\n      noUpdateTTL = this.noUpdateTTL,\n      status\n    } = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    size = this.requireSize(k, v, size, sizeCalculation);\n    // if the item doesn't fit, don't do anything\n    // NB: maxEntrySize set to maxSize by default\n    if (this.maxEntrySize && size > this.maxEntrySize) {\n      if (status) {\n        status.set = 'miss';\n        status.maxEntrySizeExceeded = true;\n      }\n      // have to delete, in case a background fetch is there already.\n      // in non-async cases, this is a no-op\n      this.delete(k);\n      return this;\n    }\n    let index = this.size === 0 ? undefined : this.keyMap.get(k);\n    if (index === undefined) {\n      // addition\n      index = this.newIndex();\n      this.keyList[index] = k;\n      this.valList[index] = v;\n      this.keyMap.set(k, index);\n      this.next[this.tail] = index;\n      this.prev[index] = this.tail;\n      this.tail = index;\n      this.size++;\n      this.addItemSize(index, size, status);\n      if (status) {\n        status.set = 'add';\n      }\n      noUpdateTTL = false;\n    } else {\n      // update\n      this.moveToTail(index);\n      const oldVal = this.valList[index];\n      if (v !== oldVal) {\n        if (this.isBackgroundFetch(oldVal)) {\n          oldVal.__abortController.abort(new Error('replaced'));\n        } else {\n          if (!noDisposeOnSet) {\n            this.dispose(oldVal, k, 'set');\n            if (this.disposeAfter) {\n              this.disposed.push([oldVal, k, 'set']);\n            }\n          }\n        }\n        this.removeItemSize(index);\n        this.valList[index] = v;\n        this.addItemSize(index, size, status);\n        if (status) {\n          status.set = 'replace';\n          const oldValue = oldVal && this.isBackgroundFetch(oldVal) ? oldVal.__staleWhileFetching : oldVal;\n          if (oldValue !== undefined) status.oldValue = oldValue;\n        }\n      } else if (status) {\n        status.set = 'update';\n      }\n    }\n    if (ttl !== 0 && this.ttl === 0 && !this.ttls) {\n      this.initializeTTLTracking();\n    }\n    if (!noUpdateTTL) {\n      this.setItemTTL(index, ttl, start);\n    }\n    this.statusTTL(status, index);\n    if (this.disposeAfter) {\n      while (this.disposed.length) {\n        this.disposeAfter(...this.disposed.shift());\n      }\n    }\n    return this;\n  }\n  newIndex() {\n    if (this.size === 0) {\n      return this.tail;\n    }\n    if (this.size === this.max && this.max !== 0) {\n      return this.evict(false);\n    }\n    if (this.free.length !== 0) {\n      return this.free.pop();\n    }\n    // initial fill, just keep writing down the list\n    return this.initialFill++;\n  }\n  pop() {\n    if (this.size) {\n      const val = this.valList[this.head];\n      this.evict(true);\n      return val;\n    }\n  }\n  evict(free) {\n    const head = this.head;\n    const k = this.keyList[head];\n    const v = this.valList[head];\n    if (this.isBackgroundFetch(v)) {\n      v.__abortController.abort(new Error('evicted'));\n    } else {\n      this.dispose(v, k, 'evict');\n      if (this.disposeAfter) {\n        this.disposed.push([v, k, 'evict']);\n      }\n    }\n    this.removeItemSize(head);\n    // if we aren't about to use the index, then null these out\n    if (free) {\n      this.keyList[head] = null;\n      this.valList[head] = null;\n      this.free.push(head);\n    }\n    this.head = this.next[head];\n    this.keyMap.delete(k);\n    this.size--;\n    return head;\n  }\n  has(k) {\n    let {\n      updateAgeOnHas = this.updateAgeOnHas,\n      status\n    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const index = this.keyMap.get(k);\n    if (index !== undefined) {\n      if (!this.isStale(index)) {\n        if (updateAgeOnHas) {\n          this.updateItemAge(index);\n        }\n        if (status) status.has = 'hit';\n        this.statusTTL(status, index);\n        return true;\n      } else if (status) {\n        status.has = 'stale';\n        this.statusTTL(status, index);\n      }\n    } else if (status) {\n      status.has = 'miss';\n    }\n    return false;\n  }\n\n  // like get(), but without any LRU updating or TTL expiration\n  peek(k) {\n    let {\n      allowStale = this.allowStale\n    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const index = this.keyMap.get(k);\n    if (index !== undefined && (allowStale || !this.isStale(index))) {\n      const v = this.valList[index];\n      // either stale and allowed, or forcing a refresh of non-stale value\n      return this.isBackgroundFetch(v) ? v.__staleWhileFetching : v;\n    }\n  }\n  backgroundFetch(k, index, options, context) {\n    var _this4 = this;\n    const v = index === undefined ? undefined : this.valList[index];\n    if (this.isBackgroundFetch(v)) {\n      return v;\n    }\n    const ac = new AC();\n    if (options.signal) {\n      options.signal.addEventListener('abort', () => ac.abort(options.signal.reason));\n    }\n    const fetchOpts = {\n      signal: ac.signal,\n      options,\n      context\n    };\n    const cb = function (v) {\n      let updateCache = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      const {\n        aborted\n      } = ac.signal;\n      const ignoreAbort = options.ignoreFetchAbort && v !== undefined;\n      if (options.status) {\n        if (aborted && !updateCache) {\n          options.status.fetchAborted = true;\n          options.status.fetchError = ac.signal.reason;\n          if (ignoreAbort) options.status.fetchAbortIgnored = true;\n        } else {\n          options.status.fetchResolved = true;\n        }\n      }\n      if (aborted && !ignoreAbort && !updateCache) {\n        return fetchFail(ac.signal.reason);\n      }\n      // either we didn't abort, and are still here, or we did, and ignored\n      if (_this4.valList[index] === p) {\n        if (v === undefined) {\n          if (p.__staleWhileFetching) {\n            _this4.valList[index] = p.__staleWhileFetching;\n          } else {\n            _this4.delete(k);\n          }\n        } else {\n          if (options.status) options.status.fetchUpdated = true;\n          _this4.set(k, v, fetchOpts.options);\n        }\n      }\n      return v;\n    };\n    const eb = er => {\n      if (options.status) {\n        options.status.fetchRejected = true;\n        options.status.fetchError = er;\n      }\n      return fetchFail(er);\n    };\n    const fetchFail = er => {\n      const {\n        aborted\n      } = ac.signal;\n      const allowStaleAborted = aborted && options.allowStaleOnFetchAbort;\n      const allowStale = allowStaleAborted || options.allowStaleOnFetchRejection;\n      const noDelete = allowStale || options.noDeleteOnFetchRejection;\n      if (this.valList[index] === p) {\n        // if we allow stale on fetch rejections, then we need to ensure that\n        // the stale value is not removed from the cache when the fetch fails.\n        const del = !noDelete || p.__staleWhileFetching === undefined;\n        if (del) {\n          this.delete(k);\n        } else if (!allowStaleAborted) {\n          // still replace the *promise* with the stale value,\n          // since we are done with the promise at this point.\n          // leave it untouched if we're still waiting for an\n          // aborted background fetch that hasn't yet returned.\n          this.valList[index] = p.__staleWhileFetching;\n        }\n      }\n      if (allowStale) {\n        if (options.status && p.__staleWhileFetching !== undefined) {\n          options.status.returnedStale = true;\n        }\n        return p.__staleWhileFetching;\n      } else if (p.__returned === p) {\n        throw er;\n      }\n    };\n    const pcall = (res, rej) => {\n      this.fetchMethod(k, v, fetchOpts).then(v => res(v), rej);\n      // ignored, we go until we finish, regardless.\n      // defer check until we are actually aborting,\n      // so fetchMethod can override.\n      ac.signal.addEventListener('abort', () => {\n        if (!options.ignoreFetchAbort || options.allowStaleOnFetchAbort) {\n          res();\n          // when it eventually resolves, update the cache.\n          if (options.allowStaleOnFetchAbort) {\n            res = v => cb(v, true);\n          }\n        }\n      });\n    };\n    if (options.status) options.status.fetchDispatched = true;\n    const p = new Promise(pcall).then(cb, eb);\n    p.__abortController = ac;\n    p.__staleWhileFetching = v;\n    p.__returned = null;\n    if (index === undefined) {\n      // internal, don't expose status.\n      this.set(k, p, {\n        ...fetchOpts.options,\n        status: undefined\n      });\n      index = this.keyMap.get(k);\n    } else {\n      this.valList[index] = p;\n    }\n    return p;\n  }\n  isBackgroundFetch(p) {\n    return p && typeof p === 'object' && typeof p.then === 'function' && Object.prototype.hasOwnProperty.call(p, '__staleWhileFetching') && Object.prototype.hasOwnProperty.call(p, '__returned') && (p.__returned === p || p.__returned === null);\n  }\n\n  // this takes the union of get() and set() opts, because it does both\n  async fetch(k) {\n    let {\n      // get options\n      allowStale = this.allowStale,\n      updateAgeOnGet = this.updateAgeOnGet,\n      noDeleteOnStaleGet = this.noDeleteOnStaleGet,\n      // set options\n      ttl = this.ttl,\n      noDisposeOnSet = this.noDisposeOnSet,\n      size = 0,\n      sizeCalculation = this.sizeCalculation,\n      noUpdateTTL = this.noUpdateTTL,\n      // fetch exclusive options\n      noDeleteOnFetchRejection = this.noDeleteOnFetchRejection,\n      allowStaleOnFetchRejection = this.allowStaleOnFetchRejection,\n      ignoreFetchAbort = this.ignoreFetchAbort,\n      allowStaleOnFetchAbort = this.allowStaleOnFetchAbort,\n      fetchContext = this.fetchContext,\n      forceRefresh = false,\n      status,\n      signal\n    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    if (!this.fetchMethod) {\n      if (status) status.fetch = 'get';\n      return this.get(k, {\n        allowStale,\n        updateAgeOnGet,\n        noDeleteOnStaleGet,\n        status\n      });\n    }\n    const options = {\n      allowStale,\n      updateAgeOnGet,\n      noDeleteOnStaleGet,\n      ttl,\n      noDisposeOnSet,\n      size,\n      sizeCalculation,\n      noUpdateTTL,\n      noDeleteOnFetchRejection,\n      allowStaleOnFetchRejection,\n      allowStaleOnFetchAbort,\n      ignoreFetchAbort,\n      status,\n      signal\n    };\n    let index = this.keyMap.get(k);\n    if (index === undefined) {\n      if (status) status.fetch = 'miss';\n      const p = this.backgroundFetch(k, index, options, fetchContext);\n      return p.__returned = p;\n    } else {\n      // in cache, maybe already fetching\n      const v = this.valList[index];\n      if (this.isBackgroundFetch(v)) {\n        const stale = allowStale && v.__staleWhileFetching !== undefined;\n        if (status) {\n          status.fetch = 'inflight';\n          if (stale) status.returnedStale = true;\n        }\n        return stale ? v.__staleWhileFetching : v.__returned = v;\n      }\n\n      // if we force a refresh, that means do NOT serve the cached value,\n      // unless we are already in the process of refreshing the cache.\n      const isStale = this.isStale(index);\n      if (!forceRefresh && !isStale) {\n        if (status) status.fetch = 'hit';\n        this.moveToTail(index);\n        if (updateAgeOnGet) {\n          this.updateItemAge(index);\n        }\n        this.statusTTL(status, index);\n        return v;\n      }\n\n      // ok, it is stale or a forced refresh, and not already fetching.\n      // refresh the cache.\n      const p = this.backgroundFetch(k, index, options, fetchContext);\n      const hasStale = p.__staleWhileFetching !== undefined;\n      const staleVal = hasStale && allowStale;\n      if (status) {\n        status.fetch = hasStale && isStale ? 'stale' : 'refresh';\n        if (staleVal && isStale) status.returnedStale = true;\n      }\n      return staleVal ? p.__staleWhileFetching : p.__returned = p;\n    }\n  }\n  get(k) {\n    let {\n      allowStale = this.allowStale,\n      updateAgeOnGet = this.updateAgeOnGet,\n      noDeleteOnStaleGet = this.noDeleteOnStaleGet,\n      status\n    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const index = this.keyMap.get(k);\n    if (index !== undefined) {\n      const value = this.valList[index];\n      const fetching = this.isBackgroundFetch(value);\n      this.statusTTL(status, index);\n      if (this.isStale(index)) {\n        if (status) status.get = 'stale';\n        // delete only if not an in-flight background fetch\n        if (!fetching) {\n          if (!noDeleteOnStaleGet) {\n            this.delete(k);\n          }\n          if (status) status.returnedStale = allowStale;\n          return allowStale ? value : undefined;\n        } else {\n          if (status) {\n            status.returnedStale = allowStale && value.__staleWhileFetching !== undefined;\n          }\n          return allowStale ? value.__staleWhileFetching : undefined;\n        }\n      } else {\n        if (status) status.get = 'hit';\n        // if we're currently fetching it, we don't actually have it yet\n        // it's not stale, which means this isn't a staleWhileRefetching.\n        // If it's not stale, and fetching, AND has a __staleWhileFetching\n        // value, then that means the user fetched with {forceRefresh:true},\n        // so it's safe to return that value.\n        if (fetching) {\n          return value.__staleWhileFetching;\n        }\n        this.moveToTail(index);\n        if (updateAgeOnGet) {\n          this.updateItemAge(index);\n        }\n        return value;\n      }\n    } else if (status) {\n      status.get = 'miss';\n    }\n  }\n  connect(p, n) {\n    this.prev[n] = p;\n    this.next[p] = n;\n  }\n  moveToTail(index) {\n    // if tail already, nothing to do\n    // if head, move head to next[index]\n    // else\n    //   move next[prev[index]] to next[index] (head has no prev)\n    //   move prev[next[index]] to prev[index]\n    // prev[index] = tail\n    // next[tail] = index\n    // tail = index\n    if (index !== this.tail) {\n      if (index === this.head) {\n        this.head = this.next[index];\n      } else {\n        this.connect(this.prev[index], this.next[index]);\n      }\n      this.connect(this.tail, index);\n      this.tail = index;\n    }\n  }\n  get del() {\n    deprecatedMethod('del', 'delete');\n    return this.delete;\n  }\n  delete(k) {\n    let deleted = false;\n    if (this.size !== 0) {\n      const index = this.keyMap.get(k);\n      if (index !== undefined) {\n        deleted = true;\n        if (this.size === 1) {\n          this.clear();\n        } else {\n          this.removeItemSize(index);\n          const v = this.valList[index];\n          if (this.isBackgroundFetch(v)) {\n            v.__abortController.abort(new Error('deleted'));\n          } else {\n            this.dispose(v, k, 'delete');\n            if (this.disposeAfter) {\n              this.disposed.push([v, k, 'delete']);\n            }\n          }\n          this.keyMap.delete(k);\n          this.keyList[index] = null;\n          this.valList[index] = null;\n          if (index === this.tail) {\n            this.tail = this.prev[index];\n          } else if (index === this.head) {\n            this.head = this.next[index];\n          } else {\n            this.next[this.prev[index]] = this.next[index];\n            this.prev[this.next[index]] = this.prev[index];\n          }\n          this.size--;\n          this.free.push(index);\n        }\n      }\n    }\n    if (this.disposed) {\n      while (this.disposed.length) {\n        this.disposeAfter(...this.disposed.shift());\n      }\n    }\n    return deleted;\n  }\n  clear() {\n    for (const index of this.rindexes({\n      allowStale: true\n    })) {\n      const v = this.valList[index];\n      if (this.isBackgroundFetch(v)) {\n        v.__abortController.abort(new Error('deleted'));\n      } else {\n        const k = this.keyList[index];\n        this.dispose(v, k, 'delete');\n        if (this.disposeAfter) {\n          this.disposed.push([v, k, 'delete']);\n        }\n      }\n    }\n    this.keyMap.clear();\n    this.valList.fill(null);\n    this.keyList.fill(null);\n    if (this.ttls) {\n      this.ttls.fill(0);\n      this.starts.fill(0);\n    }\n    if (this.sizes) {\n      this.sizes.fill(0);\n    }\n    this.head = 0;\n    this.tail = 0;\n    this.initialFill = 1;\n    this.free.length = 0;\n    this.calculatedSize = 0;\n    this.size = 0;\n    if (this.disposed) {\n      while (this.disposed.length) {\n        this.disposeAfter(...this.disposed.shift());\n      }\n    }\n  }\n  get reset() {\n    deprecatedMethod('reset', 'clear');\n    return this.clear;\n  }\n  get length() {\n    deprecatedProperty('length', 'size');\n    return this.size;\n  }\n  static get AbortController() {\n    return AC;\n  }\n  static get AbortSignal() {\n    return AS;\n  }\n}\nmodule.exports = LRUCache;","map":{"version":3,"names":["perf","performance","now","Date","hasAbortController","AbortController","AC","constructor","signal","AS","abort","reason","arguments","length","undefined","Error","aborted","dispatchEvent","type","target","hasAbortSignal","AbortSignal","hasACAbortSignal","_listeners","e","onabort","forEach","f","addEventListener","ev","fn","push","removeEventListener","filter","warned","Set","deprecatedOption","opt","instead","code","shouldWarn","warn","LRUCache","deprecatedMethod","method","prototype","get","Object","getOwnPropertyDescriptor","deprecatedProperty","field","emitWarning","process","console","error","has","what","add","msg","isPosInt","n","Math","floor","isFinite","getUintArray","max","pow","Uint8Array","Uint16Array","Uint32Array","Number","MAX_SAFE_INTEGER","ZeroArray","Array","size","fill","Stack","UintArray","heap","pop","options","ttl","ttlResolution","ttlAutopurge","updateAgeOnGet","updateAgeOnHas","allowStale","dispose","disposeAfter","noDisposeOnSet","noUpdateTTL","maxSize","maxEntrySize","sizeCalculation","fetchMethod","fetchContext","noDeleteOnFetchRejection","noDeleteOnStaleGet","allowStaleOnFetchRejection","allowStaleOnFetchAbort","ignoreFetchAbort","maxAge","stale","TypeError","keyMap","Map","keyList","valList","next","prev","head","tail","free","initialFill","disposed","initializeSizeTracking","initializeTTLTracking","getRemainingTTL","key","Infinity","_this","ttls","starts","setItemTTL","index","start","t","setTimeout","isStale","delete","unref","updateItemAge","statusTTL","status","cachedNow","getNow","remainingTTL","_index","_status","_ttl","_start","calculatedSize","sizes","removeItemSize","requireSize","k","v","isBackgroundFetch","addItemSize","evict","entrySize","totalCalculatedSize","_size","_k","_v","indexes","_this2","i","isValidIndex","rindexes","_this3","entries","rentries","keys","rkeys","values","rvalues","Symbol","iterator","find","getOptions","value","__staleWhileFetching","thisp","call","rforEach","prune","purgeStale","deleted","dump","arr","entry","age","unshift","load","clear","set","_reason","maxEntrySizeExceeded","newIndex","moveToTail","oldVal","__abortController","oldValue","shift","val","peek","backgroundFetch","context","_this4","ac","fetchOpts","cb","updateCache","ignoreAbort","fetchAborted","fetchError","fetchAbortIgnored","fetchResolved","fetchFail","p","fetchUpdated","eb","er","fetchRejected","allowStaleAborted","noDelete","del","returnedStale","__returned","pcall","res","rej","then","fetchDispatched","Promise","hasOwnProperty","fetch","forceRefresh","hasStale","staleVal","fetching","connect","reset","module","exports"],"sources":["/Users/jstanton/Coding/FieldDock/FieldDockMain/node_modules/mqtt/node_modules/lru-cache/index.js"],"sourcesContent":["const perf =\n  typeof performance === 'object' &&\n  performance &&\n  typeof performance.now === 'function'\n    ? performance\n    : Date\n\nconst hasAbortController = typeof AbortController === 'function'\n\n// minimal backwards-compatibility polyfill\n// this doesn't have nearly all the checks and whatnot that\n// actual AbortController/Signal has, but it's enough for\n// our purposes, and if used properly, behaves the same.\nconst AC = hasAbortController\n  ? AbortController\n  : class AbortController {\n      constructor() {\n        this.signal = new AS()\n      }\n      abort(reason = new Error('This operation was aborted')) {\n        this.signal.reason = this.signal.reason || reason\n        this.signal.aborted = true\n        this.signal.dispatchEvent({\n          type: 'abort',\n          target: this.signal,\n        })\n      }\n    }\n\nconst hasAbortSignal = typeof AbortSignal === 'function'\n// Some polyfills put this on the AC class, not global\nconst hasACAbortSignal = typeof AC.AbortSignal === 'function'\nconst AS = hasAbortSignal\n  ? AbortSignal\n  : hasACAbortSignal\n  ? AC.AbortController\n  : class AbortSignal {\n      constructor() {\n        this.reason = undefined\n        this.aborted = false\n        this._listeners = []\n      }\n      dispatchEvent(e) {\n        if (e.type === 'abort') {\n          this.aborted = true\n          this.onabort(e)\n          this._listeners.forEach(f => f(e), this)\n        }\n      }\n      onabort() {}\n      addEventListener(ev, fn) {\n        if (ev === 'abort') {\n          this._listeners.push(fn)\n        }\n      }\n      removeEventListener(ev, fn) {\n        if (ev === 'abort') {\n          this._listeners = this._listeners.filter(f => f !== fn)\n        }\n      }\n    }\n\nconst warned = new Set()\nconst deprecatedOption = (opt, instead) => {\n  const code = `LRU_CACHE_OPTION_${opt}`\n  if (shouldWarn(code)) {\n    warn(code, `${opt} option`, `options.${instead}`, LRUCache)\n  }\n}\nconst deprecatedMethod = (method, instead) => {\n  const code = `LRU_CACHE_METHOD_${method}`\n  if (shouldWarn(code)) {\n    const { prototype } = LRUCache\n    const { get } = Object.getOwnPropertyDescriptor(prototype, method)\n    warn(code, `${method} method`, `cache.${instead}()`, get)\n  }\n}\nconst deprecatedProperty = (field, instead) => {\n  const code = `LRU_CACHE_PROPERTY_${field}`\n  if (shouldWarn(code)) {\n    const { prototype } = LRUCache\n    const { get } = Object.getOwnPropertyDescriptor(prototype, field)\n    warn(code, `${field} property`, `cache.${instead}`, get)\n  }\n}\n\nconst emitWarning = (...a) => {\n  typeof process === 'object' &&\n  process &&\n  typeof process.emitWarning === 'function'\n    ? process.emitWarning(...a)\n    : console.error(...a)\n}\n\nconst shouldWarn = code => !warned.has(code)\n\nconst warn = (code, what, instead, fn) => {\n  warned.add(code)\n  const msg = `The ${what} is deprecated. Please use ${instead} instead.`\n  emitWarning(msg, 'DeprecationWarning', code, fn)\n}\n\nconst isPosInt = n => n && n === Math.floor(n) && n > 0 && isFinite(n)\n\n/* istanbul ignore next - This is a little bit ridiculous, tbh.\n * The maximum array length is 2^32-1 or thereabouts on most JS impls.\n * And well before that point, you're caching the entire world, I mean,\n * that's ~32GB of just integers for the next/prev links, plus whatever\n * else to hold that many keys and values.  Just filling the memory with\n * zeroes at init time is brutal when you get that big.\n * But why not be complete?\n * Maybe in the future, these limits will have expanded. */\nconst getUintArray = max =>\n  !isPosInt(max)\n    ? null\n    : max <= Math.pow(2, 8)\n    ? Uint8Array\n    : max <= Math.pow(2, 16)\n    ? Uint16Array\n    : max <= Math.pow(2, 32)\n    ? Uint32Array\n    : max <= Number.MAX_SAFE_INTEGER\n    ? ZeroArray\n    : null\n\nclass ZeroArray extends Array {\n  constructor(size) {\n    super(size)\n    this.fill(0)\n  }\n}\n\nclass Stack {\n  constructor(max) {\n    if (max === 0) {\n      return []\n    }\n    const UintArray = getUintArray(max)\n    this.heap = new UintArray(max)\n    this.length = 0\n  }\n  push(n) {\n    this.heap[this.length++] = n\n  }\n  pop() {\n    return this.heap[--this.length]\n  }\n}\n\nclass LRUCache {\n  constructor(options = {}) {\n    const {\n      max = 0,\n      ttl,\n      ttlResolution = 1,\n      ttlAutopurge,\n      updateAgeOnGet,\n      updateAgeOnHas,\n      allowStale,\n      dispose,\n      disposeAfter,\n      noDisposeOnSet,\n      noUpdateTTL,\n      maxSize = 0,\n      maxEntrySize = 0,\n      sizeCalculation,\n      fetchMethod,\n      fetchContext,\n      noDeleteOnFetchRejection,\n      noDeleteOnStaleGet,\n      allowStaleOnFetchRejection,\n      allowStaleOnFetchAbort,\n      ignoreFetchAbort,\n    } = options\n\n    // deprecated options, don't trigger a warning for getting them if\n    // the thing being passed in is another LRUCache we're copying.\n    const { length, maxAge, stale } =\n      options instanceof LRUCache ? {} : options\n\n    if (max !== 0 && !isPosInt(max)) {\n      throw new TypeError('max option must be a nonnegative integer')\n    }\n\n    const UintArray = max ? getUintArray(max) : Array\n    if (!UintArray) {\n      throw new Error('invalid max value: ' + max)\n    }\n\n    this.max = max\n    this.maxSize = maxSize\n    this.maxEntrySize = maxEntrySize || this.maxSize\n    this.sizeCalculation = sizeCalculation || length\n    if (this.sizeCalculation) {\n      if (!this.maxSize && !this.maxEntrySize) {\n        throw new TypeError(\n          'cannot set sizeCalculation without setting maxSize or maxEntrySize'\n        )\n      }\n      if (typeof this.sizeCalculation !== 'function') {\n        throw new TypeError('sizeCalculation set to non-function')\n      }\n    }\n\n    this.fetchMethod = fetchMethod || null\n    if (this.fetchMethod && typeof this.fetchMethod !== 'function') {\n      throw new TypeError(\n        'fetchMethod must be a function if specified'\n      )\n    }\n\n    this.fetchContext = fetchContext\n    if (!this.fetchMethod && fetchContext !== undefined) {\n      throw new TypeError(\n        'cannot set fetchContext without fetchMethod'\n      )\n    }\n\n    this.keyMap = new Map()\n    this.keyList = new Array(max).fill(null)\n    this.valList = new Array(max).fill(null)\n    this.next = new UintArray(max)\n    this.prev = new UintArray(max)\n    this.head = 0\n    this.tail = 0\n    this.free = new Stack(max)\n    this.initialFill = 1\n    this.size = 0\n\n    if (typeof dispose === 'function') {\n      this.dispose = dispose\n    }\n    if (typeof disposeAfter === 'function') {\n      this.disposeAfter = disposeAfter\n      this.disposed = []\n    } else {\n      this.disposeAfter = null\n      this.disposed = null\n    }\n    this.noDisposeOnSet = !!noDisposeOnSet\n    this.noUpdateTTL = !!noUpdateTTL\n    this.noDeleteOnFetchRejection = !!noDeleteOnFetchRejection\n    this.allowStaleOnFetchRejection = !!allowStaleOnFetchRejection\n    this.allowStaleOnFetchAbort = !!allowStaleOnFetchAbort\n    this.ignoreFetchAbort = !!ignoreFetchAbort\n\n    // NB: maxEntrySize is set to maxSize if it's set\n    if (this.maxEntrySize !== 0) {\n      if (this.maxSize !== 0) {\n        if (!isPosInt(this.maxSize)) {\n          throw new TypeError(\n            'maxSize must be a positive integer if specified'\n          )\n        }\n      }\n      if (!isPosInt(this.maxEntrySize)) {\n        throw new TypeError(\n          'maxEntrySize must be a positive integer if specified'\n        )\n      }\n      this.initializeSizeTracking()\n    }\n\n    this.allowStale = !!allowStale || !!stale\n    this.noDeleteOnStaleGet = !!noDeleteOnStaleGet\n    this.updateAgeOnGet = !!updateAgeOnGet\n    this.updateAgeOnHas = !!updateAgeOnHas\n    this.ttlResolution =\n      isPosInt(ttlResolution) || ttlResolution === 0\n        ? ttlResolution\n        : 1\n    this.ttlAutopurge = !!ttlAutopurge\n    this.ttl = ttl || maxAge || 0\n    if (this.ttl) {\n      if (!isPosInt(this.ttl)) {\n        throw new TypeError(\n          'ttl must be a positive integer if specified'\n        )\n      }\n      this.initializeTTLTracking()\n    }\n\n    // do not allow completely unbounded caches\n    if (this.max === 0 && this.ttl === 0 && this.maxSize === 0) {\n      throw new TypeError(\n        'At least one of max, maxSize, or ttl is required'\n      )\n    }\n    if (!this.ttlAutopurge && !this.max && !this.maxSize) {\n      const code = 'LRU_CACHE_UNBOUNDED'\n      if (shouldWarn(code)) {\n        warned.add(code)\n        const msg =\n          'TTL caching without ttlAutopurge, max, or maxSize can ' +\n          'result in unbounded memory consumption.'\n        emitWarning(msg, 'UnboundedCacheWarning', code, LRUCache)\n      }\n    }\n\n    if (stale) {\n      deprecatedOption('stale', 'allowStale')\n    }\n    if (maxAge) {\n      deprecatedOption('maxAge', 'ttl')\n    }\n    if (length) {\n      deprecatedOption('length', 'sizeCalculation')\n    }\n  }\n\n  getRemainingTTL(key) {\n    return this.has(key, { updateAgeOnHas: false }) ? Infinity : 0\n  }\n\n  initializeTTLTracking() {\n    this.ttls = new ZeroArray(this.max)\n    this.starts = new ZeroArray(this.max)\n\n    this.setItemTTL = (index, ttl, start = perf.now()) => {\n      this.starts[index] = ttl !== 0 ? start : 0\n      this.ttls[index] = ttl\n      if (ttl !== 0 && this.ttlAutopurge) {\n        const t = setTimeout(() => {\n          if (this.isStale(index)) {\n            this.delete(this.keyList[index])\n          }\n        }, ttl + 1)\n        /* istanbul ignore else - unref() not supported on all platforms */\n        if (t.unref) {\n          t.unref()\n        }\n      }\n    }\n\n    this.updateItemAge = index => {\n      this.starts[index] = this.ttls[index] !== 0 ? perf.now() : 0\n    }\n\n    this.statusTTL = (status, index) => {\n      if (status) {\n        status.ttl = this.ttls[index]\n        status.start = this.starts[index]\n        status.now = cachedNow || getNow()\n        status.remainingTTL = status.now + status.ttl - status.start\n      }\n    }\n\n    // debounce calls to perf.now() to 1s so we're not hitting\n    // that costly call repeatedly.\n    let cachedNow = 0\n    const getNow = () => {\n      const n = perf.now()\n      if (this.ttlResolution > 0) {\n        cachedNow = n\n        const t = setTimeout(\n          () => (cachedNow = 0),\n          this.ttlResolution\n        )\n        /* istanbul ignore else - not available on all platforms */\n        if (t.unref) {\n          t.unref()\n        }\n      }\n      return n\n    }\n\n    this.getRemainingTTL = key => {\n      const index = this.keyMap.get(key)\n      if (index === undefined) {\n        return 0\n      }\n      return this.ttls[index] === 0 || this.starts[index] === 0\n        ? Infinity\n        : this.starts[index] +\n            this.ttls[index] -\n            (cachedNow || getNow())\n    }\n\n    this.isStale = index => {\n      return (\n        this.ttls[index] !== 0 &&\n        this.starts[index] !== 0 &&\n        (cachedNow || getNow()) - this.starts[index] >\n          this.ttls[index]\n      )\n    }\n  }\n  updateItemAge(_index) {}\n  statusTTL(_status, _index) {}\n  setItemTTL(_index, _ttl, _start) {}\n  isStale(_index) {\n    return false\n  }\n\n  initializeSizeTracking() {\n    this.calculatedSize = 0\n    this.sizes = new ZeroArray(this.max)\n    this.removeItemSize = index => {\n      this.calculatedSize -= this.sizes[index]\n      this.sizes[index] = 0\n    }\n    this.requireSize = (k, v, size, sizeCalculation) => {\n      // provisionally accept background fetches.\n      // actual value size will be checked when they return.\n      if (this.isBackgroundFetch(v)) {\n        return 0\n      }\n      if (!isPosInt(size)) {\n        if (sizeCalculation) {\n          if (typeof sizeCalculation !== 'function') {\n            throw new TypeError('sizeCalculation must be a function')\n          }\n          size = sizeCalculation(v, k)\n          if (!isPosInt(size)) {\n            throw new TypeError(\n              'sizeCalculation return invalid (expect positive integer)'\n            )\n          }\n        } else {\n          throw new TypeError(\n            'invalid size value (must be positive integer). ' +\n              'When maxSize or maxEntrySize is used, sizeCalculation or size ' +\n              'must be set.'\n          )\n        }\n      }\n      return size\n    }\n    this.addItemSize = (index, size, status) => {\n      this.sizes[index] = size\n      if (this.maxSize) {\n        const maxSize = this.maxSize - this.sizes[index]\n        while (this.calculatedSize > maxSize) {\n          this.evict(true)\n        }\n      }\n      this.calculatedSize += this.sizes[index]\n      if (status) {\n        status.entrySize = size\n        status.totalCalculatedSize = this.calculatedSize\n      }\n    }\n  }\n  removeItemSize(_index) {}\n  addItemSize(_index, _size) {}\n  requireSize(_k, _v, size, sizeCalculation) {\n    if (size || sizeCalculation) {\n      throw new TypeError(\n        'cannot set size without setting maxSize or maxEntrySize on cache'\n      )\n    }\n  }\n\n  *indexes({ allowStale = this.allowStale } = {}) {\n    if (this.size) {\n      for (let i = this.tail; true; ) {\n        if (!this.isValidIndex(i)) {\n          break\n        }\n        if (allowStale || !this.isStale(i)) {\n          yield i\n        }\n        if (i === this.head) {\n          break\n        } else {\n          i = this.prev[i]\n        }\n      }\n    }\n  }\n\n  *rindexes({ allowStale = this.allowStale } = {}) {\n    if (this.size) {\n      for (let i = this.head; true; ) {\n        if (!this.isValidIndex(i)) {\n          break\n        }\n        if (allowStale || !this.isStale(i)) {\n          yield i\n        }\n        if (i === this.tail) {\n          break\n        } else {\n          i = this.next[i]\n        }\n      }\n    }\n  }\n\n  isValidIndex(index) {\n    return (\n      index !== undefined &&\n      this.keyMap.get(this.keyList[index]) === index\n    )\n  }\n\n  *entries() {\n    for (const i of this.indexes()) {\n      if (\n        this.valList[i] !== undefined &&\n        this.keyList[i] !== undefined &&\n        !this.isBackgroundFetch(this.valList[i])\n      ) {\n        yield [this.keyList[i], this.valList[i]]\n      }\n    }\n  }\n  *rentries() {\n    for (const i of this.rindexes()) {\n      if (\n        this.valList[i] !== undefined &&\n        this.keyList[i] !== undefined &&\n        !this.isBackgroundFetch(this.valList[i])\n      ) {\n        yield [this.keyList[i], this.valList[i]]\n      }\n    }\n  }\n\n  *keys() {\n    for (const i of this.indexes()) {\n      if (\n        this.keyList[i] !== undefined &&\n        !this.isBackgroundFetch(this.valList[i])\n      ) {\n        yield this.keyList[i]\n      }\n    }\n  }\n  *rkeys() {\n    for (const i of this.rindexes()) {\n      if (\n        this.keyList[i] !== undefined &&\n        !this.isBackgroundFetch(this.valList[i])\n      ) {\n        yield this.keyList[i]\n      }\n    }\n  }\n\n  *values() {\n    for (const i of this.indexes()) {\n      if (\n        this.valList[i] !== undefined &&\n        !this.isBackgroundFetch(this.valList[i])\n      ) {\n        yield this.valList[i]\n      }\n    }\n  }\n  *rvalues() {\n    for (const i of this.rindexes()) {\n      if (\n        this.valList[i] !== undefined &&\n        !this.isBackgroundFetch(this.valList[i])\n      ) {\n        yield this.valList[i]\n      }\n    }\n  }\n\n  [Symbol.iterator]() {\n    return this.entries()\n  }\n\n  find(fn, getOptions) {\n    for (const i of this.indexes()) {\n      const v = this.valList[i]\n      const value = this.isBackgroundFetch(v)\n        ? v.__staleWhileFetching\n        : v\n      if (value === undefined) continue\n      if (fn(value, this.keyList[i], this)) {\n        return this.get(this.keyList[i], getOptions)\n      }\n    }\n  }\n\n  forEach(fn, thisp = this) {\n    for (const i of this.indexes()) {\n      const v = this.valList[i]\n      const value = this.isBackgroundFetch(v)\n        ? v.__staleWhileFetching\n        : v\n      if (value === undefined) continue\n      fn.call(thisp, value, this.keyList[i], this)\n    }\n  }\n\n  rforEach(fn, thisp = this) {\n    for (const i of this.rindexes()) {\n      const v = this.valList[i]\n      const value = this.isBackgroundFetch(v)\n        ? v.__staleWhileFetching\n        : v\n      if (value === undefined) continue\n      fn.call(thisp, value, this.keyList[i], this)\n    }\n  }\n\n  get prune() {\n    deprecatedMethod('prune', 'purgeStale')\n    return this.purgeStale\n  }\n\n  purgeStale() {\n    let deleted = false\n    for (const i of this.rindexes({ allowStale: true })) {\n      if (this.isStale(i)) {\n        this.delete(this.keyList[i])\n        deleted = true\n      }\n    }\n    return deleted\n  }\n\n  dump() {\n    const arr = []\n    for (const i of this.indexes({ allowStale: true })) {\n      const key = this.keyList[i]\n      const v = this.valList[i]\n      const value = this.isBackgroundFetch(v)\n        ? v.__staleWhileFetching\n        : v\n      if (value === undefined) continue\n      const entry = { value }\n      if (this.ttls) {\n        entry.ttl = this.ttls[i]\n        // always dump the start relative to a portable timestamp\n        // it's ok for this to be a bit slow, it's a rare operation.\n        const age = perf.now() - this.starts[i]\n        entry.start = Math.floor(Date.now() - age)\n      }\n      if (this.sizes) {\n        entry.size = this.sizes[i]\n      }\n      arr.unshift([key, entry])\n    }\n    return arr\n  }\n\n  load(arr) {\n    this.clear()\n    for (const [key, entry] of arr) {\n      if (entry.start) {\n        // entry.start is a portable timestamp, but we may be using\n        // node's performance.now(), so calculate the offset.\n        // it's ok for this to be a bit slow, it's a rare operation.\n        const age = Date.now() - entry.start\n        entry.start = perf.now() - age\n      }\n      this.set(key, entry.value, entry)\n    }\n  }\n\n  dispose(_v, _k, _reason) {}\n\n  set(\n    k,\n    v,\n    {\n      ttl = this.ttl,\n      start,\n      noDisposeOnSet = this.noDisposeOnSet,\n      size = 0,\n      sizeCalculation = this.sizeCalculation,\n      noUpdateTTL = this.noUpdateTTL,\n      status,\n    } = {}\n  ) {\n    size = this.requireSize(k, v, size, sizeCalculation)\n    // if the item doesn't fit, don't do anything\n    // NB: maxEntrySize set to maxSize by default\n    if (this.maxEntrySize && size > this.maxEntrySize) {\n      if (status) {\n        status.set = 'miss'\n        status.maxEntrySizeExceeded = true\n      }\n      // have to delete, in case a background fetch is there already.\n      // in non-async cases, this is a no-op\n      this.delete(k)\n      return this\n    }\n    let index = this.size === 0 ? undefined : this.keyMap.get(k)\n    if (index === undefined) {\n      // addition\n      index = this.newIndex()\n      this.keyList[index] = k\n      this.valList[index] = v\n      this.keyMap.set(k, index)\n      this.next[this.tail] = index\n      this.prev[index] = this.tail\n      this.tail = index\n      this.size++\n      this.addItemSize(index, size, status)\n      if (status) {\n        status.set = 'add'\n      }\n      noUpdateTTL = false\n    } else {\n      // update\n      this.moveToTail(index)\n      const oldVal = this.valList[index]\n      if (v !== oldVal) {\n        if (this.isBackgroundFetch(oldVal)) {\n          oldVal.__abortController.abort(new Error('replaced'))\n        } else {\n          if (!noDisposeOnSet) {\n            this.dispose(oldVal, k, 'set')\n            if (this.disposeAfter) {\n              this.disposed.push([oldVal, k, 'set'])\n            }\n          }\n        }\n        this.removeItemSize(index)\n        this.valList[index] = v\n        this.addItemSize(index, size, status)\n        if (status) {\n          status.set = 'replace'\n          const oldValue =\n            oldVal && this.isBackgroundFetch(oldVal)\n              ? oldVal.__staleWhileFetching\n              : oldVal\n          if (oldValue !== undefined) status.oldValue = oldValue\n        }\n      } else if (status) {\n        status.set = 'update'\n      }\n    }\n    if (ttl !== 0 && this.ttl === 0 && !this.ttls) {\n      this.initializeTTLTracking()\n    }\n    if (!noUpdateTTL) {\n      this.setItemTTL(index, ttl, start)\n    }\n    this.statusTTL(status, index)\n    if (this.disposeAfter) {\n      while (this.disposed.length) {\n        this.disposeAfter(...this.disposed.shift())\n      }\n    }\n    return this\n  }\n\n  newIndex() {\n    if (this.size === 0) {\n      return this.tail\n    }\n    if (this.size === this.max && this.max !== 0) {\n      return this.evict(false)\n    }\n    if (this.free.length !== 0) {\n      return this.free.pop()\n    }\n    // initial fill, just keep writing down the list\n    return this.initialFill++\n  }\n\n  pop() {\n    if (this.size) {\n      const val = this.valList[this.head]\n      this.evict(true)\n      return val\n    }\n  }\n\n  evict(free) {\n    const head = this.head\n    const k = this.keyList[head]\n    const v = this.valList[head]\n    if (this.isBackgroundFetch(v)) {\n      v.__abortController.abort(new Error('evicted'))\n    } else {\n      this.dispose(v, k, 'evict')\n      if (this.disposeAfter) {\n        this.disposed.push([v, k, 'evict'])\n      }\n    }\n    this.removeItemSize(head)\n    // if we aren't about to use the index, then null these out\n    if (free) {\n      this.keyList[head] = null\n      this.valList[head] = null\n      this.free.push(head)\n    }\n    this.head = this.next[head]\n    this.keyMap.delete(k)\n    this.size--\n    return head\n  }\n\n  has(k, { updateAgeOnHas = this.updateAgeOnHas, status } = {}) {\n    const index = this.keyMap.get(k)\n    if (index !== undefined) {\n      if (!this.isStale(index)) {\n        if (updateAgeOnHas) {\n          this.updateItemAge(index)\n        }\n        if (status) status.has = 'hit'\n        this.statusTTL(status, index)\n        return true\n      } else if (status) {\n        status.has = 'stale'\n        this.statusTTL(status, index)\n      }\n    } else if (status) {\n      status.has = 'miss'\n    }\n    return false\n  }\n\n  // like get(), but without any LRU updating or TTL expiration\n  peek(k, { allowStale = this.allowStale } = {}) {\n    const index = this.keyMap.get(k)\n    if (index !== undefined && (allowStale || !this.isStale(index))) {\n      const v = this.valList[index]\n      // either stale and allowed, or forcing a refresh of non-stale value\n      return this.isBackgroundFetch(v) ? v.__staleWhileFetching : v\n    }\n  }\n\n  backgroundFetch(k, index, options, context) {\n    const v = index === undefined ? undefined : this.valList[index]\n    if (this.isBackgroundFetch(v)) {\n      return v\n    }\n    const ac = new AC()\n    if (options.signal) {\n      options.signal.addEventListener('abort', () =>\n        ac.abort(options.signal.reason)\n      )\n    }\n    const fetchOpts = {\n      signal: ac.signal,\n      options,\n      context,\n    }\n    const cb = (v, updateCache = false) => {\n      const { aborted } = ac.signal\n      const ignoreAbort = options.ignoreFetchAbort && v !== undefined\n      if (options.status) {\n        if (aborted && !updateCache) {\n          options.status.fetchAborted = true\n          options.status.fetchError = ac.signal.reason\n          if (ignoreAbort) options.status.fetchAbortIgnored = true\n        } else {\n          options.status.fetchResolved = true\n        }\n      }\n      if (aborted && !ignoreAbort && !updateCache) {\n        return fetchFail(ac.signal.reason)\n      }\n      // either we didn't abort, and are still here, or we did, and ignored\n      if (this.valList[index] === p) {\n        if (v === undefined) {\n          if (p.__staleWhileFetching) {\n            this.valList[index] = p.__staleWhileFetching\n          } else {\n            this.delete(k)\n          }\n        } else {\n          if (options.status) options.status.fetchUpdated = true\n          this.set(k, v, fetchOpts.options)\n        }\n      }\n      return v\n    }\n    const eb = er => {\n      if (options.status) {\n        options.status.fetchRejected = true\n        options.status.fetchError = er\n      }\n      return fetchFail(er)\n    }\n    const fetchFail = er => {\n      const { aborted } = ac.signal\n      const allowStaleAborted =\n        aborted && options.allowStaleOnFetchAbort\n      const allowStale =\n        allowStaleAborted || options.allowStaleOnFetchRejection\n      const noDelete = allowStale || options.noDeleteOnFetchRejection\n      if (this.valList[index] === p) {\n        // if we allow stale on fetch rejections, then we need to ensure that\n        // the stale value is not removed from the cache when the fetch fails.\n        const del = !noDelete || p.__staleWhileFetching === undefined\n        if (del) {\n          this.delete(k)\n        } else if (!allowStaleAborted) {\n          // still replace the *promise* with the stale value,\n          // since we are done with the promise at this point.\n          // leave it untouched if we're still waiting for an\n          // aborted background fetch that hasn't yet returned.\n          this.valList[index] = p.__staleWhileFetching\n        }\n      }\n      if (allowStale) {\n        if (options.status && p.__staleWhileFetching !== undefined) {\n          options.status.returnedStale = true\n        }\n        return p.__staleWhileFetching\n      } else if (p.__returned === p) {\n        throw er\n      }\n    }\n    const pcall = (res, rej) => {\n      this.fetchMethod(k, v, fetchOpts).then(v => res(v), rej)\n      // ignored, we go until we finish, regardless.\n      // defer check until we are actually aborting,\n      // so fetchMethod can override.\n      ac.signal.addEventListener('abort', () => {\n        if (\n          !options.ignoreFetchAbort ||\n          options.allowStaleOnFetchAbort\n        ) {\n          res()\n          // when it eventually resolves, update the cache.\n          if (options.allowStaleOnFetchAbort) {\n            res = v => cb(v, true)\n          }\n        }\n      })\n    }\n    if (options.status) options.status.fetchDispatched = true\n    const p = new Promise(pcall).then(cb, eb)\n    p.__abortController = ac\n    p.__staleWhileFetching = v\n    p.__returned = null\n    if (index === undefined) {\n      // internal, don't expose status.\n      this.set(k, p, { ...fetchOpts.options, status: undefined })\n      index = this.keyMap.get(k)\n    } else {\n      this.valList[index] = p\n    }\n    return p\n  }\n\n  isBackgroundFetch(p) {\n    return (\n      p &&\n      typeof p === 'object' &&\n      typeof p.then === 'function' &&\n      Object.prototype.hasOwnProperty.call(\n        p,\n        '__staleWhileFetching'\n      ) &&\n      Object.prototype.hasOwnProperty.call(p, '__returned') &&\n      (p.__returned === p || p.__returned === null)\n    )\n  }\n\n  // this takes the union of get() and set() opts, because it does both\n  async fetch(\n    k,\n    {\n      // get options\n      allowStale = this.allowStale,\n      updateAgeOnGet = this.updateAgeOnGet,\n      noDeleteOnStaleGet = this.noDeleteOnStaleGet,\n      // set options\n      ttl = this.ttl,\n      noDisposeOnSet = this.noDisposeOnSet,\n      size = 0,\n      sizeCalculation = this.sizeCalculation,\n      noUpdateTTL = this.noUpdateTTL,\n      // fetch exclusive options\n      noDeleteOnFetchRejection = this.noDeleteOnFetchRejection,\n      allowStaleOnFetchRejection = this.allowStaleOnFetchRejection,\n      ignoreFetchAbort = this.ignoreFetchAbort,\n      allowStaleOnFetchAbort = this.allowStaleOnFetchAbort,\n      fetchContext = this.fetchContext,\n      forceRefresh = false,\n      status,\n      signal,\n    } = {}\n  ) {\n    if (!this.fetchMethod) {\n      if (status) status.fetch = 'get'\n      return this.get(k, {\n        allowStale,\n        updateAgeOnGet,\n        noDeleteOnStaleGet,\n        status,\n      })\n    }\n\n    const options = {\n      allowStale,\n      updateAgeOnGet,\n      noDeleteOnStaleGet,\n      ttl,\n      noDisposeOnSet,\n      size,\n      sizeCalculation,\n      noUpdateTTL,\n      noDeleteOnFetchRejection,\n      allowStaleOnFetchRejection,\n      allowStaleOnFetchAbort,\n      ignoreFetchAbort,\n      status,\n      signal,\n    }\n\n    let index = this.keyMap.get(k)\n    if (index === undefined) {\n      if (status) status.fetch = 'miss'\n      const p = this.backgroundFetch(k, index, options, fetchContext)\n      return (p.__returned = p)\n    } else {\n      // in cache, maybe already fetching\n      const v = this.valList[index]\n      if (this.isBackgroundFetch(v)) {\n        const stale =\n          allowStale && v.__staleWhileFetching !== undefined\n        if (status) {\n          status.fetch = 'inflight'\n          if (stale) status.returnedStale = true\n        }\n        return stale ? v.__staleWhileFetching : (v.__returned = v)\n      }\n\n      // if we force a refresh, that means do NOT serve the cached value,\n      // unless we are already in the process of refreshing the cache.\n      const isStale = this.isStale(index)\n      if (!forceRefresh && !isStale) {\n        if (status) status.fetch = 'hit'\n        this.moveToTail(index)\n        if (updateAgeOnGet) {\n          this.updateItemAge(index)\n        }\n        this.statusTTL(status, index)\n        return v\n      }\n\n      // ok, it is stale or a forced refresh, and not already fetching.\n      // refresh the cache.\n      const p = this.backgroundFetch(k, index, options, fetchContext)\n      const hasStale = p.__staleWhileFetching !== undefined\n      const staleVal = hasStale && allowStale\n      if (status) {\n        status.fetch = hasStale && isStale ? 'stale' : 'refresh'\n        if (staleVal && isStale) status.returnedStale = true\n      }\n      return staleVal ? p.__staleWhileFetching : (p.__returned = p)\n    }\n  }\n\n  get(\n    k,\n    {\n      allowStale = this.allowStale,\n      updateAgeOnGet = this.updateAgeOnGet,\n      noDeleteOnStaleGet = this.noDeleteOnStaleGet,\n      status,\n    } = {}\n  ) {\n    const index = this.keyMap.get(k)\n    if (index !== undefined) {\n      const value = this.valList[index]\n      const fetching = this.isBackgroundFetch(value)\n      this.statusTTL(status, index)\n      if (this.isStale(index)) {\n        if (status) status.get = 'stale'\n        // delete only if not an in-flight background fetch\n        if (!fetching) {\n          if (!noDeleteOnStaleGet) {\n            this.delete(k)\n          }\n          if (status) status.returnedStale = allowStale\n          return allowStale ? value : undefined\n        } else {\n          if (status) {\n            status.returnedStale =\n              allowStale && value.__staleWhileFetching !== undefined\n          }\n          return allowStale ? value.__staleWhileFetching : undefined\n        }\n      } else {\n        if (status) status.get = 'hit'\n        // if we're currently fetching it, we don't actually have it yet\n        // it's not stale, which means this isn't a staleWhileRefetching.\n        // If it's not stale, and fetching, AND has a __staleWhileFetching\n        // value, then that means the user fetched with {forceRefresh:true},\n        // so it's safe to return that value.\n        if (fetching) {\n          return value.__staleWhileFetching\n        }\n        this.moveToTail(index)\n        if (updateAgeOnGet) {\n          this.updateItemAge(index)\n        }\n        return value\n      }\n    } else if (status) {\n      status.get = 'miss'\n    }\n  }\n\n  connect(p, n) {\n    this.prev[n] = p\n    this.next[p] = n\n  }\n\n  moveToTail(index) {\n    // if tail already, nothing to do\n    // if head, move head to next[index]\n    // else\n    //   move next[prev[index]] to next[index] (head has no prev)\n    //   move prev[next[index]] to prev[index]\n    // prev[index] = tail\n    // next[tail] = index\n    // tail = index\n    if (index !== this.tail) {\n      if (index === this.head) {\n        this.head = this.next[index]\n      } else {\n        this.connect(this.prev[index], this.next[index])\n      }\n      this.connect(this.tail, index)\n      this.tail = index\n    }\n  }\n\n  get del() {\n    deprecatedMethod('del', 'delete')\n    return this.delete\n  }\n\n  delete(k) {\n    let deleted = false\n    if (this.size !== 0) {\n      const index = this.keyMap.get(k)\n      if (index !== undefined) {\n        deleted = true\n        if (this.size === 1) {\n          this.clear()\n        } else {\n          this.removeItemSize(index)\n          const v = this.valList[index]\n          if (this.isBackgroundFetch(v)) {\n            v.__abortController.abort(new Error('deleted'))\n          } else {\n            this.dispose(v, k, 'delete')\n            if (this.disposeAfter) {\n              this.disposed.push([v, k, 'delete'])\n            }\n          }\n          this.keyMap.delete(k)\n          this.keyList[index] = null\n          this.valList[index] = null\n          if (index === this.tail) {\n            this.tail = this.prev[index]\n          } else if (index === this.head) {\n            this.head = this.next[index]\n          } else {\n            this.next[this.prev[index]] = this.next[index]\n            this.prev[this.next[index]] = this.prev[index]\n          }\n          this.size--\n          this.free.push(index)\n        }\n      }\n    }\n    if (this.disposed) {\n      while (this.disposed.length) {\n        this.disposeAfter(...this.disposed.shift())\n      }\n    }\n    return deleted\n  }\n\n  clear() {\n    for (const index of this.rindexes({ allowStale: true })) {\n      const v = this.valList[index]\n      if (this.isBackgroundFetch(v)) {\n        v.__abortController.abort(new Error('deleted'))\n      } else {\n        const k = this.keyList[index]\n        this.dispose(v, k, 'delete')\n        if (this.disposeAfter) {\n          this.disposed.push([v, k, 'delete'])\n        }\n      }\n    }\n\n    this.keyMap.clear()\n    this.valList.fill(null)\n    this.keyList.fill(null)\n    if (this.ttls) {\n      this.ttls.fill(0)\n      this.starts.fill(0)\n    }\n    if (this.sizes) {\n      this.sizes.fill(0)\n    }\n    this.head = 0\n    this.tail = 0\n    this.initialFill = 1\n    this.free.length = 0\n    this.calculatedSize = 0\n    this.size = 0\n    if (this.disposed) {\n      while (this.disposed.length) {\n        this.disposeAfter(...this.disposed.shift())\n      }\n    }\n  }\n\n  get reset() {\n    deprecatedMethod('reset', 'clear')\n    return this.clear\n  }\n\n  get length() {\n    deprecatedProperty('length', 'size')\n    return this.size\n  }\n\n  static get AbortController() {\n    return AC\n  }\n  static get AbortSignal() {\n    return AS\n  }\n}\n\nmodule.exports = LRUCache\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}