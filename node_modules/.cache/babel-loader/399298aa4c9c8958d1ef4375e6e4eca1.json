{"ast":null,"code":"const bl = require('bl');\nconst EventEmitter = require('events');\nconst Packet = require('./packet');\nconst constants = require('./constants');\nconst debug = require('debug')('mqtt-packet:parser');\nclass Parser extends EventEmitter {\n  constructor() {\n    super();\n    this.parser = this.constructor.parser;\n  }\n  static parser(opt) {\n    if (!(this instanceof Parser)) return new Parser().parser(opt);\n    this.settings = opt || {};\n    this._states = ['_parseHeader', '_parseLength', '_parsePayload', '_newPacket'];\n    this._resetState();\n    return this;\n  }\n  _resetState() {\n    debug('_resetState: resetting packet, error, _list, and _stateCounter');\n    this.packet = new Packet();\n    this.error = null;\n    this._list = bl();\n    this._stateCounter = 0;\n  }\n  parse(buf) {\n    if (this.error) this._resetState();\n    this._list.append(buf);\n    debug('parse: current state: %s', this._states[this._stateCounter]);\n    while ((this.packet.length !== -1 || this._list.length > 0) && this[this._states[this._stateCounter]]() && !this.error) {\n      this._stateCounter++;\n      debug('parse: state complete. _stateCounter is now: %d', this._stateCounter);\n      debug('parse: packet.length: %d, buffer list length: %d', this.packet.length, this._list.length);\n      if (this._stateCounter >= this._states.length) this._stateCounter = 0;\n    }\n    debug('parse: exited while loop. packet: %d, buffer list length: %d', this.packet.length, this._list.length);\n    return this._list.length;\n  }\n  _parseHeader() {\n    // There is at least one byte in the buffer\n    const zero = this._list.readUInt8(0);\n    const cmdIndex = zero >> constants.CMD_SHIFT;\n    this.packet.cmd = constants.types[cmdIndex];\n    const headerFlags = zero & 0xf;\n    const requiredHeaderFlags = constants.requiredHeaderFlags[cmdIndex];\n    if (requiredHeaderFlags != null && headerFlags !== requiredHeaderFlags) {\n      // Where a flag bit is marked as “Reserved” in Table 2.2 - Flag Bits, it is reserved for future use and MUST be set to the value listed in that table [MQTT-2.2.2-1]. If invalid flags are received, the receiver MUST close the Network Connection [MQTT-2.2.2-2]\n      return this._emitError(new Error(constants.requiredHeaderFlagsErrors[cmdIndex]));\n    }\n    this.packet.retain = (zero & constants.RETAIN_MASK) !== 0;\n    this.packet.qos = zero >> constants.QOS_SHIFT & constants.QOS_MASK;\n    if (this.packet.qos > 2) {\n      return this._emitError(new Error('Packet must not have both QoS bits set to 1'));\n    }\n    this.packet.dup = (zero & constants.DUP_MASK) !== 0;\n    debug('_parseHeader: packet: %o', this.packet);\n    this._list.consume(1);\n    return true;\n  }\n  _parseLength() {\n    // There is at least one byte in the list\n    const result = this._parseVarByteNum(true);\n    if (result) {\n      this.packet.length = result.value;\n      this._list.consume(result.bytes);\n    }\n    debug('_parseLength %d', result.value);\n    return !!result;\n  }\n  _parsePayload() {\n    debug('_parsePayload: payload %O', this._list);\n    let result = false;\n\n    // Do we have a payload? Do we have enough data to complete the payload?\n    // PINGs have no payload\n    if (this.packet.length === 0 || this._list.length >= this.packet.length) {\n      this._pos = 0;\n      switch (this.packet.cmd) {\n        case 'connect':\n          this._parseConnect();\n          break;\n        case 'connack':\n          this._parseConnack();\n          break;\n        case 'publish':\n          this._parsePublish();\n          break;\n        case 'puback':\n        case 'pubrec':\n        case 'pubrel':\n        case 'pubcomp':\n          this._parseConfirmation();\n          break;\n        case 'subscribe':\n          this._parseSubscribe();\n          break;\n        case 'suback':\n          this._parseSuback();\n          break;\n        case 'unsubscribe':\n          this._parseUnsubscribe();\n          break;\n        case 'unsuback':\n          this._parseUnsuback();\n          break;\n        case 'pingreq':\n        case 'pingresp':\n          // These are empty, nothing to do\n          break;\n        case 'disconnect':\n          this._parseDisconnect();\n          break;\n        case 'auth':\n          this._parseAuth();\n          break;\n        default:\n          this._emitError(new Error('Not supported'));\n      }\n      result = true;\n    }\n    debug('_parsePayload complete result: %s', result);\n    return result;\n  }\n  _parseConnect() {\n    debug('_parseConnect');\n    let topic; // Will topic\n    let payload; // Will payload\n    let password; // Password\n    let username; // Username\n    const flags = {};\n    const packet = this.packet;\n\n    // Parse protocolId\n    const protocolId = this._parseString();\n    if (protocolId === null) return this._emitError(new Error('Cannot parse protocolId'));\n    if (protocolId !== 'MQTT' && protocolId !== 'MQIsdp') {\n      return this._emitError(new Error('Invalid protocolId'));\n    }\n    packet.protocolId = protocolId;\n\n    // Parse constants version number\n    if (this._pos >= this._list.length) return this._emitError(new Error('Packet too short'));\n    packet.protocolVersion = this._list.readUInt8(this._pos);\n    if (packet.protocolVersion >= 128) {\n      packet.bridgeMode = true;\n      packet.protocolVersion = packet.protocolVersion - 128;\n    }\n    if (packet.protocolVersion !== 3 && packet.protocolVersion !== 4 && packet.protocolVersion !== 5) {\n      return this._emitError(new Error('Invalid protocol version'));\n    }\n    this._pos++;\n    if (this._pos >= this._list.length) {\n      return this._emitError(new Error('Packet too short'));\n    }\n    if (this._list.readUInt8(this._pos) & 0x1) {\n      // The Server MUST validate that the reserved flag in the CONNECT Control Packet is set to zero and disconnect the Client if it is not zero [MQTT-3.1.2-3]\n      return this._emitError(new Error('Connect flag bit 0 must be 0, but got 1'));\n    }\n    // Parse connect flags\n    flags.username = this._list.readUInt8(this._pos) & constants.USERNAME_MASK;\n    flags.password = this._list.readUInt8(this._pos) & constants.PASSWORD_MASK;\n    flags.will = this._list.readUInt8(this._pos) & constants.WILL_FLAG_MASK;\n    const willRetain = !!(this._list.readUInt8(this._pos) & constants.WILL_RETAIN_MASK);\n    const willQos = (this._list.readUInt8(this._pos) & constants.WILL_QOS_MASK) >> constants.WILL_QOS_SHIFT;\n    if (flags.will) {\n      packet.will = {};\n      packet.will.retain = willRetain;\n      packet.will.qos = willQos;\n    } else {\n      if (willRetain) {\n        return this._emitError(new Error('Will Retain Flag must be set to zero when Will Flag is set to 0'));\n      }\n      if (willQos) {\n        return this._emitError(new Error('Will QoS must be set to zero when Will Flag is set to 0'));\n      }\n    }\n    packet.clean = (this._list.readUInt8(this._pos) & constants.CLEAN_SESSION_MASK) !== 0;\n    this._pos++;\n\n    // Parse keepalive\n    packet.keepalive = this._parseNum();\n    if (packet.keepalive === -1) return this._emitError(new Error('Packet too short'));\n\n    // parse properties\n    if (packet.protocolVersion === 5) {\n      const properties = this._parseProperties();\n      if (Object.getOwnPropertyNames(properties).length) {\n        packet.properties = properties;\n      }\n    }\n    // Parse clientId\n    const clientId = this._parseString();\n    if (clientId === null) return this._emitError(new Error('Packet too short'));\n    packet.clientId = clientId;\n    debug('_parseConnect: packet.clientId: %s', packet.clientId);\n    if (flags.will) {\n      if (packet.protocolVersion === 5) {\n        const willProperties = this._parseProperties();\n        if (Object.getOwnPropertyNames(willProperties).length) {\n          packet.will.properties = willProperties;\n        }\n      }\n      // Parse will topic\n      topic = this._parseString();\n      if (topic === null) return this._emitError(new Error('Cannot parse will topic'));\n      packet.will.topic = topic;\n      debug('_parseConnect: packet.will.topic: %s', packet.will.topic);\n\n      // Parse will payload\n      payload = this._parseBuffer();\n      if (payload === null) return this._emitError(new Error('Cannot parse will payload'));\n      packet.will.payload = payload;\n      debug('_parseConnect: packet.will.paylaod: %s', packet.will.payload);\n    }\n\n    // Parse username\n    if (flags.username) {\n      username = this._parseString();\n      if (username === null) return this._emitError(new Error('Cannot parse username'));\n      packet.username = username;\n      debug('_parseConnect: packet.username: %s', packet.username);\n    }\n\n    // Parse password\n    if (flags.password) {\n      password = this._parseBuffer();\n      if (password === null) return this._emitError(new Error('Cannot parse password'));\n      packet.password = password;\n    }\n    // need for right parse auth packet and self set up\n    this.settings = packet;\n    debug('_parseConnect: complete');\n    return packet;\n  }\n  _parseConnack() {\n    debug('_parseConnack');\n    const packet = this.packet;\n    if (this._list.length < 1) return null;\n    const flags = this._list.readUInt8(this._pos++);\n    if (flags > 1) {\n      return this._emitError(new Error('Invalid connack flags, bits 7-1 must be set to 0'));\n    }\n    packet.sessionPresent = !!(flags & constants.SESSIONPRESENT_MASK);\n    if (this.settings.protocolVersion === 5) {\n      if (this._list.length >= 2) {\n        packet.reasonCode = this._list.readUInt8(this._pos++);\n      } else {\n        packet.reasonCode = 0;\n      }\n    } else {\n      if (this._list.length < 2) return null;\n      packet.returnCode = this._list.readUInt8(this._pos++);\n    }\n    if (packet.returnCode === -1 || packet.reasonCode === -1) return this._emitError(new Error('Cannot parse return code'));\n    // mqtt 5 properties\n    if (this.settings.protocolVersion === 5) {\n      const properties = this._parseProperties();\n      if (Object.getOwnPropertyNames(properties).length) {\n        packet.properties = properties;\n      }\n    }\n    debug('_parseConnack: complete');\n  }\n  _parsePublish() {\n    debug('_parsePublish');\n    const packet = this.packet;\n    packet.topic = this._parseString();\n    if (packet.topic === null) return this._emitError(new Error('Cannot parse topic'));\n\n    // Parse messageId\n    if (packet.qos > 0) if (!this._parseMessageId()) {\n      return;\n    }\n\n    // Properties mqtt 5\n    if (this.settings.protocolVersion === 5) {\n      const properties = this._parseProperties();\n      if (Object.getOwnPropertyNames(properties).length) {\n        packet.properties = properties;\n      }\n    }\n    packet.payload = this._list.slice(this._pos, packet.length);\n    debug('_parsePublish: payload from buffer list: %o', packet.payload);\n  }\n  _parseSubscribe() {\n    debug('_parseSubscribe');\n    const packet = this.packet;\n    let topic;\n    let options;\n    let qos;\n    let rh;\n    let rap;\n    let nl;\n    let subscription;\n    packet.subscriptions = [];\n    if (!this._parseMessageId()) {\n      return;\n    }\n\n    // Properties mqtt 5\n    if (this.settings.protocolVersion === 5) {\n      const properties = this._parseProperties();\n      if (Object.getOwnPropertyNames(properties).length) {\n        packet.properties = properties;\n      }\n    }\n    if (packet.length <= 0) {\n      return this._emitError(new Error('Malformed subscribe, no payload specified'));\n    }\n    while (this._pos < packet.length) {\n      // Parse topic\n      topic = this._parseString();\n      if (topic === null) return this._emitError(new Error('Cannot parse topic'));\n      if (this._pos >= packet.length) return this._emitError(new Error('Malformed Subscribe Payload'));\n      options = this._parseByte();\n      if (this.settings.protocolVersion === 5) {\n        if (options & 0xc0) {\n          return this._emitError(new Error('Invalid subscribe topic flag bits, bits 7-6 must be 0'));\n        }\n      } else {\n        if (options & 0xfc) {\n          return this._emitError(new Error('Invalid subscribe topic flag bits, bits 7-2 must be 0'));\n        }\n      }\n      qos = options & constants.SUBSCRIBE_OPTIONS_QOS_MASK;\n      if (qos > 2) {\n        return this._emitError(new Error('Invalid subscribe QoS, must be <= 2'));\n      }\n      nl = (options >> constants.SUBSCRIBE_OPTIONS_NL_SHIFT & constants.SUBSCRIBE_OPTIONS_NL_MASK) !== 0;\n      rap = (options >> constants.SUBSCRIBE_OPTIONS_RAP_SHIFT & constants.SUBSCRIBE_OPTIONS_RAP_MASK) !== 0;\n      rh = options >> constants.SUBSCRIBE_OPTIONS_RH_SHIFT & constants.SUBSCRIBE_OPTIONS_RH_MASK;\n      if (rh > 2) {\n        return this._emitError(new Error('Invalid retain handling, must be <= 2'));\n      }\n      subscription = {\n        topic,\n        qos\n      };\n\n      // mqtt 5 options\n      if (this.settings.protocolVersion === 5) {\n        subscription.nl = nl;\n        subscription.rap = rap;\n        subscription.rh = rh;\n      } else if (this.settings.bridgeMode) {\n        subscription.rh = 0;\n        subscription.rap = true;\n        subscription.nl = true;\n      }\n\n      // Push pair to subscriptions\n      debug('_parseSubscribe: push subscription `%s` to subscription', subscription);\n      packet.subscriptions.push(subscription);\n    }\n  }\n  _parseSuback() {\n    debug('_parseSuback');\n    const packet = this.packet;\n    this.packet.granted = [];\n    if (!this._parseMessageId()) {\n      return;\n    }\n\n    // Properties mqtt 5\n    if (this.settings.protocolVersion === 5) {\n      const properties = this._parseProperties();\n      if (Object.getOwnPropertyNames(properties).length) {\n        packet.properties = properties;\n      }\n    }\n    if (packet.length <= 0) {\n      return this._emitError(new Error('Malformed suback, no payload specified'));\n    }\n\n    // Parse granted QoSes\n    while (this._pos < this.packet.length) {\n      const code = this._list.readUInt8(this._pos++);\n      if (this.settings.protocolVersion === 5) {\n        if (!constants.MQTT5_SUBACK_CODES[code]) {\n          return this._emitError(new Error('Invalid suback code'));\n        }\n      } else {\n        if (code > 2 && code !== 0x80) {\n          return this._emitError(new Error('Invalid suback QoS, must be 0, 1, 2 or 128'));\n        }\n      }\n      this.packet.granted.push(code);\n    }\n  }\n  _parseUnsubscribe() {\n    debug('_parseUnsubscribe');\n    const packet = this.packet;\n    packet.unsubscriptions = [];\n\n    // Parse messageId\n    if (!this._parseMessageId()) {\n      return;\n    }\n\n    // Properties mqtt 5\n    if (this.settings.protocolVersion === 5) {\n      const properties = this._parseProperties();\n      if (Object.getOwnPropertyNames(properties).length) {\n        packet.properties = properties;\n      }\n    }\n    if (packet.length <= 0) {\n      return this._emitError(new Error('Malformed unsubscribe, no payload specified'));\n    }\n    while (this._pos < packet.length) {\n      // Parse topic\n      const topic = this._parseString();\n      if (topic === null) return this._emitError(new Error('Cannot parse topic'));\n\n      // Push topic to unsubscriptions\n      debug('_parseUnsubscribe: push topic `%s` to unsubscriptions', topic);\n      packet.unsubscriptions.push(topic);\n    }\n  }\n  _parseUnsuback() {\n    debug('_parseUnsuback');\n    const packet = this.packet;\n    if (!this._parseMessageId()) return this._emitError(new Error('Cannot parse messageId'));\n    if ((this.settings.protocolVersion === 3 || this.settings.protocolVersion === 4) && packet.length !== 2) {\n      return this._emitError(new Error('Malformed unsuback, payload length must be 2'));\n    }\n    if (packet.length <= 0) {\n      return this._emitError(new Error('Malformed unsuback, no payload specified'));\n    }\n\n    // Properties mqtt 5\n    if (this.settings.protocolVersion === 5) {\n      const properties = this._parseProperties();\n      if (Object.getOwnPropertyNames(properties).length) {\n        packet.properties = properties;\n      }\n      // Parse granted QoSes\n      packet.granted = [];\n      while (this._pos < this.packet.length) {\n        const code = this._list.readUInt8(this._pos++);\n        if (!constants.MQTT5_UNSUBACK_CODES[code]) {\n          return this._emitError(new Error('Invalid unsuback code'));\n        }\n        this.packet.granted.push(code);\n      }\n    }\n  }\n\n  // parse packets like puback, pubrec, pubrel, pubcomp\n  _parseConfirmation() {\n    debug('_parseConfirmation: packet.cmd: `%s`', this.packet.cmd);\n    const packet = this.packet;\n    this._parseMessageId();\n    if (this.settings.protocolVersion === 5) {\n      if (packet.length > 2) {\n        // response code\n        packet.reasonCode = this._parseByte();\n        switch (this.packet.cmd) {\n          case 'puback':\n          case 'pubrec':\n            if (!constants.MQTT5_PUBACK_PUBREC_CODES[packet.reasonCode]) {\n              return this._emitError(new Error('Invalid ' + this.packet.cmd + ' reason code'));\n            }\n            break;\n          case 'pubrel':\n          case 'pubcomp':\n            if (!constants.MQTT5_PUBREL_PUBCOMP_CODES[packet.reasonCode]) {\n              return this._emitError(new Error('Invalid ' + this.packet.cmd + ' reason code'));\n            }\n            break;\n        }\n        debug('_parseConfirmation: packet.reasonCode `%d`', packet.reasonCode);\n      } else {\n        packet.reasonCode = 0;\n      }\n      if (packet.length > 3) {\n        // properies mqtt 5\n        const properties = this._parseProperties();\n        if (Object.getOwnPropertyNames(properties).length) {\n          packet.properties = properties;\n        }\n      }\n    }\n    return true;\n  }\n\n  // parse disconnect packet\n  _parseDisconnect() {\n    const packet = this.packet;\n    debug('_parseDisconnect');\n    if (this.settings.protocolVersion === 5) {\n      // response code\n      if (this._list.length > 0) {\n        packet.reasonCode = this._parseByte();\n        if (!constants.MQTT5_DISCONNECT_CODES[packet.reasonCode]) {\n          this._emitError(new Error('Invalid disconnect reason code'));\n        }\n      } else {\n        packet.reasonCode = 0;\n      }\n      // properies mqtt 5\n      const properties = this._parseProperties();\n      if (Object.getOwnPropertyNames(properties).length) {\n        packet.properties = properties;\n      }\n    }\n    debug('_parseDisconnect result: true');\n    return true;\n  }\n\n  // parse auth packet\n  _parseAuth() {\n    debug('_parseAuth');\n    const packet = this.packet;\n    if (this.settings.protocolVersion !== 5) {\n      return this._emitError(new Error('Not supported auth packet for this version MQTT'));\n    }\n\n    // response code\n    packet.reasonCode = this._parseByte();\n    if (!constants.MQTT5_AUTH_CODES[packet.reasonCode]) {\n      return this._emitError(new Error('Invalid auth reason code'));\n    }\n    // properies mqtt 5\n    const properties = this._parseProperties();\n    if (Object.getOwnPropertyNames(properties).length) {\n      packet.properties = properties;\n    }\n    debug('_parseAuth: result: true');\n    return true;\n  }\n  _parseMessageId() {\n    const packet = this.packet;\n    packet.messageId = this._parseNum();\n    if (packet.messageId === null) {\n      this._emitError(new Error('Cannot parse messageId'));\n      return false;\n    }\n    debug('_parseMessageId: packet.messageId %d', packet.messageId);\n    return true;\n  }\n  _parseString(maybeBuffer) {\n    const length = this._parseNum();\n    const end = length + this._pos;\n    if (length === -1 || end > this._list.length || end > this.packet.length) return null;\n    const result = this._list.toString('utf8', this._pos, end);\n    this._pos += length;\n    debug('_parseString: result: %s', result);\n    return result;\n  }\n  _parseStringPair() {\n    debug('_parseStringPair');\n    return {\n      name: this._parseString(),\n      value: this._parseString()\n    };\n  }\n  _parseBuffer() {\n    const length = this._parseNum();\n    const end = length + this._pos;\n    if (length === -1 || end > this._list.length || end > this.packet.length) return null;\n    const result = this._list.slice(this._pos, end);\n    this._pos += length;\n    debug('_parseBuffer: result: %o', result);\n    return result;\n  }\n  _parseNum() {\n    if (this._list.length - this._pos < 2) return -1;\n    const result = this._list.readUInt16BE(this._pos);\n    this._pos += 2;\n    debug('_parseNum: result: %s', result);\n    return result;\n  }\n  _parse4ByteNum() {\n    if (this._list.length - this._pos < 4) return -1;\n    const result = this._list.readUInt32BE(this._pos);\n    this._pos += 4;\n    debug('_parse4ByteNum: result: %s', result);\n    return result;\n  }\n  _parseVarByteNum(fullInfoFlag) {\n    debug('_parseVarByteNum');\n    const maxBytes = 4;\n    let bytes = 0;\n    let mul = 1;\n    let value = 0;\n    let result = false;\n    let current;\n    const padding = this._pos ? this._pos : 0;\n    while (bytes < maxBytes && padding + bytes < this._list.length) {\n      current = this._list.readUInt8(padding + bytes++);\n      value += mul * (current & constants.VARBYTEINT_MASK);\n      mul *= 0x80;\n      if ((current & constants.VARBYTEINT_FIN_MASK) === 0) {\n        result = true;\n        break;\n      }\n      if (this._list.length <= bytes) {\n        break;\n      }\n    }\n    if (!result && bytes === maxBytes && this._list.length >= bytes) {\n      this._emitError(new Error('Invalid variable byte integer'));\n    }\n    if (padding) {\n      this._pos += bytes;\n    }\n    if (result) {\n      if (fullInfoFlag) {\n        result = {\n          bytes,\n          value\n        };\n      } else {\n        result = value;\n      }\n    } else {\n      result = false;\n    }\n    debug('_parseVarByteNum: result: %o', result);\n    return result;\n  }\n  _parseByte() {\n    let result;\n    if (this._pos < this._list.length) {\n      result = this._list.readUInt8(this._pos);\n      this._pos++;\n    }\n    debug('_parseByte: result: %o', result);\n    return result;\n  }\n  _parseByType(type) {\n    debug('_parseByType: type: %s', type);\n    switch (type) {\n      case 'byte':\n        {\n          return this._parseByte() !== 0;\n        }\n      case 'int8':\n        {\n          return this._parseByte();\n        }\n      case 'int16':\n        {\n          return this._parseNum();\n        }\n      case 'int32':\n        {\n          return this._parse4ByteNum();\n        }\n      case 'var':\n        {\n          return this._parseVarByteNum();\n        }\n      case 'string':\n        {\n          return this._parseString();\n        }\n      case 'pair':\n        {\n          return this._parseStringPair();\n        }\n      case 'binary':\n        {\n          return this._parseBuffer();\n        }\n    }\n  }\n  _parseProperties() {\n    debug('_parseProperties');\n    const length = this._parseVarByteNum();\n    const start = this._pos;\n    const end = start + length;\n    const result = {};\n    while (this._pos < end) {\n      const type = this._parseByte();\n      if (!type) {\n        this._emitError(new Error('Cannot parse property code type'));\n        return false;\n      }\n      const name = constants.propertiesCodes[type];\n      if (!name) {\n        this._emitError(new Error('Unknown property'));\n        return false;\n      }\n      // user properties process\n      if (name === 'userProperties') {\n        if (!result[name]) {\n          result[name] = Object.create(null);\n        }\n        const currentUserProperty = this._parseByType(constants.propertiesTypes[name]);\n        if (result[name][currentUserProperty.name]) {\n          if (Array.isArray(result[name][currentUserProperty.name])) {\n            result[name][currentUserProperty.name].push(currentUserProperty.value);\n          } else {\n            const currentValue = result[name][currentUserProperty.name];\n            result[name][currentUserProperty.name] = [currentValue];\n            result[name][currentUserProperty.name].push(currentUserProperty.value);\n          }\n        } else {\n          result[name][currentUserProperty.name] = currentUserProperty.value;\n        }\n        continue;\n      }\n      if (result[name]) {\n        if (Array.isArray(result[name])) {\n          result[name].push(this._parseByType(constants.propertiesTypes[name]));\n        } else {\n          result[name] = [result[name]];\n          result[name].push(this._parseByType(constants.propertiesTypes[name]));\n        }\n      } else {\n        result[name] = this._parseByType(constants.propertiesTypes[name]);\n      }\n    }\n    return result;\n  }\n  _newPacket() {\n    debug('_newPacket');\n    if (this.packet) {\n      this._list.consume(this.packet.length);\n      debug('_newPacket: parser emit packet: packet.cmd: %s, packet.payload: %s, packet.length: %d', this.packet.cmd, this.packet.payload, this.packet.length);\n      this.emit('packet', this.packet);\n    }\n    debug('_newPacket: new packet');\n    this.packet = new Packet();\n    this._pos = 0;\n    return true;\n  }\n  _emitError(err) {\n    debug('_emitError', err);\n    this.error = err;\n    this.emit('error', err);\n  }\n}\nmodule.exports = Parser;","map":{"version":3,"names":["bl","require","EventEmitter","Packet","constants","debug","Parser","constructor","parser","opt","settings","_states","_resetState","packet","error","_list","_stateCounter","parse","buf","append","length","_parseHeader","zero","readUInt8","cmdIndex","CMD_SHIFT","cmd","types","headerFlags","requiredHeaderFlags","_emitError","Error","requiredHeaderFlagsErrors","retain","RETAIN_MASK","qos","QOS_SHIFT","QOS_MASK","dup","DUP_MASK","consume","_parseLength","result","_parseVarByteNum","value","bytes","_parsePayload","_pos","_parseConnect","_parseConnack","_parsePublish","_parseConfirmation","_parseSubscribe","_parseSuback","_parseUnsubscribe","_parseUnsuback","_parseDisconnect","_parseAuth","topic","payload","password","username","flags","protocolId","_parseString","protocolVersion","bridgeMode","USERNAME_MASK","PASSWORD_MASK","will","WILL_FLAG_MASK","willRetain","WILL_RETAIN_MASK","willQos","WILL_QOS_MASK","WILL_QOS_SHIFT","clean","CLEAN_SESSION_MASK","keepalive","_parseNum","properties","_parseProperties","Object","getOwnPropertyNames","clientId","willProperties","_parseBuffer","sessionPresent","SESSIONPRESENT_MASK","reasonCode","returnCode","_parseMessageId","slice","options","rh","rap","nl","subscription","subscriptions","_parseByte","SUBSCRIBE_OPTIONS_QOS_MASK","SUBSCRIBE_OPTIONS_NL_SHIFT","SUBSCRIBE_OPTIONS_NL_MASK","SUBSCRIBE_OPTIONS_RAP_SHIFT","SUBSCRIBE_OPTIONS_RAP_MASK","SUBSCRIBE_OPTIONS_RH_SHIFT","SUBSCRIBE_OPTIONS_RH_MASK","push","granted","code","MQTT5_SUBACK_CODES","unsubscriptions","MQTT5_UNSUBACK_CODES","MQTT5_PUBACK_PUBREC_CODES","MQTT5_PUBREL_PUBCOMP_CODES","MQTT5_DISCONNECT_CODES","MQTT5_AUTH_CODES","messageId","maybeBuffer","end","toString","_parseStringPair","name","readUInt16BE","_parse4ByteNum","readUInt32BE","fullInfoFlag","maxBytes","mul","current","padding","VARBYTEINT_MASK","VARBYTEINT_FIN_MASK","_parseByType","type","start","propertiesCodes","create","currentUserProperty","propertiesTypes","Array","isArray","currentValue","_newPacket","emit","err","module","exports"],"sources":["/Users/jstanton/Coding/FieldDock/FieldDockMain/node_modules/mqtt-packet/parser.js"],"sourcesContent":["const bl = require('bl')\nconst EventEmitter = require('events')\nconst Packet = require('./packet')\nconst constants = require('./constants')\nconst debug = require('debug')('mqtt-packet:parser')\n\nclass Parser extends EventEmitter {\n  constructor () {\n    super()\n    this.parser = this.constructor.parser\n  }\n\n  static parser (opt) {\n    if (!(this instanceof Parser)) return (new Parser()).parser(opt)\n\n    this.settings = opt || {}\n\n    this._states = [\n      '_parseHeader',\n      '_parseLength',\n      '_parsePayload',\n      '_newPacket'\n    ]\n\n    this._resetState()\n    return this\n  }\n\n  _resetState () {\n    debug('_resetState: resetting packet, error, _list, and _stateCounter')\n    this.packet = new Packet()\n    this.error = null\n    this._list = bl()\n    this._stateCounter = 0\n  }\n\n  parse (buf) {\n    if (this.error) this._resetState()\n\n    this._list.append(buf)\n    debug('parse: current state: %s', this._states[this._stateCounter])\n    while ((this.packet.length !== -1 || this._list.length > 0) &&\n      this[this._states[this._stateCounter]]() &&\n      !this.error) {\n      this._stateCounter++\n      debug('parse: state complete. _stateCounter is now: %d', this._stateCounter)\n      debug('parse: packet.length: %d, buffer list length: %d', this.packet.length, this._list.length)\n      if (this._stateCounter >= this._states.length) this._stateCounter = 0\n    }\n    debug('parse: exited while loop. packet: %d, buffer list length: %d', this.packet.length, this._list.length)\n    return this._list.length\n  }\n\n  _parseHeader () {\n    // There is at least one byte in the buffer\n    const zero = this._list.readUInt8(0)\n    const cmdIndex = zero >> constants.CMD_SHIFT\n    this.packet.cmd = constants.types[cmdIndex]\n    const headerFlags = zero & 0xf\n    const requiredHeaderFlags = constants.requiredHeaderFlags[cmdIndex]\n    if (requiredHeaderFlags != null && headerFlags !== requiredHeaderFlags) {\n      // Where a flag bit is marked as “Reserved” in Table 2.2 - Flag Bits, it is reserved for future use and MUST be set to the value listed in that table [MQTT-2.2.2-1]. If invalid flags are received, the receiver MUST close the Network Connection [MQTT-2.2.2-2]\n      return this._emitError(new Error(constants.requiredHeaderFlagsErrors[cmdIndex]))\n    }\n    this.packet.retain = (zero & constants.RETAIN_MASK) !== 0\n    this.packet.qos = (zero >> constants.QOS_SHIFT) & constants.QOS_MASK\n    if (this.packet.qos > 2) {\n      return this._emitError(new Error('Packet must not have both QoS bits set to 1'))\n    }\n    this.packet.dup = (zero & constants.DUP_MASK) !== 0\n    debug('_parseHeader: packet: %o', this.packet)\n\n    this._list.consume(1)\n\n    return true\n  }\n\n  _parseLength () {\n    // There is at least one byte in the list\n    const result = this._parseVarByteNum(true)\n\n    if (result) {\n      this.packet.length = result.value\n      this._list.consume(result.bytes)\n    }\n    debug('_parseLength %d', result.value)\n    return !!result\n  }\n\n  _parsePayload () {\n    debug('_parsePayload: payload %O', this._list)\n    let result = false\n\n    // Do we have a payload? Do we have enough data to complete the payload?\n    // PINGs have no payload\n    if (this.packet.length === 0 || this._list.length >= this.packet.length) {\n      this._pos = 0\n\n      switch (this.packet.cmd) {\n        case 'connect':\n          this._parseConnect()\n          break\n        case 'connack':\n          this._parseConnack()\n          break\n        case 'publish':\n          this._parsePublish()\n          break\n        case 'puback':\n        case 'pubrec':\n        case 'pubrel':\n        case 'pubcomp':\n          this._parseConfirmation()\n          break\n        case 'subscribe':\n          this._parseSubscribe()\n          break\n        case 'suback':\n          this._parseSuback()\n          break\n        case 'unsubscribe':\n          this._parseUnsubscribe()\n          break\n        case 'unsuback':\n          this._parseUnsuback()\n          break\n        case 'pingreq':\n        case 'pingresp':\n          // These are empty, nothing to do\n          break\n        case 'disconnect':\n          this._parseDisconnect()\n          break\n        case 'auth':\n          this._parseAuth()\n          break\n        default:\n          this._emitError(new Error('Not supported'))\n      }\n\n      result = true\n    }\n    debug('_parsePayload complete result: %s', result)\n    return result\n  }\n\n  _parseConnect () {\n    debug('_parseConnect')\n    let topic // Will topic\n    let payload // Will payload\n    let password // Password\n    let username // Username\n    const flags = {}\n    const packet = this.packet\n\n    // Parse protocolId\n    const protocolId = this._parseString()\n\n    if (protocolId === null) return this._emitError(new Error('Cannot parse protocolId'))\n    if (protocolId !== 'MQTT' && protocolId !== 'MQIsdp') {\n      return this._emitError(new Error('Invalid protocolId'))\n    }\n\n    packet.protocolId = protocolId\n\n    // Parse constants version number\n    if (this._pos >= this._list.length) return this._emitError(new Error('Packet too short'))\n\n    packet.protocolVersion = this._list.readUInt8(this._pos)\n\n    if (packet.protocolVersion >= 128) {\n      packet.bridgeMode = true\n      packet.protocolVersion = packet.protocolVersion - 128\n    }\n\n    if (packet.protocolVersion !== 3 && packet.protocolVersion !== 4 && packet.protocolVersion !== 5) {\n      return this._emitError(new Error('Invalid protocol version'))\n    }\n\n    this._pos++\n\n    if (this._pos >= this._list.length) {\n      return this._emitError(new Error('Packet too short'))\n    }\n\n    if (this._list.readUInt8(this._pos) & 0x1) {\n      // The Server MUST validate that the reserved flag in the CONNECT Control Packet is set to zero and disconnect the Client if it is not zero [MQTT-3.1.2-3]\n      return this._emitError(new Error('Connect flag bit 0 must be 0, but got 1'))\n    }\n    // Parse connect flags\n    flags.username = (this._list.readUInt8(this._pos) & constants.USERNAME_MASK)\n    flags.password = (this._list.readUInt8(this._pos) & constants.PASSWORD_MASK)\n    flags.will = (this._list.readUInt8(this._pos) & constants.WILL_FLAG_MASK)\n\n    const willRetain = !!(this._list.readUInt8(this._pos) & constants.WILL_RETAIN_MASK)\n    const willQos = (this._list.readUInt8(this._pos) &\n        constants.WILL_QOS_MASK) >> constants.WILL_QOS_SHIFT\n\n    if (flags.will) {\n      packet.will = {}\n      packet.will.retain = willRetain\n      packet.will.qos = willQos\n    } else {\n      if (willRetain) {\n        return this._emitError(new Error('Will Retain Flag must be set to zero when Will Flag is set to 0'))\n      }\n      if (willQos) {\n        return this._emitError(new Error('Will QoS must be set to zero when Will Flag is set to 0'))\n      }\n    }\n\n    packet.clean = (this._list.readUInt8(this._pos) & constants.CLEAN_SESSION_MASK) !== 0\n    this._pos++\n\n    // Parse keepalive\n    packet.keepalive = this._parseNum()\n    if (packet.keepalive === -1) return this._emitError(new Error('Packet too short'))\n\n    // parse properties\n    if (packet.protocolVersion === 5) {\n      const properties = this._parseProperties()\n      if (Object.getOwnPropertyNames(properties).length) {\n        packet.properties = properties\n      }\n    }\n    // Parse clientId\n    const clientId = this._parseString()\n    if (clientId === null) return this._emitError(new Error('Packet too short'))\n    packet.clientId = clientId\n    debug('_parseConnect: packet.clientId: %s', packet.clientId)\n\n    if (flags.will) {\n      if (packet.protocolVersion === 5) {\n        const willProperties = this._parseProperties()\n        if (Object.getOwnPropertyNames(willProperties).length) {\n          packet.will.properties = willProperties\n        }\n      }\n      // Parse will topic\n      topic = this._parseString()\n      if (topic === null) return this._emitError(new Error('Cannot parse will topic'))\n      packet.will.topic = topic\n      debug('_parseConnect: packet.will.topic: %s', packet.will.topic)\n\n      // Parse will payload\n      payload = this._parseBuffer()\n      if (payload === null) return this._emitError(new Error('Cannot parse will payload'))\n      packet.will.payload = payload\n      debug('_parseConnect: packet.will.paylaod: %s', packet.will.payload)\n    }\n\n    // Parse username\n    if (flags.username) {\n      username = this._parseString()\n      if (username === null) return this._emitError(new Error('Cannot parse username'))\n      packet.username = username\n      debug('_parseConnect: packet.username: %s', packet.username)\n    }\n\n    // Parse password\n    if (flags.password) {\n      password = this._parseBuffer()\n      if (password === null) return this._emitError(new Error('Cannot parse password'))\n      packet.password = password\n    }\n    // need for right parse auth packet and self set up\n    this.settings = packet\n    debug('_parseConnect: complete')\n    return packet\n  }\n\n  _parseConnack () {\n    debug('_parseConnack')\n    const packet = this.packet\n\n    if (this._list.length < 1) return null\n    const flags = this._list.readUInt8(this._pos++)\n    if (flags > 1) {\n      return this._emitError(new Error('Invalid connack flags, bits 7-1 must be set to 0'))\n    }\n    packet.sessionPresent = !!(flags & constants.SESSIONPRESENT_MASK)\n\n    if (this.settings.protocolVersion === 5) {\n      if (this._list.length >= 2) {\n        packet.reasonCode = this._list.readUInt8(this._pos++)\n      } else {\n        packet.reasonCode = 0\n      }\n    } else {\n      if (this._list.length < 2) return null\n      packet.returnCode = this._list.readUInt8(this._pos++)\n    }\n\n    if (packet.returnCode === -1 || packet.reasonCode === -1) return this._emitError(new Error('Cannot parse return code'))\n    // mqtt 5 properties\n    if (this.settings.protocolVersion === 5) {\n      const properties = this._parseProperties()\n      if (Object.getOwnPropertyNames(properties).length) {\n        packet.properties = properties\n      }\n    }\n    debug('_parseConnack: complete')\n  }\n\n  _parsePublish () {\n    debug('_parsePublish')\n    const packet = this.packet\n    packet.topic = this._parseString()\n\n    if (packet.topic === null) return this._emitError(new Error('Cannot parse topic'))\n\n    // Parse messageId\n    if (packet.qos > 0) if (!this._parseMessageId()) { return }\n\n    // Properties mqtt 5\n    if (this.settings.protocolVersion === 5) {\n      const properties = this._parseProperties()\n      if (Object.getOwnPropertyNames(properties).length) {\n        packet.properties = properties\n      }\n    }\n\n    packet.payload = this._list.slice(this._pos, packet.length)\n    debug('_parsePublish: payload from buffer list: %o', packet.payload)\n  }\n\n  _parseSubscribe () {\n    debug('_parseSubscribe')\n    const packet = this.packet\n    let topic\n    let options\n    let qos\n    let rh\n    let rap\n    let nl\n    let subscription\n\n    packet.subscriptions = []\n\n    if (!this._parseMessageId()) { return }\n\n    // Properties mqtt 5\n    if (this.settings.protocolVersion === 5) {\n      const properties = this._parseProperties()\n      if (Object.getOwnPropertyNames(properties).length) {\n        packet.properties = properties\n      }\n    }\n\n    if (packet.length <= 0) { return this._emitError(new Error('Malformed subscribe, no payload specified')) }\n\n    while (this._pos < packet.length) {\n      // Parse topic\n      topic = this._parseString()\n      if (topic === null) return this._emitError(new Error('Cannot parse topic'))\n      if (this._pos >= packet.length) return this._emitError(new Error('Malformed Subscribe Payload'))\n\n      options = this._parseByte()\n\n      if (this.settings.protocolVersion === 5) {\n        if (options & 0xc0) {\n          return this._emitError(new Error('Invalid subscribe topic flag bits, bits 7-6 must be 0'))\n        }\n      } else {\n        if (options & 0xfc) {\n          return this._emitError(new Error('Invalid subscribe topic flag bits, bits 7-2 must be 0'))\n        }\n      }\n\n      qos = options & constants.SUBSCRIBE_OPTIONS_QOS_MASK\n      if (qos > 2) {\n        return this._emitError(new Error('Invalid subscribe QoS, must be <= 2'))\n      }\n      nl = ((options >> constants.SUBSCRIBE_OPTIONS_NL_SHIFT) & constants.SUBSCRIBE_OPTIONS_NL_MASK) !== 0\n      rap = ((options >> constants.SUBSCRIBE_OPTIONS_RAP_SHIFT) & constants.SUBSCRIBE_OPTIONS_RAP_MASK) !== 0\n      rh = (options >> constants.SUBSCRIBE_OPTIONS_RH_SHIFT) & constants.SUBSCRIBE_OPTIONS_RH_MASK\n\n      if (rh > 2) {\n        return this._emitError(new Error('Invalid retain handling, must be <= 2'))\n      }\n\n      subscription = { topic, qos }\n\n      // mqtt 5 options\n      if (this.settings.protocolVersion === 5) {\n        subscription.nl = nl\n        subscription.rap = rap\n        subscription.rh = rh\n      } else if (this.settings.bridgeMode) {\n        subscription.rh = 0\n        subscription.rap = true\n        subscription.nl = true\n      }\n\n      // Push pair to subscriptions\n      debug('_parseSubscribe: push subscription `%s` to subscription', subscription)\n      packet.subscriptions.push(subscription)\n    }\n  }\n\n  _parseSuback () {\n    debug('_parseSuback')\n    const packet = this.packet\n    this.packet.granted = []\n\n    if (!this._parseMessageId()) { return }\n\n    // Properties mqtt 5\n    if (this.settings.protocolVersion === 5) {\n      const properties = this._parseProperties()\n      if (Object.getOwnPropertyNames(properties).length) {\n        packet.properties = properties\n      }\n    }\n\n    if (packet.length <= 0) { return this._emitError(new Error('Malformed suback, no payload specified')) }\n\n    // Parse granted QoSes\n    while (this._pos < this.packet.length) {\n      const code = this._list.readUInt8(this._pos++)\n      if (this.settings.protocolVersion === 5) {\n        if (!constants.MQTT5_SUBACK_CODES[code]) {\n          return this._emitError(new Error('Invalid suback code'))\n        }\n      } else {\n        if (code > 2 && code !== 0x80) {\n          return this._emitError(new Error('Invalid suback QoS, must be 0, 1, 2 or 128'))\n        }\n      }\n      this.packet.granted.push(code)\n    }\n  }\n\n  _parseUnsubscribe () {\n    debug('_parseUnsubscribe')\n    const packet = this.packet\n\n    packet.unsubscriptions = []\n\n    // Parse messageId\n    if (!this._parseMessageId()) { return }\n\n    // Properties mqtt 5\n    if (this.settings.protocolVersion === 5) {\n      const properties = this._parseProperties()\n      if (Object.getOwnPropertyNames(properties).length) {\n        packet.properties = properties\n      }\n    }\n\n    if (packet.length <= 0) { return this._emitError(new Error('Malformed unsubscribe, no payload specified')) }\n\n    while (this._pos < packet.length) {\n      // Parse topic\n      const topic = this._parseString()\n      if (topic === null) return this._emitError(new Error('Cannot parse topic'))\n\n      // Push topic to unsubscriptions\n      debug('_parseUnsubscribe: push topic `%s` to unsubscriptions', topic)\n      packet.unsubscriptions.push(topic)\n    }\n  }\n\n  _parseUnsuback () {\n    debug('_parseUnsuback')\n    const packet = this.packet\n    if (!this._parseMessageId()) return this._emitError(new Error('Cannot parse messageId'))\n\n    if ((this.settings.protocolVersion === 3 ||\n      this.settings.protocolVersion === 4) && packet.length !== 2) {\n      return this._emitError(new Error('Malformed unsuback, payload length must be 2'))\n    }\n    if (packet.length <= 0) { return this._emitError(new Error('Malformed unsuback, no payload specified')) }\n\n    // Properties mqtt 5\n    if (this.settings.protocolVersion === 5) {\n      const properties = this._parseProperties()\n      if (Object.getOwnPropertyNames(properties).length) {\n        packet.properties = properties\n      }\n      // Parse granted QoSes\n      packet.granted = []\n\n      while (this._pos < this.packet.length) {\n        const code = this._list.readUInt8(this._pos++)\n        if (!constants.MQTT5_UNSUBACK_CODES[code]) {\n          return this._emitError(new Error('Invalid unsuback code'))\n        }\n        this.packet.granted.push(code)\n      }\n    }\n  }\n\n  // parse packets like puback, pubrec, pubrel, pubcomp\n  _parseConfirmation () {\n    debug('_parseConfirmation: packet.cmd: `%s`', this.packet.cmd)\n    const packet = this.packet\n\n    this._parseMessageId()\n\n    if (this.settings.protocolVersion === 5) {\n      if (packet.length > 2) {\n        // response code\n        packet.reasonCode = this._parseByte()\n        switch (this.packet.cmd) {\n          case 'puback':\n          case 'pubrec':\n            if (!constants.MQTT5_PUBACK_PUBREC_CODES[packet.reasonCode]) {\n              return this._emitError(new Error('Invalid ' + this.packet.cmd + ' reason code'))\n            }\n            break\n          case 'pubrel':\n          case 'pubcomp':\n            if (!constants.MQTT5_PUBREL_PUBCOMP_CODES[packet.reasonCode]) {\n              return this._emitError(new Error('Invalid ' + this.packet.cmd + ' reason code'))\n            }\n            break\n        }\n        debug('_parseConfirmation: packet.reasonCode `%d`', packet.reasonCode)\n      } else {\n        packet.reasonCode = 0\n      }\n\n      if (packet.length > 3) {\n        // properies mqtt 5\n        const properties = this._parseProperties()\n        if (Object.getOwnPropertyNames(properties).length) {\n          packet.properties = properties\n        }\n      }\n    }\n\n    return true\n  }\n\n  // parse disconnect packet\n  _parseDisconnect () {\n    const packet = this.packet\n    debug('_parseDisconnect')\n\n    if (this.settings.protocolVersion === 5) {\n      // response code\n      if (this._list.length > 0) {\n        packet.reasonCode = this._parseByte()\n        if (!constants.MQTT5_DISCONNECT_CODES[packet.reasonCode]) {\n          this._emitError(new Error('Invalid disconnect reason code'))\n        }\n      } else {\n        packet.reasonCode = 0\n      }\n      // properies mqtt 5\n      const properties = this._parseProperties()\n      if (Object.getOwnPropertyNames(properties).length) {\n        packet.properties = properties\n      }\n    }\n\n    debug('_parseDisconnect result: true')\n    return true\n  }\n\n  // parse auth packet\n  _parseAuth () {\n    debug('_parseAuth')\n    const packet = this.packet\n\n    if (this.settings.protocolVersion !== 5) {\n      return this._emitError(new Error('Not supported auth packet for this version MQTT'))\n    }\n\n    // response code\n    packet.reasonCode = this._parseByte()\n    if (!constants.MQTT5_AUTH_CODES[packet.reasonCode]) {\n      return this._emitError(new Error('Invalid auth reason code'))\n    }\n    // properies mqtt 5\n    const properties = this._parseProperties()\n    if (Object.getOwnPropertyNames(properties).length) {\n      packet.properties = properties\n    }\n\n    debug('_parseAuth: result: true')\n    return true\n  }\n\n  _parseMessageId () {\n    const packet = this.packet\n\n    packet.messageId = this._parseNum()\n\n    if (packet.messageId === null) {\n      this._emitError(new Error('Cannot parse messageId'))\n      return false\n    }\n\n    debug('_parseMessageId: packet.messageId %d', packet.messageId)\n    return true\n  }\n\n  _parseString (maybeBuffer) {\n    const length = this._parseNum()\n    const end = length + this._pos\n\n    if (length === -1 || end > this._list.length || end > this.packet.length) return null\n\n    const result = this._list.toString('utf8', this._pos, end)\n    this._pos += length\n    debug('_parseString: result: %s', result)\n    return result\n  }\n\n  _parseStringPair () {\n    debug('_parseStringPair')\n    return {\n      name: this._parseString(),\n      value: this._parseString()\n    }\n  }\n\n  _parseBuffer () {\n    const length = this._parseNum()\n    const end = length + this._pos\n\n    if (length === -1 || end > this._list.length || end > this.packet.length) return null\n\n    const result = this._list.slice(this._pos, end)\n\n    this._pos += length\n    debug('_parseBuffer: result: %o', result)\n    return result\n  }\n\n  _parseNum () {\n    if (this._list.length - this._pos < 2) return -1\n\n    const result = this._list.readUInt16BE(this._pos)\n    this._pos += 2\n    debug('_parseNum: result: %s', result)\n    return result\n  }\n\n  _parse4ByteNum () {\n    if (this._list.length - this._pos < 4) return -1\n\n    const result = this._list.readUInt32BE(this._pos)\n    this._pos += 4\n    debug('_parse4ByteNum: result: %s', result)\n    return result\n  }\n\n  _parseVarByteNum (fullInfoFlag) {\n    debug('_parseVarByteNum')\n    const maxBytes = 4\n    let bytes = 0\n    let mul = 1\n    let value = 0\n    let result = false\n    let current\n    const padding = this._pos ? this._pos : 0\n\n    while (bytes < maxBytes && (padding + bytes) < this._list.length) {\n      current = this._list.readUInt8(padding + bytes++)\n      value += mul * (current & constants.VARBYTEINT_MASK)\n      mul *= 0x80\n\n      if ((current & constants.VARBYTEINT_FIN_MASK) === 0) {\n        result = true\n        break\n      }\n      if (this._list.length <= bytes) {\n        break\n      }\n    }\n\n    if (!result && bytes === maxBytes && this._list.length >= bytes) {\n      this._emitError(new Error('Invalid variable byte integer'))\n    }\n\n    if (padding) {\n      this._pos += bytes\n    }\n\n    if (result) {\n      if (fullInfoFlag) {\n        result = { bytes, value }\n      } else {\n        result = value\n      }\n    } else {\n      result = false\n    }\n\n    debug('_parseVarByteNum: result: %o', result)\n    return result\n  }\n\n  _parseByte () {\n    let result\n    if (this._pos < this._list.length) {\n      result = this._list.readUInt8(this._pos)\n      this._pos++\n    }\n    debug('_parseByte: result: %o', result)\n    return result\n  }\n\n  _parseByType (type) {\n    debug('_parseByType: type: %s', type)\n    switch (type) {\n      case 'byte': {\n        return this._parseByte() !== 0\n      }\n      case 'int8': {\n        return this._parseByte()\n      }\n      case 'int16': {\n        return this._parseNum()\n      }\n      case 'int32': {\n        return this._parse4ByteNum()\n      }\n      case 'var': {\n        return this._parseVarByteNum()\n      }\n      case 'string': {\n        return this._parseString()\n      }\n      case 'pair': {\n        return this._parseStringPair()\n      }\n      case 'binary': {\n        return this._parseBuffer()\n      }\n    }\n  }\n\n  _parseProperties () {\n    debug('_parseProperties')\n    const length = this._parseVarByteNum()\n    const start = this._pos\n    const end = start + length\n    const result = {}\n    while (this._pos < end) {\n      const type = this._parseByte()\n      if (!type) {\n        this._emitError(new Error('Cannot parse property code type'))\n        return false\n      }\n      const name = constants.propertiesCodes[type]\n      if (!name) {\n        this._emitError(new Error('Unknown property'))\n        return false\n      }\n      // user properties process\n      if (name === 'userProperties') {\n        if (!result[name]) {\n          result[name] = Object.create(null)\n        }\n        const currentUserProperty = this._parseByType(constants.propertiesTypes[name])\n        if (result[name][currentUserProperty.name]) {\n          if (Array.isArray(result[name][currentUserProperty.name])) {\n            result[name][currentUserProperty.name].push(currentUserProperty.value)\n          } else {\n            const currentValue = result[name][currentUserProperty.name]\n            result[name][currentUserProperty.name] = [currentValue]\n            result[name][currentUserProperty.name].push(currentUserProperty.value)\n          }\n        } else {\n          result[name][currentUserProperty.name] = currentUserProperty.value\n        }\n        continue\n      }\n      if (result[name]) {\n        if (Array.isArray(result[name])) {\n          result[name].push(this._parseByType(constants.propertiesTypes[name]))\n        } else {\n          result[name] = [result[name]]\n          result[name].push(this._parseByType(constants.propertiesTypes[name]))\n        }\n      } else {\n        result[name] = this._parseByType(constants.propertiesTypes[name])\n      }\n    }\n    return result\n  }\n\n  _newPacket () {\n    debug('_newPacket')\n    if (this.packet) {\n      this._list.consume(this.packet.length)\n      debug('_newPacket: parser emit packet: packet.cmd: %s, packet.payload: %s, packet.length: %d', this.packet.cmd, this.packet.payload, this.packet.length)\n      this.emit('packet', this.packet)\n    }\n    debug('_newPacket: new packet')\n    this.packet = new Packet()\n\n    this._pos = 0\n\n    return true\n  }\n\n  _emitError (err) {\n    debug('_emitError', err)\n    this.error = err\n    this.emit('error', err)\n  }\n}\n\nmodule.exports = Parser\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}