{"ast":null,"code":"/* replacement start */\n\nconst process = require('process/')\n\n/* replacement end */\n// Ported from https://github.com/mafintosh/pump with\n// permission from the author, Mathias Buus (@mafintosh).\n;\n\n'use strict';\nconst {\n  ArrayIsArray,\n  Promise,\n  SymbolAsyncIterator\n} = require('../../ours/primordials');\nconst eos = require('./end-of-stream');\nconst {\n  once\n} = require('../../ours/util');\nconst destroyImpl = require('./destroy');\nconst Duplex = require('./duplex');\nconst {\n  aggregateTwoErrors,\n  codes: {\n    ERR_INVALID_ARG_TYPE,\n    ERR_INVALID_RETURN_VALUE,\n    ERR_MISSING_ARGS,\n    ERR_STREAM_DESTROYED,\n    ERR_STREAM_PREMATURE_CLOSE\n  },\n  AbortError\n} = require('../../ours/errors');\nconst {\n  validateFunction,\n  validateAbortSignal\n} = require('../validators');\nconst {\n  isIterable,\n  isReadable,\n  isReadableNodeStream,\n  isNodeStream,\n  isTransformStream,\n  isWebStream,\n  isReadableStream,\n  isReadableEnded\n} = require('./utils');\nconst AbortController = globalThis.AbortController || require('abort-controller').AbortController;\nlet PassThrough;\nlet Readable;\nfunction destroyer(stream, reading, writing) {\n  let finished = false;\n  stream.on('close', () => {\n    finished = true;\n  });\n  const cleanup = eos(stream, {\n    readable: reading,\n    writable: writing\n  }, err => {\n    finished = !err;\n  });\n  return {\n    destroy: err => {\n      if (finished) return;\n      finished = true;\n      destroyImpl.destroyer(stream, err || new ERR_STREAM_DESTROYED('pipe'));\n    },\n    cleanup\n  };\n}\nfunction popCallback(streams) {\n  // Streams should never be an empty array. It should always contain at least\n  // a single stream. Therefore optimize for the average case instead of\n  // checking for length === 0 as well.\n  validateFunction(streams[streams.length - 1], 'streams[stream.length - 1]');\n  return streams.pop();\n}\nfunction makeAsyncIterable(val) {\n  if (isIterable(val)) {\n    return val;\n  } else if (isReadableNodeStream(val)) {\n    // Legacy streams are not Iterable.\n    return fromReadable(val);\n  }\n  throw new ERR_INVALID_ARG_TYPE('val', ['Readable', 'Iterable', 'AsyncIterable'], val);\n}\nasync function* fromReadable(val) {\n  if (!Readable) {\n    Readable = require('./readable');\n  }\n  yield* Readable.prototype[SymbolAsyncIterator].call(val);\n}\nasync function pumpToNode(iterable, writable, finish, _ref) {\n  let {\n    end\n  } = _ref;\n  let error;\n  let onresolve = null;\n  const resume = err => {\n    if (err) {\n      error = err;\n    }\n    if (onresolve) {\n      const callback = onresolve;\n      onresolve = null;\n      callback();\n    }\n  };\n  const wait = () => new Promise((resolve, reject) => {\n    if (error) {\n      reject(error);\n    } else {\n      onresolve = () => {\n        if (error) {\n          reject(error);\n        } else {\n          resolve();\n        }\n      };\n    }\n  });\n  writable.on('drain', resume);\n  const cleanup = eos(writable, {\n    readable: false\n  }, resume);\n  try {\n    if (writable.writableNeedDrain) {\n      await wait();\n    }\n    for await (const chunk of iterable) {\n      if (!writable.write(chunk)) {\n        await wait();\n      }\n    }\n    if (end) {\n      writable.end();\n    }\n    await wait();\n    finish();\n  } catch (err) {\n    finish(error !== err ? aggregateTwoErrors(error, err) : err);\n  } finally {\n    cleanup();\n    writable.off('drain', resume);\n  }\n}\nasync function pumpToWeb(readable, writable, finish, _ref2) {\n  let {\n    end\n  } = _ref2;\n  if (isTransformStream(writable)) {\n    writable = writable.writable;\n  }\n  // https://streams.spec.whatwg.org/#example-manual-write-with-backpressure\n  const writer = writable.getWriter();\n  try {\n    for await (const chunk of readable) {\n      await writer.ready;\n      writer.write(chunk).catch(() => {});\n    }\n    await writer.ready;\n    if (end) {\n      await writer.close();\n    }\n    finish();\n  } catch (err) {\n    try {\n      await writer.abort(err);\n      finish(err);\n    } catch (err) {\n      finish(err);\n    }\n  }\n}\nfunction pipeline() {\n  for (var _len = arguments.length, streams = new Array(_len), _key = 0; _key < _len; _key++) {\n    streams[_key] = arguments[_key];\n  }\n  return pipelineImpl(streams, once(popCallback(streams)));\n}\nfunction pipelineImpl(streams, callback, opts) {\n  if (streams.length === 1 && ArrayIsArray(streams[0])) {\n    streams = streams[0];\n  }\n  if (streams.length < 2) {\n    throw new ERR_MISSING_ARGS('streams');\n  }\n  const ac = new AbortController();\n  const signal = ac.signal;\n  const outerSignal = opts === null || opts === undefined ? undefined : opts.signal;\n\n  // Need to cleanup event listeners if last stream is readable\n  // https://github.com/nodejs/node/issues/35452\n  const lastStreamCleanup = [];\n  validateAbortSignal(outerSignal, 'options.signal');\n  function abort() {\n    finishImpl(new AbortError());\n  }\n  outerSignal === null || outerSignal === undefined ? undefined : outerSignal.addEventListener('abort', abort);\n  let error;\n  let value;\n  const destroys = [];\n  let finishCount = 0;\n  function finish(err) {\n    finishImpl(err, --finishCount === 0);\n  }\n  function finishImpl(err, final) {\n    if (err && (!error || error.code === 'ERR_STREAM_PREMATURE_CLOSE')) {\n      error = err;\n    }\n    if (!error && !final) {\n      return;\n    }\n    while (destroys.length) {\n      destroys.shift()(error);\n    }\n    outerSignal === null || outerSignal === undefined ? undefined : outerSignal.removeEventListener('abort', abort);\n    ac.abort();\n    if (final) {\n      if (!error) {\n        lastStreamCleanup.forEach(fn => fn());\n      }\n      process.nextTick(callback, error, value);\n    }\n  }\n  let ret;\n  for (let i = 0; i < streams.length; i++) {\n    const stream = streams[i];\n    const reading = i < streams.length - 1;\n    const writing = i > 0;\n    const end = reading || (opts === null || opts === undefined ? undefined : opts.end) !== false;\n    const isLastStream = i === streams.length - 1;\n    if (isNodeStream(stream)) {\n      if (end) {\n        const {\n          destroy,\n          cleanup\n        } = destroyer(stream, reading, writing);\n        destroys.push(destroy);\n        if (isReadable(stream) && isLastStream) {\n          lastStreamCleanup.push(cleanup);\n        }\n      }\n\n      // Catch stream errors that occur after pipe/pump has completed.\n      function onError(err) {\n        if (err && err.name !== 'AbortError' && err.code !== 'ERR_STREAM_PREMATURE_CLOSE') {\n          finish(err);\n        }\n      }\n      stream.on('error', onError);\n      if (isReadable(stream) && isLastStream) {\n        lastStreamCleanup.push(() => {\n          stream.removeListener('error', onError);\n        });\n      }\n    }\n    if (i === 0) {\n      if (typeof stream === 'function') {\n        ret = stream({\n          signal\n        });\n        if (!isIterable(ret)) {\n          throw new ERR_INVALID_RETURN_VALUE('Iterable, AsyncIterable or Stream', 'source', ret);\n        }\n      } else if (isIterable(stream) || isReadableNodeStream(stream) || isTransformStream(stream)) {\n        ret = stream;\n      } else {\n        ret = Duplex.from(stream);\n      }\n    } else if (typeof stream === 'function') {\n      if (isTransformStream(ret)) {\n        var _ret;\n        ret = makeAsyncIterable((_ret = ret) === null || _ret === undefined ? undefined : _ret.readable);\n      } else {\n        ret = makeAsyncIterable(ret);\n      }\n      ret = stream(ret, {\n        signal\n      });\n      if (reading) {\n        if (!isIterable(ret, true)) {\n          throw new ERR_INVALID_RETURN_VALUE('AsyncIterable', `transform[${i - 1}]`, ret);\n        }\n      } else {\n        var _ret2;\n        if (!PassThrough) {\n          PassThrough = require('./passthrough');\n        }\n\n        // If the last argument to pipeline is not a stream\n        // we must create a proxy stream so that pipeline(...)\n        // always returns a stream which can be further\n        // composed through `.pipe(stream)`.\n\n        const pt = new PassThrough({\n          objectMode: true\n        });\n\n        // Handle Promises/A+ spec, `then` could be a getter that throws on\n        // second use.\n        const then = (_ret2 = ret) === null || _ret2 === undefined ? undefined : _ret2.then;\n        if (typeof then === 'function') {\n          finishCount++;\n          then.call(ret, val => {\n            value = val;\n            if (val != null) {\n              pt.write(val);\n            }\n            if (end) {\n              pt.end();\n            }\n            process.nextTick(finish);\n          }, err => {\n            pt.destroy(err);\n            process.nextTick(finish, err);\n          });\n        } else if (isIterable(ret, true)) {\n          finishCount++;\n          pumpToNode(ret, pt, finish, {\n            end\n          });\n        } else if (isReadableStream(ret) || isTransformStream(ret)) {\n          const toRead = ret.readable || ret;\n          finishCount++;\n          pumpToNode(toRead, pt, finish, {\n            end\n          });\n        } else {\n          throw new ERR_INVALID_RETURN_VALUE('AsyncIterable or Promise', 'destination', ret);\n        }\n        ret = pt;\n        const {\n          destroy,\n          cleanup\n        } = destroyer(ret, false, true);\n        destroys.push(destroy);\n        if (isLastStream) {\n          lastStreamCleanup.push(cleanup);\n        }\n      }\n    } else if (isNodeStream(stream)) {\n      if (isReadableNodeStream(ret)) {\n        finishCount += 2;\n        const cleanup = pipe(ret, stream, finish, {\n          end\n        });\n        if (isReadable(stream) && isLastStream) {\n          lastStreamCleanup.push(cleanup);\n        }\n      } else if (isTransformStream(ret) || isReadableStream(ret)) {\n        const toRead = ret.readable || ret;\n        finishCount++;\n        pumpToNode(toRead, stream, finish, {\n          end\n        });\n      } else if (isIterable(ret)) {\n        finishCount++;\n        pumpToNode(ret, stream, finish, {\n          end\n        });\n      } else {\n        throw new ERR_INVALID_ARG_TYPE('val', ['Readable', 'Iterable', 'AsyncIterable', 'ReadableStream', 'TransformStream'], ret);\n      }\n      ret = stream;\n    } else if (isWebStream(stream)) {\n      if (isReadableNodeStream(ret)) {\n        finishCount++;\n        pumpToWeb(makeAsyncIterable(ret), stream, finish, {\n          end\n        });\n      } else if (isReadableStream(ret) || isIterable(ret)) {\n        finishCount++;\n        pumpToWeb(ret, stream, finish, {\n          end\n        });\n      } else if (isTransformStream(ret)) {\n        finishCount++;\n        pumpToWeb(ret.readable, stream, finish, {\n          end\n        });\n      } else {\n        throw new ERR_INVALID_ARG_TYPE('val', ['Readable', 'Iterable', 'AsyncIterable', 'ReadableStream', 'TransformStream'], ret);\n      }\n      ret = stream;\n    } else {\n      ret = Duplex.from(stream);\n    }\n  }\n  if (signal !== null && signal !== undefined && signal.aborted || outerSignal !== null && outerSignal !== undefined && outerSignal.aborted) {\n    process.nextTick(abort);\n  }\n  return ret;\n}\nfunction pipe(src, dst, finish, _ref3) {\n  let {\n    end\n  } = _ref3;\n  let ended = false;\n  dst.on('close', () => {\n    if (!ended) {\n      // Finish if the destination closes before the source has completed.\n      finish(new ERR_STREAM_PREMATURE_CLOSE());\n    }\n  });\n  src.pipe(dst, {\n    end: false\n  }); // If end is true we already will have a listener to end dst.\n\n  if (end) {\n    // Compat. Before node v10.12.0 stdio used to throw an error so\n    // pipe() did/does not end() stdio destinations.\n    // Now they allow it but \"secretly\" don't close the underlying fd.\n\n    function endFn() {\n      ended = true;\n      dst.end();\n    }\n    if (isReadableEnded(src)) {\n      // End the destination if the source has already ended.\n      process.nextTick(endFn);\n    } else {\n      src.once('end', endFn);\n    }\n  } else {\n    finish();\n  }\n  eos(src, {\n    readable: true,\n    writable: false\n  }, err => {\n    const rState = src._readableState;\n    if (err && err.code === 'ERR_STREAM_PREMATURE_CLOSE' && rState && rState.ended && !rState.errored && !rState.errorEmitted) {\n      // Some readable streams will emit 'close' before 'end'. However, since\n      // this is on the readable side 'end' should still be emitted if the\n      // stream has been ended and no error emitted. This should be allowed in\n      // favor of backwards compatibility. Since the stream is piped to a\n      // destination this should not result in any observable difference.\n      // We don't need to check if this is a writable premature close since\n      // eos will only fail with premature close on the reading side for\n      // duplex streams.\n      src.once('end', finish).once('error', finish);\n    } else {\n      finish(err);\n    }\n  });\n  return eos(dst, {\n    readable: false,\n    writable: true\n  }, finish);\n}\nmodule.exports = {\n  pipelineImpl,\n  pipeline\n};","map":{"version":3,"names":["process","require","ArrayIsArray","Promise","SymbolAsyncIterator","eos","once","destroyImpl","Duplex","aggregateTwoErrors","codes","ERR_INVALID_ARG_TYPE","ERR_INVALID_RETURN_VALUE","ERR_MISSING_ARGS","ERR_STREAM_DESTROYED","ERR_STREAM_PREMATURE_CLOSE","AbortError","validateFunction","validateAbortSignal","isIterable","isReadable","isReadableNodeStream","isNodeStream","isTransformStream","isWebStream","isReadableStream","isReadableEnded","AbortController","globalThis","PassThrough","Readable","destroyer","stream","reading","writing","finished","on","cleanup","readable","writable","err","destroy","popCallback","streams","length","pop","makeAsyncIterable","val","fromReadable","prototype","call","pumpToNode","iterable","finish","_ref","end","error","onresolve","resume","callback","wait","resolve","reject","writableNeedDrain","chunk","write","off","pumpToWeb","_ref2","writer","getWriter","ready","catch","close","abort","pipeline","_len","arguments","Array","_key","pipelineImpl","opts","ac","signal","outerSignal","undefined","lastStreamCleanup","finishImpl","addEventListener","value","destroys","finishCount","final","code","shift","removeEventListener","forEach","fn","nextTick","ret","i","isLastStream","push","onError","name","removeListener","from","_ret","_ret2","pt","objectMode","then","toRead","pipe","aborted","src","dst","_ref3","ended","endFn","rState","_readableState","errored","errorEmitted","module","exports"],"sources":["/Users/jstanton/Coding/FieldDock/FieldDockMain/node_modules/mqtt/node_modules/readable-stream/lib/internal/streams/pipeline.js"],"sourcesContent":["/* replacement start */\n\nconst process = require('process/')\n\n/* replacement end */\n// Ported from https://github.com/mafintosh/pump with\n// permission from the author, Mathias Buus (@mafintosh).\n\n;('use strict')\nconst { ArrayIsArray, Promise, SymbolAsyncIterator } = require('../../ours/primordials')\nconst eos = require('./end-of-stream')\nconst { once } = require('../../ours/util')\nconst destroyImpl = require('./destroy')\nconst Duplex = require('./duplex')\nconst {\n  aggregateTwoErrors,\n  codes: {\n    ERR_INVALID_ARG_TYPE,\n    ERR_INVALID_RETURN_VALUE,\n    ERR_MISSING_ARGS,\n    ERR_STREAM_DESTROYED,\n    ERR_STREAM_PREMATURE_CLOSE\n  },\n  AbortError\n} = require('../../ours/errors')\nconst { validateFunction, validateAbortSignal } = require('../validators')\nconst {\n  isIterable,\n  isReadable,\n  isReadableNodeStream,\n  isNodeStream,\n  isTransformStream,\n  isWebStream,\n  isReadableStream,\n  isReadableEnded\n} = require('./utils')\nconst AbortController = globalThis.AbortController || require('abort-controller').AbortController\nlet PassThrough\nlet Readable\nfunction destroyer(stream, reading, writing) {\n  let finished = false\n  stream.on('close', () => {\n    finished = true\n  })\n  const cleanup = eos(\n    stream,\n    {\n      readable: reading,\n      writable: writing\n    },\n    (err) => {\n      finished = !err\n    }\n  )\n  return {\n    destroy: (err) => {\n      if (finished) return\n      finished = true\n      destroyImpl.destroyer(stream, err || new ERR_STREAM_DESTROYED('pipe'))\n    },\n    cleanup\n  }\n}\nfunction popCallback(streams) {\n  // Streams should never be an empty array. It should always contain at least\n  // a single stream. Therefore optimize for the average case instead of\n  // checking for length === 0 as well.\n  validateFunction(streams[streams.length - 1], 'streams[stream.length - 1]')\n  return streams.pop()\n}\nfunction makeAsyncIterable(val) {\n  if (isIterable(val)) {\n    return val\n  } else if (isReadableNodeStream(val)) {\n    // Legacy streams are not Iterable.\n    return fromReadable(val)\n  }\n  throw new ERR_INVALID_ARG_TYPE('val', ['Readable', 'Iterable', 'AsyncIterable'], val)\n}\nasync function* fromReadable(val) {\n  if (!Readable) {\n    Readable = require('./readable')\n  }\n  yield* Readable.prototype[SymbolAsyncIterator].call(val)\n}\nasync function pumpToNode(iterable, writable, finish, { end }) {\n  let error\n  let onresolve = null\n  const resume = (err) => {\n    if (err) {\n      error = err\n    }\n    if (onresolve) {\n      const callback = onresolve\n      onresolve = null\n      callback()\n    }\n  }\n  const wait = () =>\n    new Promise((resolve, reject) => {\n      if (error) {\n        reject(error)\n      } else {\n        onresolve = () => {\n          if (error) {\n            reject(error)\n          } else {\n            resolve()\n          }\n        }\n      }\n    })\n  writable.on('drain', resume)\n  const cleanup = eos(\n    writable,\n    {\n      readable: false\n    },\n    resume\n  )\n  try {\n    if (writable.writableNeedDrain) {\n      await wait()\n    }\n    for await (const chunk of iterable) {\n      if (!writable.write(chunk)) {\n        await wait()\n      }\n    }\n    if (end) {\n      writable.end()\n    }\n    await wait()\n    finish()\n  } catch (err) {\n    finish(error !== err ? aggregateTwoErrors(error, err) : err)\n  } finally {\n    cleanup()\n    writable.off('drain', resume)\n  }\n}\nasync function pumpToWeb(readable, writable, finish, { end }) {\n  if (isTransformStream(writable)) {\n    writable = writable.writable\n  }\n  // https://streams.spec.whatwg.org/#example-manual-write-with-backpressure\n  const writer = writable.getWriter()\n  try {\n    for await (const chunk of readable) {\n      await writer.ready\n      writer.write(chunk).catch(() => {})\n    }\n    await writer.ready\n    if (end) {\n      await writer.close()\n    }\n    finish()\n  } catch (err) {\n    try {\n      await writer.abort(err)\n      finish(err)\n    } catch (err) {\n      finish(err)\n    }\n  }\n}\nfunction pipeline(...streams) {\n  return pipelineImpl(streams, once(popCallback(streams)))\n}\nfunction pipelineImpl(streams, callback, opts) {\n  if (streams.length === 1 && ArrayIsArray(streams[0])) {\n    streams = streams[0]\n  }\n  if (streams.length < 2) {\n    throw new ERR_MISSING_ARGS('streams')\n  }\n  const ac = new AbortController()\n  const signal = ac.signal\n  const outerSignal = opts === null || opts === undefined ? undefined : opts.signal\n\n  // Need to cleanup event listeners if last stream is readable\n  // https://github.com/nodejs/node/issues/35452\n  const lastStreamCleanup = []\n  validateAbortSignal(outerSignal, 'options.signal')\n  function abort() {\n    finishImpl(new AbortError())\n  }\n  outerSignal === null || outerSignal === undefined ? undefined : outerSignal.addEventListener('abort', abort)\n  let error\n  let value\n  const destroys = []\n  let finishCount = 0\n  function finish(err) {\n    finishImpl(err, --finishCount === 0)\n  }\n  function finishImpl(err, final) {\n    if (err && (!error || error.code === 'ERR_STREAM_PREMATURE_CLOSE')) {\n      error = err\n    }\n    if (!error && !final) {\n      return\n    }\n    while (destroys.length) {\n      destroys.shift()(error)\n    }\n    outerSignal === null || outerSignal === undefined ? undefined : outerSignal.removeEventListener('abort', abort)\n    ac.abort()\n    if (final) {\n      if (!error) {\n        lastStreamCleanup.forEach((fn) => fn())\n      }\n      process.nextTick(callback, error, value)\n    }\n  }\n  let ret\n  for (let i = 0; i < streams.length; i++) {\n    const stream = streams[i]\n    const reading = i < streams.length - 1\n    const writing = i > 0\n    const end = reading || (opts === null || opts === undefined ? undefined : opts.end) !== false\n    const isLastStream = i === streams.length - 1\n    if (isNodeStream(stream)) {\n      if (end) {\n        const { destroy, cleanup } = destroyer(stream, reading, writing)\n        destroys.push(destroy)\n        if (isReadable(stream) && isLastStream) {\n          lastStreamCleanup.push(cleanup)\n        }\n      }\n\n      // Catch stream errors that occur after pipe/pump has completed.\n      function onError(err) {\n        if (err && err.name !== 'AbortError' && err.code !== 'ERR_STREAM_PREMATURE_CLOSE') {\n          finish(err)\n        }\n      }\n      stream.on('error', onError)\n      if (isReadable(stream) && isLastStream) {\n        lastStreamCleanup.push(() => {\n          stream.removeListener('error', onError)\n        })\n      }\n    }\n    if (i === 0) {\n      if (typeof stream === 'function') {\n        ret = stream({\n          signal\n        })\n        if (!isIterable(ret)) {\n          throw new ERR_INVALID_RETURN_VALUE('Iterable, AsyncIterable or Stream', 'source', ret)\n        }\n      } else if (isIterable(stream) || isReadableNodeStream(stream) || isTransformStream(stream)) {\n        ret = stream\n      } else {\n        ret = Duplex.from(stream)\n      }\n    } else if (typeof stream === 'function') {\n      if (isTransformStream(ret)) {\n        var _ret\n        ret = makeAsyncIterable((_ret = ret) === null || _ret === undefined ? undefined : _ret.readable)\n      } else {\n        ret = makeAsyncIterable(ret)\n      }\n      ret = stream(ret, {\n        signal\n      })\n      if (reading) {\n        if (!isIterable(ret, true)) {\n          throw new ERR_INVALID_RETURN_VALUE('AsyncIterable', `transform[${i - 1}]`, ret)\n        }\n      } else {\n        var _ret2\n        if (!PassThrough) {\n          PassThrough = require('./passthrough')\n        }\n\n        // If the last argument to pipeline is not a stream\n        // we must create a proxy stream so that pipeline(...)\n        // always returns a stream which can be further\n        // composed through `.pipe(stream)`.\n\n        const pt = new PassThrough({\n          objectMode: true\n        })\n\n        // Handle Promises/A+ spec, `then` could be a getter that throws on\n        // second use.\n        const then = (_ret2 = ret) === null || _ret2 === undefined ? undefined : _ret2.then\n        if (typeof then === 'function') {\n          finishCount++\n          then.call(\n            ret,\n            (val) => {\n              value = val\n              if (val != null) {\n                pt.write(val)\n              }\n              if (end) {\n                pt.end()\n              }\n              process.nextTick(finish)\n            },\n            (err) => {\n              pt.destroy(err)\n              process.nextTick(finish, err)\n            }\n          )\n        } else if (isIterable(ret, true)) {\n          finishCount++\n          pumpToNode(ret, pt, finish, {\n            end\n          })\n        } else if (isReadableStream(ret) || isTransformStream(ret)) {\n          const toRead = ret.readable || ret\n          finishCount++\n          pumpToNode(toRead, pt, finish, {\n            end\n          })\n        } else {\n          throw new ERR_INVALID_RETURN_VALUE('AsyncIterable or Promise', 'destination', ret)\n        }\n        ret = pt\n        const { destroy, cleanup } = destroyer(ret, false, true)\n        destroys.push(destroy)\n        if (isLastStream) {\n          lastStreamCleanup.push(cleanup)\n        }\n      }\n    } else if (isNodeStream(stream)) {\n      if (isReadableNodeStream(ret)) {\n        finishCount += 2\n        const cleanup = pipe(ret, stream, finish, {\n          end\n        })\n        if (isReadable(stream) && isLastStream) {\n          lastStreamCleanup.push(cleanup)\n        }\n      } else if (isTransformStream(ret) || isReadableStream(ret)) {\n        const toRead = ret.readable || ret\n        finishCount++\n        pumpToNode(toRead, stream, finish, {\n          end\n        })\n      } else if (isIterable(ret)) {\n        finishCount++\n        pumpToNode(ret, stream, finish, {\n          end\n        })\n      } else {\n        throw new ERR_INVALID_ARG_TYPE(\n          'val',\n          ['Readable', 'Iterable', 'AsyncIterable', 'ReadableStream', 'TransformStream'],\n          ret\n        )\n      }\n      ret = stream\n    } else if (isWebStream(stream)) {\n      if (isReadableNodeStream(ret)) {\n        finishCount++\n        pumpToWeb(makeAsyncIterable(ret), stream, finish, {\n          end\n        })\n      } else if (isReadableStream(ret) || isIterable(ret)) {\n        finishCount++\n        pumpToWeb(ret, stream, finish, {\n          end\n        })\n      } else if (isTransformStream(ret)) {\n        finishCount++\n        pumpToWeb(ret.readable, stream, finish, {\n          end\n        })\n      } else {\n        throw new ERR_INVALID_ARG_TYPE(\n          'val',\n          ['Readable', 'Iterable', 'AsyncIterable', 'ReadableStream', 'TransformStream'],\n          ret\n        )\n      }\n      ret = stream\n    } else {\n      ret = Duplex.from(stream)\n    }\n  }\n  if (\n    (signal !== null && signal !== undefined && signal.aborted) ||\n    (outerSignal !== null && outerSignal !== undefined && outerSignal.aborted)\n  ) {\n    process.nextTick(abort)\n  }\n  return ret\n}\nfunction pipe(src, dst, finish, { end }) {\n  let ended = false\n  dst.on('close', () => {\n    if (!ended) {\n      // Finish if the destination closes before the source has completed.\n      finish(new ERR_STREAM_PREMATURE_CLOSE())\n    }\n  })\n  src.pipe(dst, {\n    end: false\n  }) // If end is true we already will have a listener to end dst.\n\n  if (end) {\n    // Compat. Before node v10.12.0 stdio used to throw an error so\n    // pipe() did/does not end() stdio destinations.\n    // Now they allow it but \"secretly\" don't close the underlying fd.\n\n    function endFn() {\n      ended = true\n      dst.end()\n    }\n    if (isReadableEnded(src)) {\n      // End the destination if the source has already ended.\n      process.nextTick(endFn)\n    } else {\n      src.once('end', endFn)\n    }\n  } else {\n    finish()\n  }\n  eos(\n    src,\n    {\n      readable: true,\n      writable: false\n    },\n    (err) => {\n      const rState = src._readableState\n      if (\n        err &&\n        err.code === 'ERR_STREAM_PREMATURE_CLOSE' &&\n        rState &&\n        rState.ended &&\n        !rState.errored &&\n        !rState.errorEmitted\n      ) {\n        // Some readable streams will emit 'close' before 'end'. However, since\n        // this is on the readable side 'end' should still be emitted if the\n        // stream has been ended and no error emitted. This should be allowed in\n        // favor of backwards compatibility. Since the stream is piped to a\n        // destination this should not result in any observable difference.\n        // We don't need to check if this is a writable premature close since\n        // eos will only fail with premature close on the reading side for\n        // duplex streams.\n        src.once('end', finish).once('error', finish)\n      } else {\n        finish(err)\n      }\n    }\n  )\n  return eos(\n    dst,\n    {\n      readable: false,\n      writable: true\n    },\n    finish\n  )\n}\nmodule.exports = {\n  pipelineImpl,\n  pipeline\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}