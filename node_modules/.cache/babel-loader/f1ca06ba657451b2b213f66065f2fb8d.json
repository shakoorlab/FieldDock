{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function () {\n        return m[k];\n      }\n    };\n  }\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  __setModuleDefault(result, mod);\n  return result;\n};\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nconst topic_alias_recv_1 = __importDefault(require(\"./topic-alias-recv\"));\nconst mqtt_packet_1 = __importDefault(require(\"mqtt-packet\"));\nconst default_message_id_provider_1 = __importDefault(require(\"./default-message-id-provider\"));\nconst readable_stream_1 = require(\"readable-stream\");\nconst reinterval_1 = __importDefault(require(\"reinterval\"));\nconst default_1 = __importDefault(require(\"rfdc/default\"));\nconst validations = __importStar(require(\"./validations\"));\nconst debug_1 = __importDefault(require(\"debug\"));\nconst store_1 = __importDefault(require(\"./store\"));\nconst handlers_1 = __importDefault(require(\"./handlers\"));\nconst TypedEmitter_1 = require(\"./TypedEmitter\");\nconst nextTick = process ? process.nextTick : callback => {\n  setTimeout(callback, 0);\n};\nconst setImmediate = global.setImmediate || function () {\n  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n    args[_key] = arguments[_key];\n  }\n  const callback = args.shift();\n  nextTick(() => {\n    callback(...args);\n  });\n};\nconst defaultConnectOptions = {\n  keepalive: 60,\n  reschedulePings: true,\n  protocolId: 'MQTT',\n  protocolVersion: 4,\n  reconnectPeriod: 1000,\n  connectTimeout: 30 * 1000,\n  clean: true,\n  resubscribe: true,\n  writeCache: true\n};\nconst socketErrors = ['ECONNREFUSED', 'EADDRINUSE', 'ECONNRESET', 'ENOTFOUND', 'ETIMEDOUT'];\nclass MqttClient extends TypedEmitter_1.TypedEventEmitter {\n  static defaultId() {\n    return `mqttjs_${Math.random().toString(16).substr(2, 8)}`;\n  }\n  constructor(streamBuilder, options) {\n    super();\n    this.options = options || {};\n    for (const k in defaultConnectOptions) {\n      if (typeof this.options[k] === 'undefined') {\n        this.options[k] = defaultConnectOptions[k];\n      } else {\n        this.options[k] = options[k];\n      }\n    }\n    this.log = this.options.log || (0, debug_1.default)('mqttjs:client');\n    this.noop = this._noop.bind(this);\n    this.log('MqttClient :: options.protocol', options.protocol);\n    this.log('MqttClient :: options.protocolVersion', options.protocolVersion);\n    this.log('MqttClient :: options.username', options.username);\n    this.log('MqttClient :: options.keepalive', options.keepalive);\n    this.log('MqttClient :: options.reconnectPeriod', options.reconnectPeriod);\n    this.log('MqttClient :: options.rejectUnauthorized', options.rejectUnauthorized);\n    this.log('MqttClient :: options.properties.topicAliasMaximum', options.properties ? options.properties.topicAliasMaximum : undefined);\n    this.options.clientId = typeof options.clientId === 'string' ? options.clientId : MqttClient.defaultId();\n    this.log('MqttClient :: clientId', this.options.clientId);\n    this.options.customHandleAcks = options.protocolVersion === 5 && options.customHandleAcks ? options.customHandleAcks : function () {\n      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        args[_key2] = arguments[_key2];\n      }\n      args[3](null, 0);\n    };\n    if (!this.options.writeCache) {\n      mqtt_packet_1.default.writeToStream.cacheNumbers = false;\n    }\n    this.streamBuilder = streamBuilder;\n    this.messageIdProvider = typeof this.options.messageIdProvider === 'undefined' ? new default_message_id_provider_1.default() : this.options.messageIdProvider;\n    this.outgoingStore = options.outgoingStore || new store_1.default();\n    this.incomingStore = options.incomingStore || new store_1.default();\n    this.queueQoSZero = options.queueQoSZero === undefined ? true : options.queueQoSZero;\n    this._resubscribeTopics = {};\n    this.messageIdToTopic = {};\n    this.pingTimer = null;\n    this.connected = false;\n    this.disconnecting = false;\n    this.reconnecting = false;\n    this.queue = [];\n    this.connackTimer = null;\n    this.reconnectTimer = null;\n    this._storeProcessing = false;\n    this._packetIdsDuringStoreProcessing = {};\n    this._storeProcessingQueue = [];\n    this.outgoing = {};\n    this._firstConnection = true;\n    if (options.properties && options.properties.topicAliasMaximum > 0) {\n      if (options.properties.topicAliasMaximum > 0xffff) {\n        this.log('MqttClient :: options.properties.topicAliasMaximum is out of range');\n      } else {\n        this.topicAliasRecv = new topic_alias_recv_1.default(options.properties.topicAliasMaximum);\n      }\n    }\n    this.on('connect', () => {\n      const {\n        queue\n      } = this;\n      const deliver = () => {\n        const entry = queue.shift();\n        this.log('deliver :: entry %o', entry);\n        let packet = null;\n        if (!entry) {\n          this._resubscribe();\n          return;\n        }\n        packet = entry.packet;\n        this.log('deliver :: call _sendPacket for %o', packet);\n        let send = true;\n        if (packet.messageId && packet.messageId !== 0) {\n          if (!this.messageIdProvider.register(packet.messageId)) {\n            send = false;\n          }\n        }\n        if (send) {\n          this._sendPacket(packet, err => {\n            if (entry.cb) {\n              entry.cb(err);\n            }\n            deliver();\n          });\n        } else {\n          this.log('messageId: %d has already used. The message is skipped and removed.', packet.messageId);\n          deliver();\n        }\n      };\n      this.log('connect :: sending queued packets');\n      deliver();\n    });\n    this.on('close', () => {\n      this.log('close :: connected set to `false`');\n      this.connected = false;\n      this.log('close :: clearing connackTimer');\n      clearTimeout(this.connackTimer);\n      this.log('close :: clearing ping timer');\n      if (this.pingTimer !== null) {\n        this.pingTimer.clear();\n        this.pingTimer = null;\n      }\n      if (this.topicAliasRecv) {\n        this.topicAliasRecv.clear();\n      }\n      this.log('close :: calling _setupReconnect');\n      this._setupReconnect();\n    });\n    if (!this.options.manualConnect) {\n      this.log('MqttClient :: setting up stream');\n      this.connect();\n    }\n  }\n  handleAuth(packet, callback) {\n    callback();\n  }\n  handleMessage(packet, callback) {\n    callback();\n  }\n  _nextId() {\n    return this.messageIdProvider.allocate();\n  }\n  getLastMessageId() {\n    return this.messageIdProvider.getLastAllocated();\n  }\n  connect() {\n    var _a;\n    const writable = new readable_stream_1.Writable();\n    const parser = mqtt_packet_1.default.parser(this.options);\n    let completeParse = null;\n    const packets = [];\n    this.log('connect :: calling method to clear reconnect');\n    this._clearReconnect();\n    this.log('connect :: using streamBuilder provided to client to create stream');\n    this.stream = this.streamBuilder(this);\n    parser.on('packet', packet => {\n      this.log('parser :: on packet push to packets array.');\n      packets.push(packet);\n    });\n    const work = () => {\n      this.log('work :: getting next packet in queue');\n      const packet = packets.shift();\n      if (packet) {\n        this.log('work :: packet pulled from queue');\n        (0, handlers_1.default)(this, packet, nextTickWork);\n      } else {\n        this.log('work :: no packets in queue');\n        const done = completeParse;\n        completeParse = null;\n        this.log('work :: done flag is %s', !!done);\n        if (done) done();\n      }\n    };\n    const nextTickWork = () => {\n      if (packets.length) {\n        nextTick(work);\n      } else {\n        const done = completeParse;\n        completeParse = null;\n        done();\n      }\n    };\n    writable._write = (buf, enc, done) => {\n      completeParse = done;\n      this.log('writable stream :: parsing buffer');\n      parser.parse(buf);\n      work();\n    };\n    const streamErrorHandler = error => {\n      this.log('streamErrorHandler :: error', error.message);\n      if (socketErrors.includes(error.code)) {\n        this.log('streamErrorHandler :: emitting error');\n        this.emit('error', error);\n      } else {\n        this.noop(error);\n      }\n    };\n    this.log('connect :: pipe stream to writable stream');\n    this.stream.pipe(writable);\n    this.stream.on('error', streamErrorHandler);\n    this.stream.on('close', () => {\n      this.log('(%s)stream :: on close', this.options.clientId);\n      this._flushVolatile();\n      this.log('stream: emit close to MqttClient');\n      this.emit('close');\n    });\n    this.log('connect: sending packet `connect`');\n    const connectPacket = {\n      cmd: 'connect',\n      protocolId: this.options.protocolId,\n      protocolVersion: this.options.protocolVersion,\n      clean: this.options.clean,\n      clientId: this.options.clientId,\n      keepalive: this.options.keepalive,\n      username: this.options.username,\n      password: this.options.password,\n      properties: this.options.properties\n    };\n    if (this.options.will) {\n      connectPacket.will = Object.assign(Object.assign({}, this.options.will), {\n        payload: (_a = this.options.will) === null || _a === void 0 ? void 0 : _a.payload\n      });\n    }\n    if (this.topicAliasRecv) {\n      if (!connectPacket.properties) {\n        connectPacket.properties = {};\n      }\n      if (this.topicAliasRecv) {\n        connectPacket.properties.topicAliasMaximum = this.topicAliasRecv.max;\n      }\n    }\n    this._writePacket(connectPacket);\n    parser.on('error', this.emit.bind(this, 'error'));\n    if (this.options.properties) {\n      if (!this.options.properties.authenticationMethod && this.options.properties.authenticationData) {\n        this.end(() => this.emit('error', new Error('Packet has no Authentication Method')));\n        return this;\n      }\n      if (this.options.properties.authenticationMethod && this.options.authPacket && typeof this.options.authPacket === 'object') {\n        const authPacket = Object.assign({\n          cmd: 'auth',\n          reasonCode: 0\n        }, this.options.authPacket);\n        this._writePacket(authPacket);\n      }\n    }\n    this.stream.setMaxListeners(1000);\n    clearTimeout(this.connackTimer);\n    this.connackTimer = setTimeout(() => {\n      this.log('!!connectTimeout hit!! Calling _cleanUp with force `true`');\n      this._cleanUp(true);\n    }, this.options.connectTimeout);\n    return this;\n  }\n  publish(topic, message, opts, callback) {\n    this.log('publish :: message `%s` to topic `%s`', message, topic);\n    const {\n      options\n    } = this;\n    if (typeof opts === 'function') {\n      callback = opts;\n      opts = null;\n    }\n    opts = opts || {};\n    const defaultOpts = {\n      qos: 0,\n      retain: false,\n      dup: false\n    };\n    opts = Object.assign(Object.assign({}, defaultOpts), opts);\n    const {\n      qos,\n      retain,\n      dup,\n      properties,\n      cbStorePut\n    } = opts;\n    if (this._checkDisconnecting(callback)) {\n      return this;\n    }\n    const publishProc = () => {\n      let messageId = 0;\n      if (qos === 1 || qos === 2) {\n        messageId = this._nextId();\n        if (messageId === null) {\n          this.log('No messageId left');\n          return false;\n        }\n      }\n      const packet = {\n        cmd: 'publish',\n        topic,\n        payload: message,\n        qos,\n        retain,\n        messageId,\n        dup\n      };\n      if (options.protocolVersion === 5) {\n        packet.properties = properties;\n      }\n      this.log('publish :: qos', qos);\n      switch (qos) {\n        case 1:\n        case 2:\n          this.outgoing[packet.messageId] = {\n            volatile: false,\n            cb: callback || this.noop\n          };\n          this.log('MqttClient:publish: packet cmd: %s', packet.cmd);\n          this._sendPacket(packet, undefined, cbStorePut);\n          break;\n        default:\n          this.log('MqttClient:publish: packet cmd: %s', packet.cmd);\n          this._sendPacket(packet, callback, cbStorePut);\n          break;\n      }\n      return true;\n    };\n    if (this._storeProcessing || this._storeProcessingQueue.length > 0 || !publishProc()) {\n      this._storeProcessingQueue.push({\n        invoke: publishProc,\n        cbStorePut: opts.cbStorePut,\n        callback\n      });\n    }\n    return this;\n  }\n  publishAsync(topic, message, opts) {\n    return new Promise((resolve, reject) => {\n      this.publish(topic, message, opts, (err, packet) => {\n        if (err) {\n          reject(err);\n        } else {\n          resolve(packet);\n        }\n      });\n    });\n  }\n  subscribe(topicObject, opts, callback) {\n    const version = this.options.protocolVersion;\n    if (typeof opts === 'function') {\n      callback = opts;\n    }\n    callback = callback || this.noop;\n    let resubscribe = false;\n    let topicsList = [];\n    if (typeof topicObject === 'string') {\n      topicObject = [topicObject];\n      topicsList = topicObject;\n    } else if (Array.isArray(topicObject)) {\n      topicsList = topicObject;\n    } else if (typeof topicObject === 'object') {\n      resubscribe = topicObject.resubscribe;\n      delete topicObject.resubscribe;\n      topicsList = Object.keys(topicObject);\n    }\n    const invalidTopic = validations.validateTopics(topicsList);\n    if (invalidTopic !== null) {\n      setImmediate(callback, new Error(`Invalid topic ${invalidTopic}`));\n      return this;\n    }\n    if (this._checkDisconnecting(callback)) {\n      this.log('subscribe: discconecting true');\n      return this;\n    }\n    const defaultOpts = {\n      qos: 0\n    };\n    if (version === 5) {\n      defaultOpts.nl = false;\n      defaultOpts.rap = false;\n      defaultOpts.rh = 0;\n    }\n    opts = Object.assign(Object.assign({}, defaultOpts), opts);\n    const properties = opts.properties;\n    const subs = [];\n    const parseSub = (topic, subOptions) => {\n      subOptions = subOptions || opts;\n      if (!Object.prototype.hasOwnProperty.call(this._resubscribeTopics, topic) || this._resubscribeTopics[topic].qos < subOptions.qos || resubscribe) {\n        const currentOpts = {\n          topic,\n          qos: subOptions.qos\n        };\n        if (version === 5) {\n          currentOpts.nl = subOptions.nl;\n          currentOpts.rap = subOptions.rap;\n          currentOpts.rh = subOptions.rh;\n          currentOpts.properties = properties;\n        }\n        this.log('subscribe: pushing topic `%s` and qos `%s` to subs list', currentOpts.topic, currentOpts.qos);\n        subs.push(currentOpts);\n      }\n    };\n    if (Array.isArray(topicObject)) {\n      topicObject.forEach(topic => {\n        this.log('subscribe: array topic %s', topic);\n        parseSub(topic);\n      });\n    } else {\n      Object.keys(topicObject).forEach(topic => {\n        this.log('subscribe: object topic %s, %o', topic, topicObject[topic]);\n        parseSub(topic, topicObject[topic]);\n      });\n    }\n    if (!subs.length) {\n      callback(null, []);\n      return this;\n    }\n    const subscribeProc = () => {\n      const messageId = this._nextId();\n      if (messageId === null) {\n        this.log('No messageId left');\n        return false;\n      }\n      const packet = {\n        cmd: 'subscribe',\n        subscriptions: subs,\n        messageId\n      };\n      if (properties) {\n        packet.properties = properties;\n      }\n      if (this.options.resubscribe) {\n        this.log('subscribe :: resubscribe true');\n        const topics = [];\n        subs.forEach(sub => {\n          if (this.options.reconnectPeriod > 0) {\n            const topic = {\n              qos: sub.qos\n            };\n            if (version === 5) {\n              topic.nl = sub.nl || false;\n              topic.rap = sub.rap || false;\n              topic.rh = sub.rh || 0;\n              topic.properties = sub.properties;\n            }\n            this._resubscribeTopics[sub.topic] = topic;\n            topics.push(sub.topic);\n          }\n        });\n        this.messageIdToTopic[packet.messageId] = topics;\n      }\n      this.outgoing[packet.messageId] = {\n        volatile: true,\n        cb(err, packet2) {\n          if (!err) {\n            const {\n              granted\n            } = packet2;\n            for (let i = 0; i < granted.length; i += 1) {\n              subs[i].qos = granted[i];\n            }\n          }\n          callback(err, subs);\n        }\n      };\n      this.log('subscribe :: call _sendPacket');\n      this._sendPacket(packet);\n      return true;\n    };\n    if (this._storeProcessing || this._storeProcessingQueue.length > 0 || !subscribeProc()) {\n      this._storeProcessingQueue.push({\n        invoke: subscribeProc,\n        callback\n      });\n    }\n    return this;\n  }\n  subscribeAsync(topicObject, opts) {\n    return new Promise((resolve, reject) => {\n      this.subscribe(topicObject, opts, (err, granted) => {\n        if (err) {\n          reject(err);\n        } else {\n          resolve(granted);\n        }\n      });\n    });\n  }\n  unsubscribe(topic, opts, callback) {\n    if (typeof topic === 'string') {\n      topic = [topic];\n    }\n    if (typeof opts === 'function') {\n      callback = opts;\n    }\n    callback = callback || this.noop;\n    const invalidTopic = validations.validateTopics(topic);\n    if (invalidTopic !== null) {\n      setImmediate(callback, new Error(`Invalid topic ${invalidTopic}`));\n      return this;\n    }\n    if (this._checkDisconnecting(callback)) {\n      return this;\n    }\n    const unsubscribeProc = () => {\n      const messageId = this._nextId();\n      if (messageId === null) {\n        this.log('No messageId left');\n        return false;\n      }\n      const packet = {\n        cmd: 'unsubscribe',\n        messageId,\n        unsubscriptions: []\n      };\n      if (typeof topic === 'string') {\n        packet.unsubscriptions = [topic];\n      } else if (Array.isArray(topic)) {\n        packet.unsubscriptions = topic;\n      }\n      if (this.options.resubscribe) {\n        packet.unsubscriptions.forEach(topic2 => {\n          delete this._resubscribeTopics[topic2];\n        });\n      }\n      if (typeof opts === 'object' && opts.properties) {\n        packet.properties = opts.properties;\n      }\n      this.outgoing[packet.messageId] = {\n        volatile: true,\n        cb: callback\n      };\n      this.log('unsubscribe: call _sendPacket');\n      this._sendPacket(packet);\n      return true;\n    };\n    if (this._storeProcessing || this._storeProcessingQueue.length > 0 || !unsubscribeProc()) {\n      this._storeProcessingQueue.push({\n        invoke: unsubscribeProc,\n        callback\n      });\n    }\n    return this;\n  }\n  unsubscribeAsync(topic, opts) {\n    return new Promise((resolve, reject) => {\n      this.unsubscribe(topic, opts, (err, packet) => {\n        if (err) {\n          reject(err);\n        } else {\n          resolve(packet);\n        }\n      });\n    });\n  }\n  end(force, opts, cb) {\n    this.log('end :: (%s)', this.options.clientId);\n    if (force == null || typeof force !== 'boolean') {\n      cb = cb || opts;\n      opts = force;\n      force = false;\n    }\n    if (typeof opts !== 'object') {\n      cb = cb || opts;\n      opts = null;\n    }\n    this.log('end :: cb? %s', !!cb);\n    if (!cb || typeof cb !== 'function') {\n      cb = this.noop;\n    }\n    const closeStores = () => {\n      this.log('end :: closeStores: closing incoming and outgoing stores');\n      this.disconnected = true;\n      this.incomingStore.close(e1 => {\n        this.outgoingStore.close(e2 => {\n          this.log('end :: closeStores: emitting end');\n          this.emit('end');\n          if (cb) {\n            const err = e1 || e2;\n            this.log('end :: closeStores: invoking callback with args');\n            cb(err);\n          }\n        });\n      });\n      if (this._deferredReconnect) {\n        this._deferredReconnect();\n      }\n    };\n    const finish = () => {\n      this.log('end :: (%s) :: finish :: calling _cleanUp with force %s', this.options.clientId, force);\n      this._cleanUp(force, () => {\n        this.log('end :: finish :: calling process.nextTick on closeStores');\n        nextTick(closeStores);\n      }, opts);\n    };\n    if (this.disconnecting) {\n      cb();\n      return this;\n    }\n    this._clearReconnect();\n    this.disconnecting = true;\n    if (!force && Object.keys(this.outgoing).length > 0) {\n      this.log('end :: (%s) :: calling finish in 10ms once outgoing is empty', this.options.clientId);\n      this.once('outgoingEmpty', setTimeout.bind(null, finish, 10));\n    } else {\n      this.log('end :: (%s) :: immediately calling finish', this.options.clientId);\n      finish();\n    }\n    return this;\n  }\n  endAsync(force, opts) {\n    return new Promise((resolve, reject) => {\n      this.end(force, opts, err => {\n        if (err) {\n          reject(err);\n        } else {\n          resolve();\n        }\n      });\n    });\n  }\n  removeOutgoingMessage(messageId) {\n    if (this.outgoing[messageId]) {\n      const {\n        cb\n      } = this.outgoing[messageId];\n      this._removeOutgoingAndStoreMessage(messageId, () => {\n        cb(new Error('Message removed'));\n      });\n    }\n    return this;\n  }\n  reconnect(opts) {\n    this.log('client reconnect');\n    const f = () => {\n      if (opts) {\n        this.options.incomingStore = opts.incomingStore;\n        this.options.outgoingStore = opts.outgoingStore;\n      } else {\n        this.options.incomingStore = null;\n        this.options.outgoingStore = null;\n      }\n      this.incomingStore = this.options.incomingStore || new store_1.default();\n      this.outgoingStore = this.options.outgoingStore || new store_1.default();\n      this.disconnecting = false;\n      this.disconnected = false;\n      this._deferredReconnect = null;\n      this._reconnect();\n    };\n    if (this.disconnecting && !this.disconnected) {\n      this._deferredReconnect = f;\n    } else {\n      f();\n    }\n    return this;\n  }\n  _flushVolatile() {\n    if (this.outgoing) {\n      this.log('_flushVolatile :: deleting volatile messages from the queue and setting their callbacks as error function');\n      Object.keys(this.outgoing).forEach(messageId => {\n        if (this.outgoing[messageId].volatile && typeof this.outgoing[messageId].cb === 'function') {\n          this.outgoing[messageId].cb(new Error('Connection closed'));\n          delete this.outgoing[messageId];\n        }\n      });\n    }\n  }\n  _flush() {\n    if (this.outgoing) {\n      this.log('_flush: queue exists? %b', !!this.outgoing);\n      Object.keys(this.outgoing).forEach(messageId => {\n        if (typeof this.outgoing[messageId].cb === 'function') {\n          this.outgoing[messageId].cb(new Error('Connection closed'));\n          delete this.outgoing[messageId];\n        }\n      });\n    }\n  }\n  _removeTopicAliasAndRecoverTopicName(packet) {\n    let alias;\n    if (packet.properties) {\n      alias = packet.properties.topicAlias;\n    }\n    let topic = packet.topic.toString();\n    this.log('_removeTopicAliasAndRecoverTopicName :: alias %d, topic %o', alias, topic);\n    if (topic.length === 0) {\n      if (typeof alias === 'undefined') {\n        return new Error('Unregistered Topic Alias');\n      }\n      topic = this.topicAliasSend.getTopicByAlias(alias);\n      if (typeof topic === 'undefined') {\n        return new Error('Unregistered Topic Alias');\n      }\n      packet.topic = topic;\n    }\n    if (alias) {\n      delete packet.properties.topicAlias;\n    }\n  }\n  _checkDisconnecting(callback) {\n    if (this.disconnecting) {\n      if (callback && callback !== this.noop) {\n        callback(new Error('client disconnecting'));\n      } else {\n        this.emit('error', new Error('client disconnecting'));\n      }\n    }\n    return this.disconnecting;\n  }\n  _reconnect() {\n    this.log('_reconnect: emitting reconnect to client');\n    this.emit('reconnect');\n    if (this.connected) {\n      this.end(() => {\n        this.connect();\n      });\n      this.log('client already connected. disconnecting first.');\n    } else {\n      this.log('_reconnect: calling connect');\n      this.connect();\n    }\n  }\n  _setupReconnect() {\n    if (!this.disconnecting && !this.reconnectTimer && this.options.reconnectPeriod > 0) {\n      if (!this.reconnecting) {\n        this.log('_setupReconnect :: emit `offline` state');\n        this.emit('offline');\n        this.log('_setupReconnect :: set `reconnecting` to `true`');\n        this.reconnecting = true;\n      }\n      this.log('_setupReconnect :: setting reconnectTimer for %d ms', this.options.reconnectPeriod);\n      this.reconnectTimer = setInterval(() => {\n        this.log('reconnectTimer :: reconnect triggered!');\n        this._reconnect();\n      }, this.options.reconnectPeriod);\n    } else {\n      this.log('_setupReconnect :: doing nothing...');\n    }\n  }\n  _clearReconnect() {\n    this.log('_clearReconnect : clearing reconnect timer');\n    if (this.reconnectTimer) {\n      clearInterval(this.reconnectTimer);\n      this.reconnectTimer = null;\n    }\n  }\n  _cleanUp(forced, done) {\n    let opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    if (done) {\n      this.log('_cleanUp :: done callback provided for on stream close');\n      this.stream.on('close', done);\n    }\n    this.log('_cleanUp :: forced? %s', forced);\n    if (forced) {\n      if (this.options.reconnectPeriod === 0 && this.options.clean) {\n        this._flush();\n      }\n      this.log('_cleanUp :: (%s) :: destroying stream', this.options.clientId);\n      this.stream.destroy();\n    } else {\n      const packet = Object.assign({\n        cmd: 'disconnect'\n      }, opts);\n      this.log('_cleanUp :: (%s) :: call _sendPacket with disconnect packet', this.options.clientId);\n      this._sendPacket(packet, () => {\n        this.log('_cleanUp :: (%s) :: destroying stream', this.options.clientId);\n        setImmediate(() => {\n          this.stream.end(() => {\n            this.log('_cleanUp :: (%s) :: stream destroyed', this.options.clientId);\n          });\n        });\n      });\n    }\n    if (!this.disconnecting) {\n      this.log('_cleanUp :: client not disconnecting. Clearing and resetting reconnect.');\n      this._clearReconnect();\n      this._setupReconnect();\n    }\n    if (this.pingTimer !== null) {\n      this.log('_cleanUp :: clearing pingTimer');\n      this.pingTimer.clear();\n      this.pingTimer = null;\n    }\n    if (done && !this.connected) {\n      this.log('_cleanUp :: (%s) :: removing stream `done` callback `close` listener', this.options.clientId);\n      this.stream.removeListener('close', done);\n      done();\n    }\n  }\n  _storeAndSend(packet, cb, cbStorePut) {\n    this.log('storeAndSend :: store packet with cmd %s to outgoingStore', packet.cmd);\n    let storePacket = packet;\n    let err;\n    if (storePacket.cmd === 'publish') {\n      storePacket = (0, default_1.default)(packet);\n      err = this._removeTopicAliasAndRecoverTopicName(storePacket);\n      if (err) {\n        return cb && cb(err);\n      }\n    }\n    this.outgoingStore.put(storePacket, err2 => {\n      if (err2) {\n        return cb && cb(err2);\n      }\n      cbStorePut();\n      this._writePacket(packet, cb);\n    });\n  }\n  _applyTopicAlias(packet) {\n    if (this.options.protocolVersion === 5) {\n      if (packet.cmd === 'publish') {\n        let alias;\n        if (packet.properties) {\n          alias = packet.properties.topicAlias;\n        }\n        const topic = packet.topic.toString();\n        if (this.topicAliasSend) {\n          if (alias) {\n            if (topic.length !== 0) {\n              this.log('applyTopicAlias :: register topic: %s - alias: %d', topic, alias);\n              if (!this.topicAliasSend.put(topic, alias)) {\n                this.log('applyTopicAlias :: error out of range. topic: %s - alias: %d', topic, alias);\n                return new Error('Sending Topic Alias out of range');\n              }\n            }\n          } else if (topic.length !== 0) {\n            if (this.options.autoAssignTopicAlias) {\n              alias = this.topicAliasSend.getAliasByTopic(topic);\n              if (alias) {\n                packet.topic = '';\n                packet.properties = Object.assign(Object.assign({}, packet.properties), {\n                  topicAlias: alias\n                });\n                this.log('applyTopicAlias :: auto assign(use) topic: %s - alias: %d', topic, alias);\n              } else {\n                alias = this.topicAliasSend.getLruAlias();\n                this.topicAliasSend.put(topic, alias);\n                packet.properties = Object.assign(Object.assign({}, packet.properties), {\n                  topicAlias: alias\n                });\n                this.log('applyTopicAlias :: auto assign topic: %s - alias: %d', topic, alias);\n              }\n            } else if (this.options.autoUseTopicAlias) {\n              alias = this.topicAliasSend.getAliasByTopic(topic);\n              if (alias) {\n                packet.topic = '';\n                packet.properties = Object.assign(Object.assign({}, packet.properties), {\n                  topicAlias: alias\n                });\n                this.log('applyTopicAlias :: auto use topic: %s - alias: %d', topic, alias);\n              }\n            }\n          }\n        } else if (alias) {\n          this.log('applyTopicAlias :: error out of range. topic: %s - alias: %d', topic, alias);\n          return new Error('Sending Topic Alias out of range');\n        }\n      }\n    }\n  }\n  _noop(err) {\n    this.log('noop ::', err);\n  }\n  _writePacket(packet, cb) {\n    this.log('_writePacket :: packet: %O', packet);\n    this.log('_writePacket :: emitting `packetsend`');\n    this.emit('packetsend', packet);\n    this._shiftPingInterval();\n    this.log('_writePacket :: writing to stream');\n    const result = mqtt_packet_1.default.writeToStream(packet, this.stream, this.options);\n    this.log('_writePacket :: writeToStream result %s', result);\n    if (!result && cb && cb !== this.noop) {\n      this.log('_writePacket :: handle events on `drain` once through callback.');\n      this.stream.once('drain', cb);\n    } else if (cb) {\n      this.log('_writePacket :: invoking cb');\n      cb();\n    }\n  }\n  _sendPacket(packet, cb, cbStorePut, noStore) {\n    this.log('_sendPacket :: (%s) ::  start', this.options.clientId);\n    cbStorePut = cbStorePut || this.noop;\n    cb = cb || this.noop;\n    const err = this._applyTopicAlias(packet);\n    if (err) {\n      cb(err);\n      return;\n    }\n    if (!this.connected) {\n      if (packet.cmd === 'auth') {\n        this._writePacket(packet, cb);\n        return;\n      }\n      this.log('_sendPacket :: client not connected. Storing packet offline.');\n      this._storePacket(packet, cb, cbStorePut);\n      return;\n    }\n    if (noStore) {\n      this._writePacket(packet, cb);\n      return;\n    }\n    switch (packet.cmd) {\n      case 'publish':\n        break;\n      case 'pubrel':\n        this._storeAndSend(packet, cb, cbStorePut);\n        return;\n      default:\n        this._writePacket(packet, cb);\n        return;\n    }\n    switch (packet.qos) {\n      case 2:\n      case 1:\n        this._storeAndSend(packet, cb, cbStorePut);\n        break;\n      case 0:\n      default:\n        this._writePacket(packet, cb);\n        break;\n    }\n    this.log('_sendPacket :: (%s) ::  end', this.options.clientId);\n  }\n  _storePacket(packet, cb, cbStorePut) {\n    this.log('_storePacket :: packet: %o', packet);\n    this.log('_storePacket :: cb? %s', !!cb);\n    cbStorePut = cbStorePut || this.noop;\n    let storePacket = packet;\n    if (storePacket.cmd === 'publish') {\n      storePacket = (0, default_1.default)(packet);\n      const err = this._removeTopicAliasAndRecoverTopicName(storePacket);\n      if (err) {\n        return cb && cb(err);\n      }\n    }\n    const qos = storePacket.qos || 0;\n    if (qos === 0 && this.queueQoSZero || storePacket.cmd !== 'publish') {\n      this.queue.push({\n        packet: storePacket,\n        cb\n      });\n    } else if (qos > 0) {\n      cb = this.outgoing[storePacket.messageId] ? this.outgoing[storePacket.messageId].cb : null;\n      this.outgoingStore.put(storePacket, err => {\n        if (err) {\n          return cb && cb(err);\n        }\n        cbStorePut();\n      });\n    } else if (cb) {\n      cb(new Error('No connection to broker'));\n    }\n  }\n  _setupPingTimer() {\n    this.log('_setupPingTimer :: keepalive %d (seconds)', this.options.keepalive);\n    if (!this.pingTimer && this.options.keepalive) {\n      this.pingResp = true;\n      this.pingTimer = (0, reinterval_1.default)(() => {\n        this._checkPing();\n      }, this.options.keepalive * 1000);\n    }\n  }\n  _shiftPingInterval() {\n    if (this.pingTimer && this.options.keepalive && this.options.reschedulePings) {\n      this.pingTimer.reschedule(this.options.keepalive * 1000);\n    }\n  }\n  _checkPing() {\n    this.log('_checkPing :: checking ping...');\n    if (this.pingResp) {\n      this.log('_checkPing :: ping response received. Clearing flag and sending `pingreq`');\n      this.pingResp = false;\n      this._sendPacket({\n        cmd: 'pingreq'\n      });\n    } else {\n      this.log('_checkPing :: calling _cleanUp with force true');\n      this._cleanUp(true);\n    }\n  }\n  _resubscribe() {\n    this.log('_resubscribe');\n    const _resubscribeTopicsKeys = Object.keys(this._resubscribeTopics);\n    if (!this._firstConnection && (this.options.clean || this.options.protocolVersion >= 4 && !this.connackPacket.sessionPresent) && _resubscribeTopicsKeys.length > 0) {\n      if (this.options.resubscribe) {\n        if (this.options.protocolVersion === 5) {\n          this.log('_resubscribe: protocolVersion 5');\n          for (let topicI = 0; topicI < _resubscribeTopicsKeys.length; topicI++) {\n            const resubscribeTopic = {};\n            resubscribeTopic[_resubscribeTopicsKeys[topicI]] = this._resubscribeTopics[_resubscribeTopicsKeys[topicI]];\n            resubscribeTopic.resubscribe = true;\n            this.subscribe(resubscribeTopic, {\n              properties: resubscribeTopic[_resubscribeTopicsKeys[topicI]].properties\n            });\n          }\n        } else {\n          this._resubscribeTopics.resubscribe = true;\n          this.subscribe(this._resubscribeTopics);\n        }\n      } else {\n        this._resubscribeTopics = {};\n      }\n    }\n    this._firstConnection = false;\n  }\n  _onConnect(packet) {\n    if (this.disconnected) {\n      this.emit('connect', packet);\n      return;\n    }\n    this.connackPacket = packet;\n    this.messageIdProvider.clear();\n    this._setupPingTimer();\n    this.connected = true;\n    const startStreamProcess = () => {\n      let outStore = this.outgoingStore.createStream();\n      const remove = () => {\n        outStore.destroy();\n        outStore = null;\n        this._flushStoreProcessingQueue();\n        clearStoreProcessing();\n      };\n      const clearStoreProcessing = () => {\n        this._storeProcessing = false;\n        this._packetIdsDuringStoreProcessing = {};\n      };\n      this.once('close', remove);\n      outStore.on('error', err => {\n        clearStoreProcessing();\n        this._flushStoreProcessingQueue();\n        this.removeListener('close', remove);\n        this.emit('error', err);\n      });\n      const storeDeliver = () => {\n        if (!outStore) {\n          return;\n        }\n        const packet2 = outStore.read(1);\n        let cb;\n        if (!packet2) {\n          outStore.once('readable', storeDeliver);\n          return;\n        }\n        this._storeProcessing = true;\n        if (this._packetIdsDuringStoreProcessing[packet2.messageId]) {\n          storeDeliver();\n          return;\n        }\n        if (!this.disconnecting && !this.reconnectTimer) {\n          cb = this.outgoing[packet2.messageId] ? this.outgoing[packet2.messageId].cb : null;\n          this.outgoing[packet2.messageId] = {\n            volatile: false,\n            cb(err, status) {\n              if (cb) {\n                cb(err, status);\n              }\n              storeDeliver();\n            }\n          };\n          this._packetIdsDuringStoreProcessing[packet2.messageId] = true;\n          if (this.messageIdProvider.register(packet2.messageId)) {\n            this._sendPacket(packet2, undefined, undefined, true);\n          } else {\n            this.log('messageId: %d has already used.', packet2.messageId);\n          }\n        } else if (outStore.destroy) {\n          outStore.destroy();\n        }\n      };\n      outStore.on('end', () => {\n        let allProcessed = true;\n        for (const id in this._packetIdsDuringStoreProcessing) {\n          if (!this._packetIdsDuringStoreProcessing[id]) {\n            allProcessed = false;\n            break;\n          }\n        }\n        if (allProcessed) {\n          clearStoreProcessing();\n          this.removeListener('close', remove);\n          this._invokeAllStoreProcessingQueue();\n          this.emit('connect', packet);\n        } else {\n          startStreamProcess();\n        }\n      });\n      storeDeliver();\n    };\n    startStreamProcess();\n  }\n  _invokeStoreProcessingQueue() {\n    if (!this._storeProcessing && this._storeProcessingQueue.length > 0) {\n      const f = this._storeProcessingQueue[0];\n      if (f && f.invoke()) {\n        this._storeProcessingQueue.shift();\n        return true;\n      }\n    }\n    return false;\n  }\n  _invokeAllStoreProcessingQueue() {\n    while (this._invokeStoreProcessingQueue()) {}\n  }\n  _flushStoreProcessingQueue() {\n    for (const f of this._storeProcessingQueue) {\n      if (f.cbStorePut) f.cbStorePut(new Error('Connection closed'));\n      if (f.callback) f.callback(new Error('Connection closed'));\n    }\n    this._storeProcessingQueue.splice(0);\n  }\n  _removeOutgoingAndStoreMessage(messageId, cb) {\n    delete this.outgoing[messageId];\n    this.outgoingStore.del({\n      messageId\n    }, (err, packet) => {\n      cb(err, packet);\n      this.messageIdProvider.deallocate(messageId);\n      this._invokeStoreProcessingQueue();\n    });\n  }\n}\nexports.default = MqttClient;","map":{"version":3,"names":["topic_alias_recv_1","__importDefault","require","mqtt_packet_1","default_message_id_provider_1","readable_stream_1","reinterval_1","default_1","validations","__importStar","debug_1","store_1","handlers_1","TypedEmitter_1","nextTick","process","callback","setTimeout","setImmediate","global","_len","arguments","length","args","Array","_key","shift","defaultConnectOptions","keepalive","reschedulePings","protocolId","protocolVersion","reconnectPeriod","connectTimeout","clean","resubscribe","writeCache","socketErrors","MqttClient","TypedEventEmitter","defaultId","Math","random","toString","substr","constructor","streamBuilder","options","k","log","default","noop","_noop","bind","protocol","username","rejectUnauthorized","properties","topicAliasMaximum","undefined","clientId","customHandleAcks","_len2","_key2","writeToStream","cacheNumbers","messageIdProvider","outgoingStore","incomingStore","queueQoSZero","_resubscribeTopics","messageIdToTopic","pingTimer","connected","disconnecting","reconnecting","queue","connackTimer","reconnectTimer","_storeProcessing","_packetIdsDuringStoreProcessing","_storeProcessingQueue","outgoing","_firstConnection","topicAliasRecv","on","deliver","entry","packet","_resubscribe","send","messageId","register","_sendPacket","err","cb","clearTimeout","clear","_setupReconnect","manualConnect","connect","handleAuth","handleMessage","_nextId","allocate","getLastMessageId","getLastAllocated","writable","Writable","parser","completeParse","packets","_clearReconnect","stream","push","work","nextTickWork","done","_write","buf","enc","parse","streamErrorHandler","error","message","includes","code","emit","pipe","_flushVolatile","connectPacket","cmd","password","will","Object","assign","payload","_a","max","_writePacket","authenticationMethod","authenticationData","end","Error","authPacket","reasonCode","setMaxListeners","_cleanUp","publish","topic","opts","defaultOpts","qos","retain","dup","cbStorePut","_checkDisconnecting","publishProc","volatile","invoke","publishAsync","Promise","resolve","reject","subscribe","topicObject","version","topicsList","isArray","keys","invalidTopic","validateTopics","nl","rap","rh","subs","parseSub","subOptions","prototype","hasOwnProperty","call","currentOpts","forEach","subscribeProc","subscriptions","topics","sub","packet2","granted","i","subscribeAsync","unsubscribe","unsubscribeProc","unsubscriptions","topic2","unsubscribeAsync","force","closeStores","disconnected","close","e1","e2","_deferredReconnect","finish","once","endAsync","removeOutgoingMessage","_removeOutgoingAndStoreMessage","reconnect","f","_reconnect","_flush","_removeTopicAliasAndRecoverTopicName","alias","topicAlias","topicAliasSend","getTopicByAlias","setInterval","clearInterval","forced","destroy","removeListener","_storeAndSend","storePacket","put","err2","_applyTopicAlias","autoAssignTopicAlias","getAliasByTopic","getLruAlias","autoUseTopicAlias","_shiftPingInterval","result","noStore","_storePacket","_setupPingTimer","pingResp","_checkPing","reschedule","_resubscribeTopicsKeys","connackPacket","sessionPresent","topicI","resubscribeTopic","_onConnect","startStreamProcess","outStore","createStream","remove","_flushStoreProcessingQueue","clearStoreProcessing","storeDeliver","read","status","allProcessed","id","_invokeAllStoreProcessingQueue","_invokeStoreProcessingQueue","splice","del","deallocate","exports"],"sources":["/Users/jstanton/Coding/FieldDock/FieldDockMain/node_modules/mqtt/src/lib/client.ts"],"sourcesContent":["/**\n * Module dependencies\n */\nimport TopicAliasRecv from './topic-alias-recv'\nimport mqttPacket, {\n\tIAuthPacket,\n\tIConnackPacket,\n\tIDisconnectPacket,\n\tIPublishPacket,\n\tISubscribePacket,\n\tISubscription,\n\tIUnsubscribePacket,\n\tPacket,\n\tQoS,\n\tISubackPacket,\n\tIConnectPacket,\n} from 'mqtt-packet'\nimport DefaultMessageIdProvider, {\n\tIMessageIdProvider,\n} from './default-message-id-provider'\nimport { DuplexOptions, Writable } from 'readable-stream'\nimport reInterval from 'reinterval'\nimport clone from 'rfdc/default'\nimport * as validations from './validations'\nimport _debug from 'debug'\nimport Store, { IStore } from './store'\nimport handlePacket from './handlers'\nimport { ClientOptions } from 'ws'\nimport { ClientRequestArgs } from 'http'\nimport {\n\tDoneCallback,\n\tErrorWithReasonCode,\n\tGenericCallback,\n\tIStream,\n\tStreamBuilder,\n\tVoidCallback,\n} from './shared'\nimport TopicAliasSend from './topic-alias-send'\nimport { TypedEventEmitter } from './TypedEmitter'\n\nconst nextTick = process\n\t? process.nextTick\n\t: (callback: () => void) => {\n\t\t\tsetTimeout(callback, 0)\n\t  }\n\nconst setImmediate =\n\tglobal.setImmediate ||\n\t((...args: any[]) => {\n\t\tconst callback = args.shift()\n\t\tnextTick(() => {\n\t\t\tcallback(...args)\n\t\t})\n\t})\n\nconst defaultConnectOptions = {\n\tkeepalive: 60,\n\treschedulePings: true,\n\tprotocolId: 'MQTT',\n\tprotocolVersion: 4,\n\treconnectPeriod: 1000,\n\tconnectTimeout: 30 * 1000,\n\tclean: true,\n\tresubscribe: true,\n\twriteCache: true,\n}\n\nconst socketErrors = [\n\t'ECONNREFUSED',\n\t'EADDRINUSE',\n\t'ECONNRESET',\n\t'ENOTFOUND',\n\t'ETIMEDOUT',\n]\n\nexport type MqttProtocol =\n\t| 'wss'\n\t| 'ws'\n\t| 'mqtt'\n\t| 'mqtts'\n\t| 'tcp'\n\t| 'ssl'\n\t| 'wx'\n\t| 'wxs'\n\t| 'ali'\n\t| 'alis'\n\nexport type StorePutCallback = () => void\n\nexport interface ISecureClientOptions {\n\t/**\n\t * optional private keys in PEM format\n\t */\n\tkey?: string | string[] | Buffer | Buffer[] | any[]\n\tkeyPath?: string\n\t/**\n\t * optional cert chains in PEM format\n\t */\n\tcert?: string | string[] | Buffer | Buffer[]\n\tcertPath?: string\n\t/**\n\t * Optionally override the trusted CA certificates in PEM format\n\t */\n\tca?: string | string[] | Buffer | Buffer[]\n\tcaPaths?: string | string[]\n\n\trejectUnauthorized?: boolean\n\t/**\n\t * optional alpn's\n\t */\n\tALPNProtocols?: string[] | Buffer[] | Uint8Array[] | Buffer | Uint8Array\n}\n\nexport type AckHandler = (\n\ttopic: string,\n\tmessage: Buffer,\n\tpacket: any,\n\tcb: (error: Error | number, code?: number) => void,\n) => void\n\nexport interface IClientOptions extends ISecureClientOptions {\n\t/** CLIENT PROPERTIES */\n\n\t/** Encoding to use. Example 'binary' */\n\tencoding?: BufferEncoding\n\t/** Set browser buffer size. Default to 512KB */\n\tbrowserBufferSize?: number\n\t/** used in ws protocol to set `objectMode` */\n\tbinary?: boolean\n\t/** Used on ali protocol */\n\tmy?: any\n\t/** Manually call `connect` after creating client instance */\n\tmanualConnect?: boolean\n\t/** Custom auth packet properties */\n\tauthPacket?: Partial<IAuthPacket>\n\t/** Disable/Enable writeToStream.cacheNumbers */\n\twriteCache?: boolean\n\t/** Should be set to `host` */\n\tservername?: string\n\t/** The default protocol to use when using `servers` and no protocol is specified */\n\tdefaultProtocol?: MqttProtocol\n\t/** Support clientId passed in the query string of the url */\n\tquery?: Record<string, string>\n\t/** Auth string in the format <username>:<password> */\n\tauth?: string\n\t/** Custom ack handler */\n\tcustomHandleAcks?: AckHandler\n\t/** Broker port */\n\tport?: number\n\t/** Broker host. Does NOT include port */\n\thost?: string\n\t/** @deprecated use `host instead */\n\thostname?: string\n\t/** Websocket `path` added as suffix */\n\tpath?: string\n\t/** The `MqttProtocol` to use */\n\tprotocol?: MqttProtocol\n\n\t/** Websocket options */\n\twsOptions?: ClientOptions | ClientRequestArgs | DuplexOptions\n\n\t/**\n\t * 1000 milliseconds, interval between two reconnections\n\t */\n\treconnectPeriod?: number\n\t/**\n\t * 30 * 1000 milliseconds, time to wait before a CONNACK is received\n\t */\n\tconnectTimeout?: number\n\n\t/**\n\t * a Store for the incoming packets\n\t */\n\tincomingStore?: IStore\n\t/**\n\t * a Store for the outgoing packets\n\t */\n\toutgoingStore?: IStore\n\n\t/** Enable/Disable queue for QoS 0 packets */\n\tqueueQoSZero?: boolean\n\n\t/** Custom log function, default uses `debug` */\n\tlog?: (...args: any[]) => void\n\n\t/** automatically use topic alias */\n\tautoUseTopicAlias?: boolean\n\n\t/** automatically assign topic alias */\n\tautoAssignTopicAlias?: boolean\n\n\t/** Set to false to disable ping reschedule. When enabled ping messages are rescheduled on each message sent */\n\treschedulePings?: boolean\n\n\t/** List of broker servers. On each reconnect try the next server will be used */\n\tservers?: Array<{\n\t\thost: string\n\t\tport: number\n\t\tprotocol?:\n\t\t\t| 'wss'\n\t\t\t| 'ws'\n\t\t\t| 'mqtt'\n\t\t\t| 'mqtts'\n\t\t\t| 'tcp'\n\t\t\t| 'ssl'\n\t\t\t| 'wx'\n\t\t\t| 'wxs'\n\t}>\n\t/**\n\t * true, set to false to disable re-subscribe functionality\n\t */\n\tresubscribe?: boolean\n\n\t/** when defined this function will be called to transform the url string generated by MqttClient from provided options */\n\ttransformWsUrl?: (\n\t\turl: string,\n\t\toptions: IClientOptions,\n\t\tclient: MqttClient,\n\t) => string\n\n\t/** Custom message id provider */\n\tmessageIdProvider?: IMessageIdProvider\n\n\t/** When using websockets, this is the timeout used when writing to socket. Default 1000 (1s) */\n\tbrowserBufferTimeout?: number\n\n\t/**\n\t * When using websockets, this sets the `objectMode` option.\n\t * When in objectMode, streams can push Strings and Buffers\n\t * as well as any other JavaScript object.\n\t * Another major difference is that when in objectMode,\n\t * the internal buffering algorithm counts objects rather than bytes.\n\t * This means if we have a Transform stream with the highWaterMark option set to 5,\n\t * the stream will only buffer a maximum of 5 objects internally\n\t */\n\tobjectMode?: boolean\n\n\t/** CONNECT PACKET PROPERTIES */\n\n\t/**\n\t * 'mqttjs_' + Math.random().toString(16).substr(2, 8)\n\t */\n\tclientId?: string\n\t/**\n\t * 3=MQTT 3.1 4=MQTT 3.1.1 5=MQTT 5.0. Defaults to 4\n\t */\n\tprotocolVersion?: IConnectPacket['protocolVersion']\n\t/**\n\t * 'MQTT'\n\t */\n\tprotocolId?: IConnectPacket['protocolId']\n\t/**\n\t * true, set to false to receive QoS 1 and 2 messages while offline\n\t */\n\tclean?: boolean\n\t/**\n\t *  10 seconds, set to 0 to disable\n\t */\n\tkeepalive?: number\n\t/**\n\t * the username required by your broker, if any\n\t */\n\tusername?: string\n\t/**\n\t * the password required by your broker, if any\n\t */\n\tpassword?: Buffer | string\n\t/**\n\t * a message that will sent by the broker automatically when the client disconnect badly.\n\t */\n\twill?: IConnectPacket['will']\n\t/** see `connect` packet: https://github.com/mqttjs/mqtt-packet/blob/master/types/index.d.ts#L65 */\n\tproperties?: IConnectPacket['properties']\n}\n\nexport interface IClientPublishOptions {\n\t/**\n\t * the QoS\n\t */\n\tqos?: QoS\n\t/**\n\t * the retain flag\n\t */\n\tretain?: boolean\n\t/**\n\t * whether or not mark a message as duplicate\n\t */\n\tdup?: boolean\n\t/*\n\t *  MQTT 5.0 properties object\n\t */\n\tproperties?: IPublishPacket['properties']\n\t/**\n\t * callback called when message is put into `outgoingStore`\n\t */\n\tcbStorePut?: StorePutCallback\n}\n\nexport interface IClientReconnectOptions {\n\t/**\n\t * a Store for the incoming packets\n\t */\n\tincomingStore?: Store\n\t/**\n\t * a Store for the outgoing packets\n\t */\n\toutgoingStore?: Store\n}\nexport interface IClientSubscribeProperties {\n\t/*\n\t *  MQTT 5.0 properies object of subscribe\n\t * */\n\tproperties?: ISubscribePacket['properties']\n}\n\nexport interface IClientSubscribeOptions extends IClientSubscribeProperties {\n\t/**\n\t * the QoS\n\t */\n\tqos: QoS\n\t/*\n\t * no local flag\n\t * */\n\tnl?: boolean\n\t/*\n\t * Retain As Published flag\n\t * */\n\trap?: boolean\n\t/*\n\t * Retain Handling option\n\t * */\n\trh?: number\n}\nexport interface ISubscriptionRequest extends IClientSubscribeOptions {\n\t/**\n\t *  is a subscribed to topic\n\t */\n\ttopic: string\n}\n\nexport interface ISubscriptionGrant\n\textends Omit<ISubscriptionRequest, 'qos' | 'properties'> {\n\t/**\n\t *  is the granted qos level on it, may return 128 on error\n\t */\n\tqos: QoS | 128\n}\n\nexport type ISubscriptionMap = {\n\t/**\n\t * object which has topic names as object keys and as value the options, like {'test1': {qos: 0}, 'test2': {qos: 2}}.\n\t */\n\t[topic: string]: IClientSubscribeOptions\n} & {\n\tresubscribe?: boolean\n}\n\nexport { IConnackPacket, IDisconnectPacket, IPublishPacket, Packet }\nexport type OnConnectCallback = (packet: IConnackPacket) => void\nexport type OnDisconnectCallback = (packet: IDisconnectPacket) => void\nexport type ClientSubscribeCallback = (\n\terr: Error | null,\n\tgranted: ISubscriptionGrant[],\n) => void\nexport type OnMessageCallback = (\n\ttopic: string,\n\tpayload: Buffer,\n\tpacket: IPublishPacket,\n) => void\nexport type OnPacketCallback = (packet: Packet) => void\nexport type OnCloseCallback = () => void\nexport type OnErrorCallback = (error: Error | ErrorWithReasonCode) => void\nexport type PacketCallback = (error?: Error, packet?: Packet) => any\nexport type CloseCallback = (error?: Error) => void\n\nexport interface MqttClientEventCallbacks {\n\tconnect: OnConnectCallback\n\tmessage: OnMessageCallback\n\tpacketsend: OnPacketCallback\n\tpacketreceive: OnPacketCallback\n\tdisconnect: OnDisconnectCallback\n\terror: OnErrorCallback\n\tclose: OnCloseCallback\n\tend: VoidCallback\n\treconnect: VoidCallback\n\toffline: VoidCallback\n\toutgoingEmpty: VoidCallback\n}\n\n/**\n * MqttClient constructor\n *\n * @param {Stream} stream - stream\n * @param {Object} [options] - connection options\n * (see Connection#connect)\n */\nexport default class MqttClient extends TypedEventEmitter<MqttClientEventCallbacks> {\n\t/** Public fields */\n\n\t/** It's true when client is connected to broker */\n\tpublic connected: boolean\n\n\tpublic disconnecting: boolean\n\n\tpublic disconnected: boolean\n\n\tpublic reconnecting: boolean\n\n\tpublic incomingStore: IStore\n\n\tpublic outgoingStore: IStore\n\n\tpublic options: IClientOptions\n\n\tpublic queueQoSZero: boolean\n\n\tpublic _reconnectCount: number\n\n\tpublic log: (...args: any[]) => void\n\n\tpublic messageIdProvider: IMessageIdProvider\n\n\tpublic pingResp: boolean\n\n\tpublic outgoing: Record<\n\t\tnumber,\n\t\t{ volatile: boolean; cb: (err: Error, packet?: Packet) => void }\n\t>\n\n\tpublic messageIdToTopic: Record<number, string[]>\n\n\tpublic noop: (error?: any) => void\n\n\tpublic pingTimer: any\n\n\tpublic stream: IStream\n\n\tpublic queue: { packet: Packet; cb: PacketCallback }[]\n\n\t/* Private fields */\n\n\t/** Function used to build the stream */\n\tprivate streamBuilder: StreamBuilder\n\n\tprivate _resubscribeTopics: ISubscriptionMap\n\n\tprivate connackTimer: NodeJS.Timeout\n\n\tprivate reconnectTimer: NodeJS.Timeout\n\n\tprivate _storeProcessing: boolean\n\n\t/** keep a reference of packets that have been successfully processed from outgoing store  */\n\tprivate _packetIdsDuringStoreProcessing: Record<number, boolean>\n\n\tprivate _storeProcessingQueue: {\n\t\tinvoke: () => any\n\t\tcbStorePut?: DoneCallback\n\t\tcallback: GenericCallback<any>\n\t}[]\n\n\tprivate _firstConnection: boolean\n\n\tprivate topicAliasRecv: TopicAliasRecv\n\n\tprivate topicAliasSend: TopicAliasSend\n\n\tprivate _deferredReconnect: () => void\n\n\tprivate connackPacket: IConnackPacket\n\n\tpublic static defaultId() {\n\t\treturn `mqttjs_${Math.random().toString(16).substr(2, 8)}`\n\t}\n\n\tconstructor(streamBuilder: StreamBuilder, options: IClientOptions) {\n\t\tsuper()\n\n\t\tthis.options = options || {}\n\n\t\t// Defaults\n\t\tfor (const k in defaultConnectOptions) {\n\t\t\tif (typeof this.options[k] === 'undefined') {\n\t\t\t\tthis.options[k] = defaultConnectOptions[k]\n\t\t\t} else {\n\t\t\t\tthis.options[k] = options[k]\n\t\t\t}\n\t\t}\n\n\t\tthis.log = this.options.log || _debug('mqttjs:client')\n\t\tthis.noop = this._noop.bind(this)\n\n\t\tthis.log('MqttClient :: options.protocol', options.protocol)\n\t\tthis.log(\n\t\t\t'MqttClient :: options.protocolVersion',\n\t\t\toptions.protocolVersion,\n\t\t)\n\t\tthis.log('MqttClient :: options.username', options.username)\n\t\tthis.log('MqttClient :: options.keepalive', options.keepalive)\n\t\tthis.log(\n\t\t\t'MqttClient :: options.reconnectPeriod',\n\t\t\toptions.reconnectPeriod,\n\t\t)\n\t\tthis.log(\n\t\t\t'MqttClient :: options.rejectUnauthorized',\n\t\t\toptions.rejectUnauthorized,\n\t\t)\n\t\tthis.log(\n\t\t\t'MqttClient :: options.properties.topicAliasMaximum',\n\t\t\toptions.properties\n\t\t\t\t? options.properties.topicAliasMaximum\n\t\t\t\t: undefined,\n\t\t)\n\n\t\tthis.options.clientId =\n\t\t\ttypeof options.clientId === 'string'\n\t\t\t\t? options.clientId\n\t\t\t\t: MqttClient.defaultId()\n\n\t\tthis.log('MqttClient :: clientId', this.options.clientId)\n\n\t\tthis.options.customHandleAcks =\n\t\t\toptions.protocolVersion === 5 && options.customHandleAcks\n\t\t\t\t? options.customHandleAcks\n\t\t\t\t: (...args) => {\n\t\t\t\t\t\targs[3](null, 0)\n\t\t\t\t  }\n\n\t\t// Disable pre-generated write cache if requested. Will allocate buffers on-the-fly instead. WARNING: This can affect write performance\n\t\tif (!this.options.writeCache) {\n\t\t\tmqttPacket.writeToStream.cacheNumbers = false\n\t\t}\n\n\t\tthis.streamBuilder = streamBuilder\n\n\t\tthis.messageIdProvider =\n\t\t\ttypeof this.options.messageIdProvider === 'undefined'\n\t\t\t\t? new DefaultMessageIdProvider()\n\t\t\t\t: this.options.messageIdProvider\n\n\t\t// Inflight message storages\n\t\tthis.outgoingStore = options.outgoingStore || new Store()\n\t\tthis.incomingStore = options.incomingStore || new Store()\n\n\t\t// Should QoS zero messages be queued when the connection is broken?\n\t\tthis.queueQoSZero =\n\t\t\toptions.queueQoSZero === undefined ? true : options.queueQoSZero\n\n\t\t// map of subscribed topics to support reconnection\n\t\tthis._resubscribeTopics = {}\n\n\t\t// map of a subscribe messageId and a topic\n\t\tthis.messageIdToTopic = {}\n\n\t\t// Ping timer, setup in _setupPingTimer\n\t\tthis.pingTimer = null\n\t\t// Is the client connected?\n\t\tthis.connected = false\n\t\t// Are we disconnecting?\n\t\tthis.disconnecting = false\n\t\t// Are we reconnecting?\n\t\tthis.reconnecting = false\n\t\t// Packet queue\n\t\tthis.queue = []\n\t\t// connack timer\n\t\tthis.connackTimer = null\n\t\t// Reconnect timer\n\t\tthis.reconnectTimer = null\n\t\t// Is processing store?\n\t\tthis._storeProcessing = false\n\t\t// Packet Ids are put into the store during store processing\n\t\tthis._packetIdsDuringStoreProcessing = {}\n\t\t// Store processing queue\n\t\tthis._storeProcessingQueue = []\n\n\t\t// Inflight callbacks\n\t\tthis.outgoing = {}\n\n\t\t// True if connection is first time.\n\t\tthis._firstConnection = true\n\n\t\tif (options.properties && options.properties.topicAliasMaximum > 0) {\n\t\t\tif (options.properties.topicAliasMaximum > 0xffff) {\n\t\t\t\tthis.log(\n\t\t\t\t\t'MqttClient :: options.properties.topicAliasMaximum is out of range',\n\t\t\t\t)\n\t\t\t} else {\n\t\t\t\tthis.topicAliasRecv = new TopicAliasRecv(\n\t\t\t\t\toptions.properties.topicAliasMaximum,\n\t\t\t\t)\n\t\t\t}\n\t\t}\n\n\t\t// Send queued packets\n\t\tthis.on('connect', () => {\n\t\t\tconst { queue } = this\n\n\t\t\tconst deliver = () => {\n\t\t\t\tconst entry = queue.shift()\n\t\t\t\tthis.log('deliver :: entry %o', entry)\n\t\t\t\tlet packet = null\n\n\t\t\t\tif (!entry) {\n\t\t\t\t\tthis._resubscribe()\n\t\t\t\t\treturn\n\t\t\t\t}\n\n\t\t\t\tpacket = entry.packet\n\t\t\t\tthis.log('deliver :: call _sendPacket for %o', packet)\n\t\t\t\tlet send = true\n\t\t\t\tif (packet.messageId && packet.messageId !== 0) {\n\t\t\t\t\tif (!this.messageIdProvider.register(packet.messageId)) {\n\t\t\t\t\t\tsend = false\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (send) {\n\t\t\t\t\tthis._sendPacket(packet, (err) => {\n\t\t\t\t\t\tif (entry.cb) {\n\t\t\t\t\t\t\tentry.cb(err)\n\t\t\t\t\t\t}\n\t\t\t\t\t\tdeliver()\n\t\t\t\t\t})\n\t\t\t\t} else {\n\t\t\t\t\tthis.log(\n\t\t\t\t\t\t'messageId: %d has already used. The message is skipped and removed.',\n\t\t\t\t\t\tpacket.messageId,\n\t\t\t\t\t)\n\t\t\t\t\tdeliver()\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis.log('connect :: sending queued packets')\n\t\t\tdeliver()\n\t\t})\n\n\t\tthis.on('close', () => {\n\t\t\tthis.log('close :: connected set to `false`')\n\t\t\tthis.connected = false\n\n\t\t\tthis.log('close :: clearing connackTimer')\n\t\t\tclearTimeout(this.connackTimer)\n\n\t\t\tthis.log('close :: clearing ping timer')\n\t\t\tif (this.pingTimer !== null) {\n\t\t\t\tthis.pingTimer.clear()\n\t\t\t\tthis.pingTimer = null\n\t\t\t}\n\n\t\t\tif (this.topicAliasRecv) {\n\t\t\t\tthis.topicAliasRecv.clear()\n\t\t\t}\n\n\t\t\tthis.log('close :: calling _setupReconnect')\n\t\t\tthis._setupReconnect()\n\t\t})\n\n\t\tif (!this.options.manualConnect) {\n\t\t\tthis.log('MqttClient :: setting up stream')\n\t\t\tthis.connect()\n\t\t}\n\t}\n\n\t/**\n\t * @param packet the packet received by the broker\n\t * @return the auth packet to be returned to the broker\n\t * @api public\n\t */\n\tpublic handleAuth(packet: IAuthPacket, callback: PacketCallback) {\n\t\tcallback()\n\t}\n\n\t/**\n\t * Handle messages with backpressure support, one at a time.\n\t * Override at will.\n\t *\n\t * @param Packet packet the packet\n\t * @param Function callback call when finished\n\t * @api public\n\t */\n\tpublic handleMessage(packet: IPublishPacket, callback: DoneCallback) {\n\t\tcallback()\n\t}\n\n\t/**\n\t * _nextId\n\t * @return unsigned int\n\t */\n\tprivate _nextId() {\n\t\treturn this.messageIdProvider.allocate()\n\t}\n\n\t/**\n\t * getLastMessageId\n\t * @return unsigned int\n\t */\n\tpublic getLastMessageId() {\n\t\treturn this.messageIdProvider.getLastAllocated()\n\t}\n\n\t/**\n\t * Setup the event handlers in the inner stream, sends `connect` and `auth` packets\n\t */\n\tpublic connect() {\n\t\tconst writable = new Writable()\n\t\tconst parser = mqttPacket.parser(this.options)\n\t\tlet completeParse = null\n\t\tconst packets = []\n\n\t\tthis.log('connect :: calling method to clear reconnect')\n\t\tthis._clearReconnect()\n\n\t\tthis.log(\n\t\t\t'connect :: using streamBuilder provided to client to create stream',\n\t\t)\n\t\tthis.stream = this.streamBuilder(this)\n\n\t\tparser.on('packet', (packet) => {\n\t\t\tthis.log('parser :: on packet push to packets array.')\n\t\t\tpackets.push(packet)\n\t\t})\n\n\t\tconst work = () => {\n\t\t\tthis.log('work :: getting next packet in queue')\n\t\t\tconst packet = packets.shift()\n\n\t\t\tif (packet) {\n\t\t\t\tthis.log('work :: packet pulled from queue')\n\t\t\t\thandlePacket(this, packet, nextTickWork)\n\t\t\t} else {\n\t\t\t\tthis.log('work :: no packets in queue')\n\t\t\t\tconst done = completeParse\n\t\t\t\tcompleteParse = null\n\t\t\t\tthis.log('work :: done flag is %s', !!done)\n\t\t\t\tif (done) done()\n\t\t\t}\n\t\t}\n\n\t\tconst nextTickWork = () => {\n\t\t\tif (packets.length) {\n\t\t\t\tnextTick(work)\n\t\t\t} else {\n\t\t\t\tconst done = completeParse\n\t\t\t\tcompleteParse = null\n\t\t\t\tdone()\n\t\t\t}\n\t\t}\n\n\t\twritable._write = (buf, enc, done) => {\n\t\t\tcompleteParse = done\n\t\t\tthis.log('writable stream :: parsing buffer')\n\t\t\tparser.parse(buf)\n\t\t\twork()\n\t\t}\n\n\t\tconst streamErrorHandler = (error) => {\n\t\t\tthis.log('streamErrorHandler :: error', error.message)\n\t\t\tif (socketErrors.includes(error.code)) {\n\t\t\t\t// handle error\n\t\t\t\tthis.log('streamErrorHandler :: emitting error')\n\t\t\t\tthis.emit('error', error)\n\t\t\t} else {\n\t\t\t\tthis.noop(error)\n\t\t\t}\n\t\t}\n\n\t\tthis.log('connect :: pipe stream to writable stream')\n\t\tthis.stream.pipe(writable)\n\n\t\t// Suppress connection errors\n\t\tthis.stream.on('error', streamErrorHandler)\n\n\t\t// Echo stream close\n\t\tthis.stream.on('close', () => {\n\t\t\tthis.log('(%s)stream :: on close', this.options.clientId)\n\t\t\tthis._flushVolatile()\n\t\t\tthis.log('stream: emit close to MqttClient')\n\t\t\tthis.emit('close')\n\t\t})\n\n\t\t// Send a connect packet\n\t\tthis.log('connect: sending packet `connect`')\n\n\t\tconst connectPacket: IConnectPacket = {\n\t\t\tcmd: 'connect',\n\t\t\tprotocolId: this.options.protocolId,\n\t\t\tprotocolVersion: this.options.protocolVersion,\n\t\t\tclean: this.options.clean,\n\t\t\tclientId: this.options.clientId,\n\t\t\tkeepalive: this.options.keepalive,\n\t\t\tusername: this.options.username,\n\t\t\tpassword: this.options.password as Buffer,\n\t\t\tproperties: this.options.properties,\n\t\t}\n\n\t\tif (this.options.will) {\n\t\t\tconnectPacket.will = {\n\t\t\t\t...this.options.will,\n\t\t\t\tpayload: this.options.will?.payload as Buffer,\n\t\t\t}\n\t\t}\n\n\t\tif (this.topicAliasRecv) {\n\t\t\tif (!connectPacket.properties) {\n\t\t\t\tconnectPacket.properties = {}\n\t\t\t}\n\t\t\tif (this.topicAliasRecv) {\n\t\t\t\tconnectPacket.properties.topicAliasMaximum =\n\t\t\t\t\tthis.topicAliasRecv.max\n\t\t\t}\n\t\t}\n\t\t// avoid message queue\n\t\tthis._writePacket(connectPacket)\n\n\t\t// Echo connection errors\n\t\tparser.on('error', this.emit.bind(this, 'error'))\n\n\t\t// auth\n\t\tif (this.options.properties) {\n\t\t\tif (\n\t\t\t\t!this.options.properties.authenticationMethod &&\n\t\t\t\tthis.options.properties.authenticationData\n\t\t\t) {\n\t\t\t\tthis.end(() =>\n\t\t\t\t\tthis.emit(\n\t\t\t\t\t\t'error',\n\t\t\t\t\t\tnew Error('Packet has no Authentication Method'),\n\t\t\t\t\t),\n\t\t\t\t)\n\t\t\t\treturn this\n\t\t\t}\n\t\t\tif (\n\t\t\t\tthis.options.properties.authenticationMethod &&\n\t\t\t\tthis.options.authPacket &&\n\t\t\t\ttypeof this.options.authPacket === 'object'\n\t\t\t) {\n\t\t\t\tconst authPacket: IAuthPacket = {\n\t\t\t\t\tcmd: 'auth',\n\t\t\t\t\treasonCode: 0,\n\t\t\t\t\t...this.options.authPacket,\n\t\t\t\t}\n\t\t\t\tthis._writePacket(authPacket)\n\t\t\t}\n\t\t}\n\n\t\t// many drain listeners are needed for qos 1 callbacks if the connection is intermittent\n\t\tthis.stream.setMaxListeners(1000)\n\n\t\tclearTimeout(this.connackTimer)\n\t\tthis.connackTimer = setTimeout(() => {\n\t\t\tthis.log(\n\t\t\t\t'!!connectTimeout hit!! Calling _cleanUp with force `true`',\n\t\t\t)\n\t\t\tthis._cleanUp(true)\n\t\t}, this.options.connectTimeout)\n\n\t\treturn this\n\t}\n\n\t/**\n\t * publish - publish <message> to <topic>\n\t *\n\t * @param {String} topic - topic to publish to\n\t * @param {String, Buffer} message - message to publish\n\t * @param {Object} [opts] - publish options, includes:\n\t *    {Number} qos - qos level to publish on\n\t *    {Boolean} retain - whether or not to retain the message\n\t *    {Boolean} dup - whether or not mark a message as duplicate\n\t *    {Function} cbStorePut - function(){} called when message is put into `outgoingStore`\n\t * @param {Function} [callback] - function(err){}\n\t *    called when publish succeeds or fails\n\t * @returns {MqttClient} this - for chaining\n\t * @api public\n\t *\n\t * @example client.publish('topic', 'message');\n\t * @example\n\t *     client.publish('topic', 'message', {qos: 1, retain: true, dup: true});\n\t * @example client.publish('topic', 'message', console.log);\n\t */\n\tpublic publish(topic: string, message: string | Buffer): MqttClient\n\tpublic publish(\n\t\ttopic: string,\n\t\tmessage: string | Buffer,\n\t\tcallback?: PacketCallback,\n\t): MqttClient\n\tpublic publish(\n\t\ttopic: string,\n\t\tmessage: string | Buffer,\n\t\topts?: IClientPublishOptions,\n\t\tcallback?: PacketCallback,\n\t): MqttClient\n\tpublic publish(\n\t\ttopic: string,\n\t\tmessage: string | Buffer,\n\t\topts?: IClientPublishOptions | DoneCallback,\n\t\tcallback?: PacketCallback,\n\t): MqttClient {\n\t\tthis.log('publish :: message `%s` to topic `%s`', message, topic)\n\t\tconst { options } = this\n\n\t\t// .publish(topic, payload, cb);\n\t\tif (typeof opts === 'function') {\n\t\t\tcallback = opts as DoneCallback\n\t\t\topts = null\n\t\t}\n\n\t\topts = opts || {}\n\n\t\t// default opts\n\t\tconst defaultOpts: IClientPublishOptions = {\n\t\t\tqos: 0,\n\t\t\tretain: false,\n\t\t\tdup: false,\n\t\t}\n\t\topts = { ...defaultOpts, ...opts }\n\n\t\tconst { qos, retain, dup, properties, cbStorePut } = opts\n\n\t\tif (this._checkDisconnecting(callback)) {\n\t\t\treturn this\n\t\t}\n\n\t\tconst publishProc = () => {\n\t\t\tlet messageId = 0\n\t\t\tif (qos === 1 || qos === 2) {\n\t\t\t\tmessageId = this._nextId()\n\t\t\t\tif (messageId === null) {\n\t\t\t\t\tthis.log('No messageId left')\n\t\t\t\t\treturn false\n\t\t\t\t}\n\t\t\t}\n\t\t\tconst packet: IPublishPacket = {\n\t\t\t\tcmd: 'publish',\n\t\t\t\ttopic,\n\t\t\t\tpayload: message,\n\t\t\t\tqos,\n\t\t\t\tretain,\n\t\t\t\tmessageId,\n\t\t\t\tdup,\n\t\t\t}\n\n\t\t\tif (options.protocolVersion === 5) {\n\t\t\t\tpacket.properties = properties\n\t\t\t}\n\n\t\t\tthis.log('publish :: qos', qos)\n\t\t\tswitch (qos) {\n\t\t\t\tcase 1:\n\t\t\t\tcase 2:\n\t\t\t\t\t// Add to callbacks\n\t\t\t\t\tthis.outgoing[packet.messageId] = {\n\t\t\t\t\t\tvolatile: false,\n\t\t\t\t\t\tcb: callback || this.noop,\n\t\t\t\t\t}\n\t\t\t\t\tthis.log('MqttClient:publish: packet cmd: %s', packet.cmd)\n\t\t\t\t\tthis._sendPacket(packet, undefined, cbStorePut)\n\t\t\t\t\tbreak\n\t\t\t\tdefault:\n\t\t\t\t\tthis.log('MqttClient:publish: packet cmd: %s', packet.cmd)\n\t\t\t\t\tthis._sendPacket(packet, callback, cbStorePut)\n\t\t\t\t\tbreak\n\t\t\t}\n\t\t\treturn true\n\t\t}\n\n\t\tif (\n\t\t\tthis._storeProcessing ||\n\t\t\tthis._storeProcessingQueue.length > 0 ||\n\t\t\t!publishProc()\n\t\t) {\n\t\t\tthis._storeProcessingQueue.push({\n\t\t\t\tinvoke: publishProc,\n\t\t\t\tcbStorePut: opts.cbStorePut,\n\t\t\t\tcallback,\n\t\t\t})\n\t\t}\n\n\t\treturn this\n\t}\n\n\tpublic publishAsync(\n\t\ttopic: string,\n\t\tmessage: string | Buffer,\n\t): Promise<Packet | undefined>\n\tpublic publishAsync(\n\t\ttopic: string,\n\t\tmessage: string | Buffer,\n\t\topts?: IClientPublishOptions,\n\t): Promise<Packet | undefined>\n\tpublic publishAsync(\n\t\ttopic: string,\n\t\tmessage: string | Buffer,\n\t\topts?: IClientPublishOptions,\n\t): Promise<Packet | undefined> {\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tthis.publish(topic, message, opts, (err, packet) => {\n\t\t\t\tif (err) {\n\t\t\t\t\treject(err)\n\t\t\t\t} else {\n\t\t\t\t\tresolve(packet)\n\t\t\t\t}\n\t\t\t})\n\t\t})\n\t}\n\n\t/**\n\t * subscribe - subscribe to <topic>\n\t *\n\t * @param {String, Array, Object} topic - topic(s) to subscribe to, supports objects in the form {'topic': qos}\n\t * @param {Object} [opts] - optional subscription options, includes:\n\t *    {Number} qos - subscribe qos level\n\t * @param {Function} [callback] - function(err, granted){} where:\n\t *    {Error} err - subscription error (none at the moment!)\n\t *    {Array} granted - array of {topic: 't', qos: 0}\n\t * @returns {MqttClient} this - for chaining\n\t * @api public\n\t * @example client.subscribe('topic');\n\t * @example client.subscribe('topic', {qos: 1});\n\t * @example client.subscribe({'topic': {qos: 0}, 'topic2': {qos: 1}}, console.log);\n\t * @example client.subscribe('topic', console.log);\n\t */\n\tpublic subscribe(\n\t\ttopicObject: string | string[] | ISubscriptionMap,\n\t): MqttClient\n\tpublic subscribe(\n\t\ttopicObject: string | string[] | ISubscriptionMap,\n\t\tcallback?: ClientSubscribeCallback,\n\t): MqttClient\n\tpublic subscribe(\n\t\ttopicObject: string | string[] | ISubscriptionMap,\n\t\topts?: IClientSubscribeOptions | IClientSubscribeProperties,\n\t): MqttClient\n\tpublic subscribe(\n\t\ttopicObject: string | string[] | ISubscriptionMap,\n\t\topts?: IClientSubscribeOptions | IClientSubscribeProperties,\n\t\tcallback?: ClientSubscribeCallback,\n\t): MqttClient\n\tpublic subscribe(\n\t\ttopicObject: string | string[] | ISubscriptionMap,\n\t\topts?:\n\t\t\t| IClientSubscribeOptions\n\t\t\t| IClientSubscribeProperties\n\t\t\t| ClientSubscribeCallback,\n\t\tcallback?: ClientSubscribeCallback,\n\t): MqttClient {\n\t\tconst version = this.options.protocolVersion\n\n\t\tif (typeof opts === 'function') {\n\t\t\tcallback = opts\n\t\t}\n\n\t\tcallback = callback || this.noop\n\n\t\t// force re-subscribe on reconnect. This is only true\n\t\t// when provided `topicObject` is `this._resubscribeTopics`\n\t\tlet resubscribe = false\n\t\tlet topicsList = []\n\n\t\tif (typeof topicObject === 'string') {\n\t\t\ttopicObject = [topicObject]\n\t\t\ttopicsList = topicObject\n\t\t} else if (Array.isArray(topicObject)) {\n\t\t\ttopicsList = topicObject\n\t\t} else if (typeof topicObject === 'object') {\n\t\t\tresubscribe = topicObject.resubscribe\n\t\t\tdelete topicObject.resubscribe\n\t\t\ttopicsList = Object.keys(topicObject)\n\t\t}\n\n\t\t// validate topics\n\t\tconst invalidTopic = validations.validateTopics(topicsList)\n\t\tif (invalidTopic !== null) {\n\t\t\tsetImmediate(callback, new Error(`Invalid topic ${invalidTopic}`))\n\t\t\treturn this\n\t\t}\n\n\t\tif (this._checkDisconnecting(callback)) {\n\t\t\tthis.log('subscribe: discconecting true')\n\t\t\treturn this\n\t\t}\n\n\t\tconst defaultOpts: Partial<IClientSubscribeOptions> = {\n\t\t\tqos: 0,\n\t\t}\n\n\t\tif (version === 5) {\n\t\t\tdefaultOpts.nl = false\n\t\t\tdefaultOpts.rap = false\n\t\t\tdefaultOpts.rh = 0\n\t\t}\n\t\topts = { ...defaultOpts, ...opts } as IClientSubscribeOptions\n\n\t\tconst properties = opts.properties\n\n\t\tconst subs: ISubscriptionRequest[] = []\n\n\t\tconst parseSub = (\n\t\t\ttopic: string,\n\t\t\tsubOptions?: IClientSubscribeOptions,\n\t\t) => {\n\t\t\t// subOptions is defined only when providing a subs map, use opts otherwise\n\t\t\tsubOptions = (subOptions || opts) as IClientSubscribeOptions\n\t\t\tif (\n\t\t\t\t!Object.prototype.hasOwnProperty.call(\n\t\t\t\t\tthis._resubscribeTopics,\n\t\t\t\t\ttopic,\n\t\t\t\t) ||\n\t\t\t\tthis._resubscribeTopics[topic].qos < subOptions.qos ||\n\t\t\t\tresubscribe\n\t\t\t) {\n\t\t\t\tconst currentOpts: ISubscription & IClientSubscribeProperties =\n\t\t\t\t\t{\n\t\t\t\t\t\ttopic,\n\t\t\t\t\t\tqos: subOptions.qos,\n\t\t\t\t\t}\n\t\t\t\tif (version === 5) {\n\t\t\t\t\tcurrentOpts.nl = subOptions.nl\n\t\t\t\t\tcurrentOpts.rap = subOptions.rap\n\t\t\t\t\tcurrentOpts.rh = subOptions.rh\n\t\t\t\t\t// use opts.properties\n\t\t\t\t\tcurrentOpts.properties = properties\n\t\t\t\t}\n\t\t\t\tthis.log(\n\t\t\t\t\t'subscribe: pushing topic `%s` and qos `%s` to subs list',\n\t\t\t\t\tcurrentOpts.topic,\n\t\t\t\t\tcurrentOpts.qos,\n\t\t\t\t)\n\t\t\t\tsubs.push(currentOpts)\n\t\t\t}\n\t\t}\n\n\t\tif (Array.isArray(topicObject)) {\n\t\t\t// array of topics\n\t\t\ttopicObject.forEach((topic) => {\n\t\t\t\tthis.log('subscribe: array topic %s', topic)\n\t\t\t\tparseSub(topic)\n\t\t\t})\n\t\t} else {\n\t\t\t// object topic --> subOptions (no properties)\n\t\t\tObject.keys(topicObject).forEach((topic) => {\n\t\t\t\tthis.log(\n\t\t\t\t\t'subscribe: object topic %s, %o',\n\t\t\t\t\ttopic,\n\t\t\t\t\ttopicObject[topic],\n\t\t\t\t)\n\t\t\t\tparseSub(topic, topicObject[topic])\n\t\t\t})\n\t\t}\n\n\t\tif (!subs.length) {\n\t\t\tcallback(null, [])\n\t\t\treturn this\n\t\t}\n\n\t\tconst subscribeProc = () => {\n\t\t\tconst messageId = this._nextId()\n\t\t\tif (messageId === null) {\n\t\t\t\tthis.log('No messageId left')\n\t\t\t\treturn false\n\t\t\t}\n\n\t\t\tconst packet: ISubscribePacket = {\n\t\t\t\tcmd: 'subscribe',\n\t\t\t\tsubscriptions: subs,\n\t\t\t\t// qos: 1,\n\t\t\t\t// retain: false,\n\t\t\t\t// dup: false,\n\t\t\t\tmessageId,\n\t\t\t}\n\n\t\t\tif (properties) {\n\t\t\t\tpacket.properties = properties\n\t\t\t}\n\n\t\t\t// subscriptions to resubscribe to in case of disconnect\n\t\t\tif (this.options.resubscribe) {\n\t\t\t\tthis.log('subscribe :: resubscribe true')\n\t\t\t\tconst topics = []\n\t\t\t\tsubs.forEach((sub) => {\n\t\t\t\t\tif (this.options.reconnectPeriod > 0) {\n\t\t\t\t\t\tconst topic: IClientSubscribeOptions = { qos: sub.qos }\n\t\t\t\t\t\tif (version === 5) {\n\t\t\t\t\t\t\ttopic.nl = sub.nl || false\n\t\t\t\t\t\t\ttopic.rap = sub.rap || false\n\t\t\t\t\t\t\ttopic.rh = sub.rh || 0\n\t\t\t\t\t\t\ttopic.properties = sub.properties\n\t\t\t\t\t\t}\n\t\t\t\t\t\tthis._resubscribeTopics[sub.topic] = topic\n\t\t\t\t\t\ttopics.push(sub.topic)\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t\tthis.messageIdToTopic[packet.messageId] = topics\n\t\t\t}\n\n\t\t\tthis.outgoing[packet.messageId] = {\n\t\t\t\tvolatile: true,\n\t\t\t\tcb(err, packet2: ISubackPacket) {\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tconst { granted } = packet2\n\t\t\t\t\t\tfor (let i = 0; i < granted.length; i += 1) {\n\t\t\t\t\t\t\tsubs[i].qos = granted[i] as QoS\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tcallback(err, subs)\n\t\t\t\t},\n\t\t\t}\n\t\t\tthis.log('subscribe :: call _sendPacket')\n\t\t\tthis._sendPacket(packet)\n\t\t\treturn true\n\t\t}\n\n\t\tif (\n\t\t\tthis._storeProcessing ||\n\t\t\tthis._storeProcessingQueue.length > 0 ||\n\t\t\t!subscribeProc()\n\t\t) {\n\t\t\tthis._storeProcessingQueue.push({\n\t\t\t\tinvoke: subscribeProc,\n\t\t\t\tcallback,\n\t\t\t})\n\t\t}\n\n\t\treturn this\n\t}\n\n\tpublic subscribeAsync(\n\t\ttopicObject: string | string[] | ISubscriptionMap,\n\t): Promise<ISubscriptionGrant[]>\n\tpublic subscribeAsync(\n\t\ttopicObject: string | string[] | ISubscriptionMap,\n\t\topts?: IClientSubscribeOptions | IClientSubscribeProperties,\n\t): Promise<ISubscriptionGrant[]>\n\tpublic subscribeAsync(\n\t\ttopicObject: string | string[] | ISubscriptionMap,\n\t\topts?: IClientSubscribeOptions | IClientSubscribeProperties,\n\t): Promise<ISubscriptionGrant[]> {\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tthis.subscribe(topicObject, opts, (err, granted) => {\n\t\t\t\tif (err) {\n\t\t\t\t\treject(err)\n\t\t\t\t} else {\n\t\t\t\t\tresolve(granted)\n\t\t\t\t}\n\t\t\t})\n\t\t})\n\t}\n\n\t/**\n\t * unsubscribe - unsubscribe from topic(s)\n\t *\n\t * @param {String, Array} topic - topics to unsubscribe from\n\t * @param {Object} [opts] - optional subscription options, includes:\n\t *    {Object} properties - properties of unsubscribe packet\n\t * @param {Function} [callback] - callback fired on unsuback\n\t * @returns {MqttClient} this - for chaining\n\t * @api public\n\t * @example client.unsubscribe('topic');\n\t * @example client.unsubscribe('topic', console.log);\n\t */\n\tpublic unsubscribe(topic: string | string[]): MqttClient\n\tpublic unsubscribe(\n\t\ttopic: string | string[],\n\t\topts?: IClientSubscribeOptions,\n\t): MqttClient\n\tpublic unsubscribe(\n\t\ttopic: string | string[],\n\t\tcallback?: PacketCallback,\n\t): MqttClient\n\tpublic unsubscribe(\n\t\ttopic: string | string[],\n\t\topts?: IClientSubscribeOptions,\n\t\tcallback?: PacketCallback,\n\t): MqttClient\n\tpublic unsubscribe(\n\t\ttopic: string | string[],\n\t\topts?: IClientSubscribeOptions | PacketCallback,\n\t\tcallback?: PacketCallback,\n\t): MqttClient {\n\t\tif (typeof topic === 'string') {\n\t\t\ttopic = [topic]\n\t\t}\n\n\t\tif (typeof opts === 'function') {\n\t\t\tcallback = opts\n\t\t}\n\n\t\tcallback = callback || this.noop\n\n\t\tconst invalidTopic = validations.validateTopics(topic)\n\t\tif (invalidTopic !== null) {\n\t\t\tsetImmediate(callback, new Error(`Invalid topic ${invalidTopic}`))\n\t\t\treturn this\n\t\t}\n\n\t\tif (this._checkDisconnecting(callback)) {\n\t\t\treturn this\n\t\t}\n\n\t\tconst unsubscribeProc = () => {\n\t\t\tconst messageId = this._nextId()\n\t\t\tif (messageId === null) {\n\t\t\t\tthis.log('No messageId left')\n\t\t\t\treturn false\n\t\t\t}\n\t\t\tconst packet: IUnsubscribePacket = {\n\t\t\t\tcmd: 'unsubscribe',\n\t\t\t\t// qos: 1,\n\t\t\t\tmessageId,\n\t\t\t\tunsubscriptions: [],\n\t\t\t}\n\n\t\t\tif (typeof topic === 'string') {\n\t\t\t\tpacket.unsubscriptions = [topic]\n\t\t\t} else if (Array.isArray(topic)) {\n\t\t\t\tpacket.unsubscriptions = topic\n\t\t\t}\n\n\t\t\tif (this.options.resubscribe) {\n\t\t\t\tpacket.unsubscriptions.forEach((topic2) => {\n\t\t\t\t\tdelete this._resubscribeTopics[topic2]\n\t\t\t\t})\n\t\t\t}\n\n\t\t\tif (typeof opts === 'object' && opts.properties) {\n\t\t\t\tpacket.properties = opts.properties\n\t\t\t}\n\n\t\t\tthis.outgoing[packet.messageId] = {\n\t\t\t\tvolatile: true,\n\t\t\t\tcb: callback,\n\t\t\t}\n\n\t\t\tthis.log('unsubscribe: call _sendPacket')\n\t\t\tthis._sendPacket(packet)\n\n\t\t\treturn true\n\t\t}\n\n\t\tif (\n\t\t\tthis._storeProcessing ||\n\t\t\tthis._storeProcessingQueue.length > 0 ||\n\t\t\t!unsubscribeProc()\n\t\t) {\n\t\t\tthis._storeProcessingQueue.push({\n\t\t\t\tinvoke: unsubscribeProc,\n\t\t\t\tcallback,\n\t\t\t})\n\t\t}\n\n\t\treturn this\n\t}\n\n\tpublic unsubscribeAsync(\n\t\ttopic: string | string[],\n\t): Promise<Packet | undefined>\n\tpublic unsubscribeAsync(\n\t\ttopic: string | string[],\n\t\topts?: IClientSubscribeOptions,\n\t): Promise<Packet | undefined>\n\tpublic unsubscribeAsync(\n\t\ttopic: string | string[],\n\t\topts?: IClientSubscribeOptions,\n\t): Promise<Packet | undefined> {\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tthis.unsubscribe(topic, opts, (err, packet) => {\n\t\t\t\tif (err) {\n\t\t\t\t\treject(err)\n\t\t\t\t} else {\n\t\t\t\t\tresolve(packet)\n\t\t\t\t}\n\t\t\t})\n\t\t})\n\t}\n\n\t/**\n\t * end - close connection\n\t *\n\t * @returns {MqttClient} this - for chaining\n\t * @param {Boolean} force - do not wait for all in-flight messages to be acked\n\t * @param {Object} opts - added to the disconnect packet\n\t * @param {Function} cb - called when the client has been closed\n\t *\n\t * @api public\n\t */\n\tpublic end(cb?: DoneCallback): MqttClient\n\tpublic end(force?: boolean): MqttClient\n\tpublic end(opts?: Partial<IDisconnectPacket>, cb?: DoneCallback): MqttClient\n\tpublic end(force?: boolean, cb?: DoneCallback): MqttClient\n\tpublic end(\n\t\tforce?: boolean,\n\t\topts?: Partial<IDisconnectPacket>,\n\t\tcb?: DoneCallback,\n\t): MqttClient\n\tpublic end(\n\t\tforce?: boolean | Partial<IDisconnectPacket> | DoneCallback,\n\t\topts?: Partial<IDisconnectPacket> | DoneCallback,\n\t\tcb?: DoneCallback,\n\t): MqttClient {\n\t\tthis.log('end :: (%s)', this.options.clientId)\n\n\t\tif (force == null || typeof force !== 'boolean') {\n\t\t\tcb = cb || (opts as DoneCallback)\n\t\t\topts = force as Partial<IDisconnectPacket>\n\t\t\tforce = false\n\t\t}\n\n\t\tif (typeof opts !== 'object') {\n\t\t\tcb = cb || opts\n\t\t\topts = null\n\t\t}\n\n\t\tthis.log('end :: cb? %s', !!cb)\n\n\t\tif (!cb || typeof cb !== 'function') {\n\t\t\tcb = this.noop\n\t\t}\n\n\t\tconst closeStores = () => {\n\t\t\tthis.log('end :: closeStores: closing incoming and outgoing stores')\n\t\t\tthis.disconnected = true\n\t\t\tthis.incomingStore.close((e1) => {\n\t\t\t\tthis.outgoingStore.close((e2) => {\n\t\t\t\t\tthis.log('end :: closeStores: emitting end')\n\t\t\t\t\tthis.emit('end')\n\t\t\t\t\tif (cb) {\n\t\t\t\t\t\tconst err = e1 || e2\n\t\t\t\t\t\tthis.log(\n\t\t\t\t\t\t\t'end :: closeStores: invoking callback with args',\n\t\t\t\t\t\t)\n\t\t\t\t\t\tcb(err)\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t})\n\t\t\tif (this._deferredReconnect) {\n\t\t\t\tthis._deferredReconnect()\n\t\t\t}\n\t\t}\n\n\t\tconst finish = () => {\n\t\t\t// defer closesStores of an I/O cycle,\n\t\t\t// just to make sure things are\n\t\t\t// ok for websockets\n\t\t\tthis.log(\n\t\t\t\t'end :: (%s) :: finish :: calling _cleanUp with force %s',\n\t\t\t\tthis.options.clientId,\n\t\t\t\tforce,\n\t\t\t)\n\t\t\tthis._cleanUp(\n\t\t\t\t<boolean>force,\n\t\t\t\t() => {\n\t\t\t\t\tthis.log(\n\t\t\t\t\t\t'end :: finish :: calling process.nextTick on closeStores',\n\t\t\t\t\t)\n\t\t\t\t\t// const boundProcess = nextTick.bind(null, closeStores)\n\t\t\t\t\tnextTick(closeStores)\n\t\t\t\t},\n\t\t\t\topts,\n\t\t\t)\n\t\t}\n\n\t\tif (this.disconnecting) {\n\t\t\tcb()\n\t\t\treturn this\n\t\t}\n\n\t\tthis._clearReconnect()\n\n\t\tthis.disconnecting = true\n\n\t\tif (!force && Object.keys(this.outgoing).length > 0) {\n\t\t\t// wait 10ms, just to be sure we received all of it\n\t\t\tthis.log(\n\t\t\t\t'end :: (%s) :: calling finish in 10ms once outgoing is empty',\n\t\t\t\tthis.options.clientId,\n\t\t\t)\n\t\t\tthis.once('outgoingEmpty', setTimeout.bind(null, finish, 10))\n\t\t} else {\n\t\t\tthis.log(\n\t\t\t\t'end :: (%s) :: immediately calling finish',\n\t\t\t\tthis.options.clientId,\n\t\t\t)\n\t\t\tfinish()\n\t\t}\n\n\t\treturn this\n\t}\n\n\tpublic endAsync(): Promise<void>\n\tpublic endAsync(force?: boolean): Promise<void>\n\tpublic endAsync(opts?: Partial<IDisconnectPacket>): Promise<void>\n\tpublic endAsync(\n\t\tforce?: boolean,\n\t\topts?: Partial<IDisconnectPacket>,\n\t): Promise<void>\n\tpublic endAsync(\n\t\tforce?: boolean | Partial<IDisconnectPacket>,\n\t\topts?: Partial<IDisconnectPacket>,\n\t): Promise<void> {\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tthis.end(force as boolean, opts, (err) => {\n\t\t\t\tif (err) {\n\t\t\t\t\treject(err)\n\t\t\t\t} else {\n\t\t\t\t\tresolve()\n\t\t\t\t}\n\t\t\t})\n\t\t})\n\t}\n\n\t/**\n\t * removeOutgoingMessage - remove a message in outgoing store\n\t * the outgoing callback will be called withe Error('Message removed') if the message is removed\n\t *\n\t * @param {Number} messageId - messageId to remove message\n\t * @returns {MqttClient} this - for chaining\n\t * @api public\n\t *\n\t * @example client.removeOutgoingMessage(client.getLastAllocated());\n\t */\n\tpublic removeOutgoingMessage(messageId: number): MqttClient {\n\t\tif (this.outgoing[messageId]) {\n\t\t\tconst { cb } = this.outgoing[messageId]\n\t\t\tthis._removeOutgoingAndStoreMessage(messageId, () => {\n\t\t\t\tcb(new Error('Message removed'))\n\t\t\t})\n\t\t}\n\t\treturn this\n\t}\n\n\t/**\n\t * reconnect - connect again using the same options as connect()\n\t *\n\t * @param {Object} [opts] - optional reconnect options, includes:\n\t *    {Store} incomingStore - a store for the incoming packets\n\t *    {Store} outgoingStore - a store for the outgoing packets\n\t *    if opts is not given, current stores are used\n\t * @returns {MqttClient} this - for chaining\n\t *\n\t * @api public\n\t */\n\tpublic reconnect(\n\t\topts?: Pick<IClientOptions, 'incomingStore' | 'outgoingStore'>,\n\t): MqttClient {\n\t\tthis.log('client reconnect')\n\t\tconst f = () => {\n\t\t\tif (opts) {\n\t\t\t\tthis.options.incomingStore = opts.incomingStore\n\t\t\t\tthis.options.outgoingStore = opts.outgoingStore\n\t\t\t} else {\n\t\t\t\tthis.options.incomingStore = null\n\t\t\t\tthis.options.outgoingStore = null\n\t\t\t}\n\t\t\tthis.incomingStore = this.options.incomingStore || new Store()\n\t\t\tthis.outgoingStore = this.options.outgoingStore || new Store()\n\t\t\tthis.disconnecting = false\n\t\t\tthis.disconnected = false\n\t\t\tthis._deferredReconnect = null\n\t\t\tthis._reconnect()\n\t\t}\n\n\t\tif (this.disconnecting && !this.disconnected) {\n\t\t\tthis._deferredReconnect = f\n\t\t} else {\n\t\t\tf()\n\t\t}\n\t\treturn this\n\t}\n\n\t/**\n\t * PRIVATE METHODS\n\t * =====================\n\t * */\n\n\t/**\n\t * Flush all outgoing messages marked as `volatile` in `outgoing` queue. Volatile messages\n\t * typically are subscription and unsubscription requests.\n\t */\n\tprivate _flushVolatile() {\n\t\tif (this.outgoing) {\n\t\t\tthis.log(\n\t\t\t\t'_flushVolatile :: deleting volatile messages from the queue and setting their callbacks as error function',\n\t\t\t)\n\t\t\tObject.keys(this.outgoing).forEach((messageId) => {\n\t\t\t\tif (\n\t\t\t\t\tthis.outgoing[messageId].volatile &&\n\t\t\t\t\ttypeof this.outgoing[messageId].cb === 'function'\n\t\t\t\t) {\n\t\t\t\t\tthis.outgoing[messageId].cb(new Error('Connection closed'))\n\t\t\t\t\tdelete this.outgoing[messageId]\n\t\t\t\t}\n\t\t\t})\n\t\t}\n\t}\n\n\t/**\n\t * Flush all outgoing messages\n\t */\n\tprivate _flush() {\n\t\tif (this.outgoing) {\n\t\t\tthis.log('_flush: queue exists? %b', !!this.outgoing)\n\t\t\tObject.keys(this.outgoing).forEach((messageId) => {\n\t\t\t\tif (typeof this.outgoing[messageId].cb === 'function') {\n\t\t\t\t\tthis.outgoing[messageId].cb(new Error('Connection closed'))\n\t\t\t\t\t// This is suspicious.  Why do we only delete this if we have a callback?\n\t\t\t\t\t// If this is by-design, then adding no as callback would cause this to get deleted unintentionally.\n\t\t\t\t\tdelete this.outgoing[messageId]\n\t\t\t\t}\n\t\t\t})\n\t\t}\n\t}\n\n\tprivate _removeTopicAliasAndRecoverTopicName(packet: IPublishPacket) {\n\t\tlet alias: number | undefined\n\n\t\tif (packet.properties) {\n\t\t\talias = packet.properties.topicAlias\n\t\t}\n\n\t\tlet topic = packet.topic.toString()\n\n\t\tthis.log(\n\t\t\t'_removeTopicAliasAndRecoverTopicName :: alias %d, topic %o',\n\t\t\talias,\n\t\t\ttopic,\n\t\t)\n\n\t\tif (topic.length === 0) {\n\t\t\t// restore topic from alias\n\t\t\tif (typeof alias === 'undefined') {\n\t\t\t\treturn new Error('Unregistered Topic Alias')\n\t\t\t}\n\t\t\ttopic = this.topicAliasSend.getTopicByAlias(alias)\n\t\t\tif (typeof topic === 'undefined') {\n\t\t\t\treturn new Error('Unregistered Topic Alias')\n\t\t\t}\n\t\t\tpacket.topic = topic\n\t\t}\n\t\tif (alias) {\n\t\t\tdelete packet.properties.topicAlias\n\t\t}\n\t}\n\n\tprivate _checkDisconnecting(callback?: GenericCallback<any>) {\n\t\tif (this.disconnecting) {\n\t\t\tif (callback && callback !== this.noop) {\n\t\t\t\tcallback(new Error('client disconnecting'))\n\t\t\t} else {\n\t\t\t\tthis.emit('error', new Error('client disconnecting'))\n\t\t\t}\n\t\t}\n\t\treturn this.disconnecting\n\t}\n\n\t/**\n\t * _reconnect - implement reconnection\n\t * @api private\n\t */\n\tprivate _reconnect() {\n\t\tthis.log('_reconnect: emitting reconnect to client')\n\t\tthis.emit('reconnect')\n\t\tif (this.connected) {\n\t\t\tthis.end(() => {\n\t\t\t\tthis.connect()\n\t\t\t})\n\t\t\tthis.log('client already connected. disconnecting first.')\n\t\t} else {\n\t\t\tthis.log('_reconnect: calling connect')\n\t\t\tthis.connect()\n\t\t}\n\t}\n\n\t/**\n\t * _setupReconnect - setup reconnect timer\n\t */\n\tprivate _setupReconnect() {\n\t\tif (\n\t\t\t!this.disconnecting &&\n\t\t\t!this.reconnectTimer &&\n\t\t\tthis.options.reconnectPeriod > 0\n\t\t) {\n\t\t\tif (!this.reconnecting) {\n\t\t\t\tthis.log('_setupReconnect :: emit `offline` state')\n\t\t\t\tthis.emit('offline')\n\t\t\t\tthis.log('_setupReconnect :: set `reconnecting` to `true`')\n\t\t\t\tthis.reconnecting = true\n\t\t\t}\n\t\t\tthis.log(\n\t\t\t\t'_setupReconnect :: setting reconnectTimer for %d ms',\n\t\t\t\tthis.options.reconnectPeriod,\n\t\t\t)\n\t\t\tthis.reconnectTimer = setInterval(() => {\n\t\t\t\tthis.log('reconnectTimer :: reconnect triggered!')\n\t\t\t\tthis._reconnect()\n\t\t\t}, this.options.reconnectPeriod)\n\t\t} else {\n\t\t\tthis.log('_setupReconnect :: doing nothing...')\n\t\t}\n\t}\n\n\t/**\n\t * _clearReconnect - clear the reconnect timer\n\t */\n\tprivate _clearReconnect() {\n\t\tthis.log('_clearReconnect : clearing reconnect timer')\n\t\tif (this.reconnectTimer) {\n\t\t\tclearInterval(this.reconnectTimer)\n\t\t\tthis.reconnectTimer = null\n\t\t}\n\t}\n\n\t/**\n\t * _cleanUp - clean up on connection end\n\t * @api private\n\t */\n\tprivate _cleanUp(forced: boolean, done?: DoneCallback, opts = {}) {\n\t\tif (done) {\n\t\t\tthis.log('_cleanUp :: done callback provided for on stream close')\n\t\t\tthis.stream.on('close', done)\n\t\t}\n\n\t\tthis.log('_cleanUp :: forced? %s', forced)\n\t\tif (forced) {\n\t\t\tif (this.options.reconnectPeriod === 0 && this.options.clean) {\n\t\t\t\tthis._flush()\n\t\t\t}\n\t\t\tthis.log(\n\t\t\t\t'_cleanUp :: (%s) :: destroying stream',\n\t\t\t\tthis.options.clientId,\n\t\t\t)\n\t\t\tthis.stream.destroy()\n\t\t} else {\n\t\t\tconst packet: IDisconnectPacket = { cmd: 'disconnect', ...opts }\n\t\t\tthis.log(\n\t\t\t\t'_cleanUp :: (%s) :: call _sendPacket with disconnect packet',\n\t\t\t\tthis.options.clientId,\n\t\t\t)\n\t\t\tthis._sendPacket(packet, () => {\n\t\t\t\tthis.log(\n\t\t\t\t\t'_cleanUp :: (%s) :: destroying stream',\n\t\t\t\t\tthis.options.clientId,\n\t\t\t\t)\n\t\t\t\tsetImmediate(() => {\n\t\t\t\t\tthis.stream.end(() => {\n\t\t\t\t\t\tthis.log(\n\t\t\t\t\t\t\t'_cleanUp :: (%s) :: stream destroyed',\n\t\t\t\t\t\t\tthis.options.clientId,\n\t\t\t\t\t\t)\n\t\t\t\t\t\t// once stream is closed the 'close' event will fire and that will\n\t\t\t\t\t\t// emit client `close` event and call `done` callback if done is provided\n\t\t\t\t\t})\n\t\t\t\t})\n\t\t\t})\n\t\t}\n\n\t\tif (!this.disconnecting) {\n\t\t\tthis.log(\n\t\t\t\t'_cleanUp :: client not disconnecting. Clearing and resetting reconnect.',\n\t\t\t)\n\t\t\tthis._clearReconnect()\n\t\t\tthis._setupReconnect()\n\t\t}\n\n\t\tif (this.pingTimer !== null) {\n\t\t\tthis.log('_cleanUp :: clearing pingTimer')\n\t\t\tthis.pingTimer.clear()\n\t\t\tthis.pingTimer = null\n\t\t}\n\n\t\tif (done && !this.connected) {\n\t\t\tthis.log(\n\t\t\t\t'_cleanUp :: (%s) :: removing stream `done` callback `close` listener',\n\t\t\t\tthis.options.clientId,\n\t\t\t)\n\t\t\tthis.stream.removeListener('close', done)\n\t\t\tdone()\n\t\t}\n\t}\n\n\tprivate _storeAndSend(\n\t\tpacket: Packet,\n\t\tcb: DoneCallback,\n\t\tcbStorePut: DoneCallback,\n\t) {\n\t\tthis.log(\n\t\t\t'storeAndSend :: store packet with cmd %s to outgoingStore',\n\t\t\tpacket.cmd,\n\t\t)\n\t\tlet storePacket = packet\n\t\tlet err: Error | undefined\n\t\tif (storePacket.cmd === 'publish') {\n\t\t\t// The original packet is for sending.\n\t\t\t// The cloned storePacket is for storing to resend on reconnect.\n\t\t\t// Topic Alias must not be used after disconnected.\n\t\t\tstorePacket = clone(packet)\n\t\t\terr = this._removeTopicAliasAndRecoverTopicName(\n\t\t\t\tstorePacket as IPublishPacket,\n\t\t\t)\n\t\t\tif (err) {\n\t\t\t\treturn cb && cb(err)\n\t\t\t}\n\t\t}\n\t\tthis.outgoingStore.put(storePacket, (err2) => {\n\t\t\tif (err2) {\n\t\t\t\treturn cb && cb(err2)\n\t\t\t}\n\t\t\tcbStorePut()\n\t\t\tthis._writePacket(packet, cb)\n\t\t})\n\t}\n\n\tprivate _applyTopicAlias(packet: Packet) {\n\t\tif (this.options.protocolVersion === 5) {\n\t\t\tif (packet.cmd === 'publish') {\n\t\t\t\tlet alias: number\n\t\t\t\tif (packet.properties) {\n\t\t\t\t\talias = packet.properties.topicAlias\n\t\t\t\t}\n\t\t\t\tconst topic = packet.topic.toString()\n\t\t\t\tif (this.topicAliasSend) {\n\t\t\t\t\tif (alias) {\n\t\t\t\t\t\tif (topic.length !== 0) {\n\t\t\t\t\t\t\t// register topic alias\n\t\t\t\t\t\t\tthis.log(\n\t\t\t\t\t\t\t\t'applyTopicAlias :: register topic: %s - alias: %d',\n\t\t\t\t\t\t\t\ttopic,\n\t\t\t\t\t\t\t\talias,\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\tif (!this.topicAliasSend.put(topic, alias)) {\n\t\t\t\t\t\t\t\tthis.log(\n\t\t\t\t\t\t\t\t\t'applyTopicAlias :: error out of range. topic: %s - alias: %d',\n\t\t\t\t\t\t\t\t\ttopic,\n\t\t\t\t\t\t\t\t\talias,\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\treturn new Error(\n\t\t\t\t\t\t\t\t\t'Sending Topic Alias out of range',\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (topic.length !== 0) {\n\t\t\t\t\t\tif (this.options.autoAssignTopicAlias) {\n\t\t\t\t\t\t\talias = this.topicAliasSend.getAliasByTopic(topic)\n\t\t\t\t\t\t\tif (alias) {\n\t\t\t\t\t\t\t\tpacket.topic = ''\n\t\t\t\t\t\t\t\tpacket.properties = {\n\t\t\t\t\t\t\t\t\t...packet.properties,\n\t\t\t\t\t\t\t\t\ttopicAlias: alias,\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tthis.log(\n\t\t\t\t\t\t\t\t\t'applyTopicAlias :: auto assign(use) topic: %s - alias: %d',\n\t\t\t\t\t\t\t\t\ttopic,\n\t\t\t\t\t\t\t\t\talias,\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\talias = this.topicAliasSend.getLruAlias()\n\t\t\t\t\t\t\t\tthis.topicAliasSend.put(topic, alias)\n\t\t\t\t\t\t\t\tpacket.properties = {\n\t\t\t\t\t\t\t\t\t...packet.properties,\n\t\t\t\t\t\t\t\t\ttopicAlias: alias,\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tthis.log(\n\t\t\t\t\t\t\t\t\t'applyTopicAlias :: auto assign topic: %s - alias: %d',\n\t\t\t\t\t\t\t\t\ttopic,\n\t\t\t\t\t\t\t\t\talias,\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else if (this.options.autoUseTopicAlias) {\n\t\t\t\t\t\t\talias = this.topicAliasSend.getAliasByTopic(topic)\n\t\t\t\t\t\t\tif (alias) {\n\t\t\t\t\t\t\t\tpacket.topic = ''\n\t\t\t\t\t\t\t\tpacket.properties = {\n\t\t\t\t\t\t\t\t\t...packet.properties,\n\t\t\t\t\t\t\t\t\ttopicAlias: alias,\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tthis.log(\n\t\t\t\t\t\t\t\t\t'applyTopicAlias :: auto use topic: %s - alias: %d',\n\t\t\t\t\t\t\t\t\ttopic,\n\t\t\t\t\t\t\t\t\talias,\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else if (alias) {\n\t\t\t\t\tthis.log(\n\t\t\t\t\t\t'applyTopicAlias :: error out of range. topic: %s - alias: %d',\n\t\t\t\t\t\ttopic,\n\t\t\t\t\t\talias,\n\t\t\t\t\t)\n\t\t\t\t\treturn new Error('Sending Topic Alias out of range')\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate _noop(err?: Error) {\n\t\tthis.log('noop ::', err)\n\t}\n\n\t/** Writes the packet to stream and emits events */\n\tprivate _writePacket(packet: Packet, cb?: DoneCallback) {\n\t\tthis.log('_writePacket :: packet: %O', packet)\n\t\tthis.log('_writePacket :: emitting `packetsend`')\n\n\t\tthis.emit('packetsend', packet)\n\n\t\t// When writing a packet, reschedule the ping timer\n\t\tthis._shiftPingInterval()\n\n\t\tthis.log('_writePacket :: writing to stream')\n\t\tconst result = mqttPacket.writeToStream(\n\t\t\tpacket,\n\t\t\tthis.stream,\n\t\t\tthis.options,\n\t\t)\n\t\tthis.log('_writePacket :: writeToStream result %s', result)\n\t\tif (!result && cb && cb !== this.noop) {\n\t\t\tthis.log(\n\t\t\t\t'_writePacket :: handle events on `drain` once through callback.',\n\t\t\t)\n\t\t\tthis.stream.once('drain', cb)\n\t\t} else if (cb) {\n\t\t\tthis.log('_writePacket :: invoking cb')\n\t\t\tcb()\n\t\t}\n\t}\n\n\t/**\n\t * _sendPacket - send or queue a packet\n\t * @param {Object} packet - packet options\n\t * @param {Function} cb - callback when the packet is sent\n\t * @param {Function} cbStorePut - called when message is put into outgoingStore\n\t * @param {Boolean} noStore - send without put to the store\n\t * @api private\n\t */\n\tprivate _sendPacket(\n\t\tpacket: Packet,\n\t\tcb?: DoneCallback,\n\t\tcbStorePut?: DoneCallback,\n\t\tnoStore?: boolean,\n\t) {\n\t\tthis.log('_sendPacket :: (%s) ::  start', this.options.clientId)\n\t\tcbStorePut = cbStorePut || this.noop\n\t\tcb = cb || this.noop\n\n\t\tconst err = this._applyTopicAlias(packet)\n\t\tif (err) {\n\t\t\tcb(err)\n\t\t\treturn\n\t\t}\n\n\t\tif (!this.connected) {\n\t\t\t// allow auth packets to be sent while authenticating with the broker (mqtt5 enhanced auth)\n\t\t\tif (packet.cmd === 'auth') {\n\t\t\t\tthis._writePacket(packet, cb)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tthis.log(\n\t\t\t\t'_sendPacket :: client not connected. Storing packet offline.',\n\t\t\t)\n\t\t\tthis._storePacket(packet, cb, cbStorePut)\n\t\t\treturn\n\t\t}\n\n\t\t// If \"noStore\" is true, the message is sent without being recorded in the store.\n\t\t// Messages that have not received puback or pubcomp remain in the store after disconnection\n\t\t// and are resent from the store upon reconnection.\n\t\t// For resend upon reconnection, \"noStore\" is set to true. This is because the message is already stored in the store.\n\t\t// This is to avoid interrupting other processes while recording to the store.\n\t\tif (noStore) {\n\t\t\tthis._writePacket(packet, cb)\n\t\t\treturn\n\t\t}\n\n\t\tswitch (packet.cmd) {\n\t\t\tcase 'publish':\n\t\t\t\tbreak\n\t\t\tcase 'pubrel':\n\t\t\t\tthis._storeAndSend(packet, cb, cbStorePut)\n\t\t\t\treturn\n\t\t\tdefault:\n\t\t\t\tthis._writePacket(packet, cb)\n\t\t\t\treturn\n\t\t}\n\n\t\tswitch (packet.qos) {\n\t\t\tcase 2:\n\t\t\tcase 1:\n\t\t\t\tthis._storeAndSend(packet, cb, cbStorePut)\n\t\t\t\tbreak\n\t\t\t/**\n\t\t\t * no need of case here since it will be caught by default\n\t\t\t * and jshint comply that before default it must be a break\n\t\t\t * anyway it will result in -1 evaluation\n\t\t\t */\n\t\t\tcase 0:\n\t\t\t/* falls through */\n\t\t\tdefault:\n\t\t\t\tthis._writePacket(packet, cb)\n\t\t\t\tbreak\n\t\t}\n\t\tthis.log('_sendPacket :: (%s) ::  end', this.options.clientId)\n\t}\n\n\t/**\n\t * _storePacket - queue a packet\n\t * @param {Object} packet - packet options\n\t * @param {Function} cb - callback when the packet is sent\n\t * @param {Function} cbStorePut - called when message is put into outgoingStore\n\t * @api private\n\t */\n\tprivate _storePacket(\n\t\tpacket: Packet,\n\t\tcb: DoneCallback,\n\t\tcbStorePut: DoneCallback,\n\t) {\n\t\tthis.log('_storePacket :: packet: %o', packet)\n\t\tthis.log('_storePacket :: cb? %s', !!cb)\n\t\tcbStorePut = cbStorePut || this.noop\n\n\t\tlet storePacket = packet\n\t\tif (storePacket.cmd === 'publish') {\n\t\t\t// The original packet is for sending.\n\t\t\t// The cloned storePacket is for storing to resend on reconnect.\n\t\t\t// Topic Alias must not be used after disconnected.\n\t\t\tstorePacket = clone(packet)\n\t\t\tconst err = this._removeTopicAliasAndRecoverTopicName(\n\t\t\t\tstorePacket as IPublishPacket,\n\t\t\t)\n\t\t\tif (err) {\n\t\t\t\treturn cb && cb(err)\n\t\t\t}\n\t\t}\n\n\t\tconst qos = (storePacket as IPublishPacket).qos || 0\n\t\t// check that the packet is not a qos of 0, or that the command is not a publish\n\t\tif ((qos === 0 && this.queueQoSZero) || storePacket.cmd !== 'publish') {\n\t\t\tthis.queue.push({ packet: storePacket, cb })\n\t\t} else if (qos > 0) {\n\t\t\tcb = this.outgoing[storePacket.messageId]\n\t\t\t\t? this.outgoing[storePacket.messageId].cb\n\t\t\t\t: null\n\t\t\tthis.outgoingStore.put(storePacket, (err) => {\n\t\t\t\tif (err) {\n\t\t\t\t\treturn cb && cb(err)\n\t\t\t\t}\n\t\t\t\tcbStorePut()\n\t\t\t})\n\t\t} else if (cb) {\n\t\t\tcb(new Error('No connection to broker'))\n\t\t}\n\t}\n\n\t/**\n\t * _setupPingTimer - setup the ping timer\n\t *\n\t * @api private\n\t */\n\tprivate _setupPingTimer() {\n\t\tthis.log(\n\t\t\t'_setupPingTimer :: keepalive %d (seconds)',\n\t\t\tthis.options.keepalive,\n\t\t)\n\n\t\tif (!this.pingTimer && this.options.keepalive) {\n\t\t\tthis.pingResp = true\n\t\t\tthis.pingTimer = reInterval(() => {\n\t\t\t\tthis._checkPing()\n\t\t\t}, this.options.keepalive * 1000)\n\t\t}\n\t}\n\n\t/**\n\t * _shiftPingInterval - reschedule the ping interval\n\t *\n\t * @api private\n\t */\n\tprivate _shiftPingInterval() {\n\t\tif (\n\t\t\tthis.pingTimer &&\n\t\t\tthis.options.keepalive &&\n\t\t\tthis.options.reschedulePings\n\t\t) {\n\t\t\tthis.pingTimer.reschedule(this.options.keepalive * 1000)\n\t\t}\n\t}\n\n\t/**\n\t * _checkPing - check if a pingresp has come back, and ping the server again\n\t *\n\t * @api private\n\t */\n\tprivate _checkPing() {\n\t\tthis.log('_checkPing :: checking ping...')\n\t\tif (this.pingResp) {\n\t\t\tthis.log(\n\t\t\t\t'_checkPing :: ping response received. Clearing flag and sending `pingreq`',\n\t\t\t)\n\t\t\tthis.pingResp = false\n\t\t\tthis._sendPacket({ cmd: 'pingreq' })\n\t\t} else {\n\t\t\t// do a forced cleanup since socket will be in bad shape\n\t\t\tthis.log('_checkPing :: calling _cleanUp with force true')\n\t\t\tthis._cleanUp(true)\n\t\t}\n\t}\n\n\t/**\n\t * _resubscribe\n\t * @api private\n\t */\n\tprivate _resubscribe() {\n\t\tthis.log('_resubscribe')\n\t\tconst _resubscribeTopicsKeys = Object.keys(this._resubscribeTopics)\n\t\tif (\n\t\t\t!this._firstConnection &&\n\t\t\t// Only resubscribe in case of clean connection or if the server does not have a stored session.\n\t\t\t// The Session Present flag is available since v3.1.1\n\t\t\t// https://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc385349254\n\t\t\t(this.options.clean ||\n\t\t\t\t(this.options.protocolVersion >= 4 &&\n\t\t\t\t\t!this.connackPacket.sessionPresent)) &&\n\t\t\t_resubscribeTopicsKeys.length > 0\n\t\t) {\n\t\t\tif (this.options.resubscribe) {\n\t\t\t\tif (this.options.protocolVersion === 5) {\n\t\t\t\t\tthis.log('_resubscribe: protocolVersion 5')\n\t\t\t\t\tfor (\n\t\t\t\t\t\tlet topicI = 0;\n\t\t\t\t\t\ttopicI < _resubscribeTopicsKeys.length;\n\t\t\t\t\t\ttopicI++\n\t\t\t\t\t) {\n\t\t\t\t\t\tconst resubscribeTopic: ISubscriptionMap = {}\n\t\t\t\t\t\tresubscribeTopic[_resubscribeTopicsKeys[topicI]] =\n\t\t\t\t\t\t\tthis._resubscribeTopics[\n\t\t\t\t\t\t\t\t_resubscribeTopicsKeys[topicI]\n\t\t\t\t\t\t\t]\n\t\t\t\t\t\tresubscribeTopic.resubscribe = true\n\t\t\t\t\t\tthis.subscribe(resubscribeTopic, {\n\t\t\t\t\t\t\tproperties:\n\t\t\t\t\t\t\t\tresubscribeTopic[_resubscribeTopicsKeys[topicI]]\n\t\t\t\t\t\t\t\t\t.properties,\n\t\t\t\t\t\t})\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tthis._resubscribeTopics.resubscribe = true\n\t\t\t\t\tthis.subscribe(this._resubscribeTopics)\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthis._resubscribeTopics = {}\n\t\t\t}\n\t\t}\n\n\t\tthis._firstConnection = false\n\t}\n\n\t/**\n\t * _onConnect\n\t *\n\t * @api private\n\t */\n\tprivate _onConnect(packet: IConnackPacket) {\n\t\tif (this.disconnected) {\n\t\t\tthis.emit('connect', packet)\n\t\t\treturn\n\t\t}\n\n\t\tthis.connackPacket = packet\n\t\tthis.messageIdProvider.clear()\n\t\tthis._setupPingTimer()\n\n\t\tthis.connected = true\n\n\t\t/** check if there are packets in outgoing store and stream them */\n\t\tconst startStreamProcess = () => {\n\t\t\tlet outStore = this.outgoingStore.createStream()\n\n\t\t\t/** destroy the outgoing store stream */\n\t\t\tconst remove = () => {\n\t\t\t\toutStore.destroy()\n\t\t\t\toutStore = null\n\t\t\t\tthis._flushStoreProcessingQueue()\n\t\t\t\tclearStoreProcessing()\n\t\t\t}\n\n\t\t\t/** stop store processing and clear packets id processed */\n\t\t\tconst clearStoreProcessing = () => {\n\t\t\t\tthis._storeProcessing = false\n\t\t\t\tthis._packetIdsDuringStoreProcessing = {}\n\t\t\t}\n\n\t\t\tthis.once('close', remove)\n\t\t\toutStore.on('error', (err) => {\n\t\t\t\tclearStoreProcessing()\n\t\t\t\tthis._flushStoreProcessingQueue()\n\t\t\t\tthis.removeListener('close', remove)\n\t\t\t\tthis.emit('error', err)\n\t\t\t})\n\n\t\t\t/** Read next packet in outgoing store and send it */\n\t\t\tconst storeDeliver = () => {\n\t\t\t\t// edge case, we wrapped this twice\n\t\t\t\tif (!outStore) {\n\t\t\t\t\treturn\n\t\t\t\t}\n\n\t\t\t\tconst packet2 = outStore.read(1)\n\n\t\t\t\tlet cb: PacketCallback\n\n\t\t\t\tif (!packet2) {\n\t\t\t\t\t// read when data is available in the future\n\t\t\t\t\toutStore.once('readable', storeDeliver)\n\t\t\t\t\treturn\n\t\t\t\t}\n\n\t\t\t\tthis._storeProcessing = true\n\n\t\t\t\t// Skip already processed store packets\n\t\t\t\tif (this._packetIdsDuringStoreProcessing[packet2.messageId]) {\n\t\t\t\t\tstoreDeliver()\n\t\t\t\t\treturn\n\t\t\t\t}\n\n\t\t\t\t// Avoid unnecessary stream read operations when disconnected\n\t\t\t\tif (!this.disconnecting && !this.reconnectTimer) {\n\t\t\t\t\tcb = this.outgoing[packet2.messageId]\n\t\t\t\t\t\t? this.outgoing[packet2.messageId].cb\n\t\t\t\t\t\t: null\n\t\t\t\t\tthis.outgoing[packet2.messageId] = {\n\t\t\t\t\t\tvolatile: false,\n\t\t\t\t\t\tcb(err, status) {\n\t\t\t\t\t\t\t// Ensure that the original callback passed in to publish gets invoked\n\t\t\t\t\t\t\tif (cb) {\n\t\t\t\t\t\t\t\tcb(err, status)\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tstoreDeliver()\n\t\t\t\t\t\t},\n\t\t\t\t\t}\n\t\t\t\t\tthis._packetIdsDuringStoreProcessing[packet2.messageId] =\n\t\t\t\t\t\ttrue\n\t\t\t\t\tif (this.messageIdProvider.register(packet2.messageId)) {\n\t\t\t\t\t\tthis._sendPacket(packet2, undefined, undefined, true)\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis.log(\n\t\t\t\t\t\t\t'messageId: %d has already used.',\n\t\t\t\t\t\t\tpacket2.messageId,\n\t\t\t\t\t\t)\n\t\t\t\t\t}\n\t\t\t\t} else if (outStore.destroy) {\n\t\t\t\t\toutStore.destroy()\n\t\t\t\t}\n\t\t\t}\n\n\t\t\toutStore.on('end', () => {\n\t\t\t\tlet allProcessed = true\n\t\t\t\tfor (const id in this._packetIdsDuringStoreProcessing) {\n\t\t\t\t\tif (!this._packetIdsDuringStoreProcessing[id]) {\n\t\t\t\t\t\tallProcessed = false\n\t\t\t\t\t\tbreak\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (allProcessed) {\n\t\t\t\t\tclearStoreProcessing()\n\t\t\t\t\tthis.removeListener('close', remove)\n\t\t\t\t\tthis._invokeAllStoreProcessingQueue()\n\t\t\t\t\tthis.emit('connect', packet)\n\t\t\t\t} else {\n\t\t\t\t\tstartStreamProcess()\n\t\t\t\t}\n\t\t\t})\n\t\t\tstoreDeliver()\n\t\t}\n\t\t// start flowing\n\t\tstartStreamProcess()\n\t}\n\n\tprivate _invokeStoreProcessingQueue() {\n\t\t// If _storeProcessing is true, the message is resending.\n\t\t// During resend, processing is skipped to prevent new messages from interrupting. #1635\n\t\tif (!this._storeProcessing && this._storeProcessingQueue.length > 0) {\n\t\t\tconst f = this._storeProcessingQueue[0]\n\t\t\tif (f && f.invoke()) {\n\t\t\t\tthis._storeProcessingQueue.shift()\n\t\t\t\treturn true\n\t\t\t}\n\t\t}\n\t\treturn false\n\t}\n\n\tprivate _invokeAllStoreProcessingQueue() {\n\t\twhile (this._invokeStoreProcessingQueue()) {\n\t\t\t/* empty */\n\t\t}\n\t}\n\n\tprivate _flushStoreProcessingQueue() {\n\t\tfor (const f of this._storeProcessingQueue) {\n\t\t\tif (f.cbStorePut) f.cbStorePut(new Error('Connection closed'))\n\t\t\tif (f.callback) f.callback(new Error('Connection closed'))\n\t\t}\n\t\tthis._storeProcessingQueue.splice(0)\n\t}\n\n\t/**\n\t * _removeOutgoingAndStoreMessage\n\t * @param {Number} messageId - messageId to remove message\n\t * @param {Function} cb - called when the message removed\n\t * @api private\n\t */\n\tprivate _removeOutgoingAndStoreMessage(\n\t\tmessageId: number,\n\t\tcb: PacketCallback,\n\t) {\n\t\tdelete this.outgoing[messageId]\n\t\tthis.outgoingStore.del({ messageId }, (err, packet) => {\n\t\t\tcb(err, packet)\n\t\t\tthis.messageIdProvider.deallocate(messageId)\n\t\t\tthis._invokeStoreProcessingQueue()\n\t\t})\n\t}\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}