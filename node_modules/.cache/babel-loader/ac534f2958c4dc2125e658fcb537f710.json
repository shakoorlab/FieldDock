{"ast":null,"code":"/* replacement start */\n\nconst process = require('process/')\n\n/* replacement end */\n// Ported from https://github.com/mafintosh/end-of-stream with\n// permission from the author, Mathias Buus (@mafintosh).\n;\n\n'use strict';\nconst {\n  AbortError,\n  codes\n} = require('../../ours/errors');\nconst {\n  ERR_INVALID_ARG_TYPE,\n  ERR_STREAM_PREMATURE_CLOSE\n} = codes;\nconst {\n  kEmptyObject,\n  once\n} = require('../../ours/util');\nconst {\n  validateAbortSignal,\n  validateFunction,\n  validateObject,\n  validateBoolean\n} = require('../validators');\nconst {\n  Promise,\n  PromisePrototypeThen\n} = require('../../ours/primordials');\nconst {\n  isClosed,\n  isReadable,\n  isReadableNodeStream,\n  isReadableStream,\n  isReadableFinished,\n  isReadableErrored,\n  isWritable,\n  isWritableNodeStream,\n  isWritableStream,\n  isWritableFinished,\n  isWritableErrored,\n  isNodeStream,\n  willEmitClose: _willEmitClose,\n  kIsClosedPromise\n} = require('./utils');\nfunction isRequest(stream) {\n  return stream.setHeader && typeof stream.abort === 'function';\n}\nconst nop = () => {};\nfunction eos(stream, options, callback) {\n  var _options$readable, _options$writable;\n  if (arguments.length === 2) {\n    callback = options;\n    options = kEmptyObject;\n  } else if (options == null) {\n    options = kEmptyObject;\n  } else {\n    validateObject(options, 'options');\n  }\n  validateFunction(callback, 'callback');\n  validateAbortSignal(options.signal, 'options.signal');\n  callback = once(callback);\n  if (isReadableStream(stream) || isWritableStream(stream)) {\n    return eosWeb(stream, options, callback);\n  }\n  if (!isNodeStream(stream)) {\n    throw new ERR_INVALID_ARG_TYPE('stream', ['ReadableStream', 'WritableStream', 'Stream'], stream);\n  }\n  const readable = (_options$readable = options.readable) !== null && _options$readable !== undefined ? _options$readable : isReadableNodeStream(stream);\n  const writable = (_options$writable = options.writable) !== null && _options$writable !== undefined ? _options$writable : isWritableNodeStream(stream);\n  const wState = stream._writableState;\n  const rState = stream._readableState;\n  const onlegacyfinish = () => {\n    if (!stream.writable) {\n      onfinish();\n    }\n  };\n\n  // TODO (ronag): Improve soft detection to include core modules and\n  // common ecosystem modules that do properly emit 'close' but fail\n  // this generic check.\n  let willEmitClose = _willEmitClose(stream) && isReadableNodeStream(stream) === readable && isWritableNodeStream(stream) === writable;\n  let writableFinished = isWritableFinished(stream, false);\n  const onfinish = () => {\n    writableFinished = true;\n    // Stream should not be destroyed here. If it is that\n    // means that user space is doing something differently and\n    // we cannot trust willEmitClose.\n    if (stream.destroyed) {\n      willEmitClose = false;\n    }\n    if (willEmitClose && (!stream.readable || readable)) {\n      return;\n    }\n    if (!readable || readableFinished) {\n      callback.call(stream);\n    }\n  };\n  let readableFinished = isReadableFinished(stream, false);\n  const onend = () => {\n    readableFinished = true;\n    // Stream should not be destroyed here. If it is that\n    // means that user space is doing something differently and\n    // we cannot trust willEmitClose.\n    if (stream.destroyed) {\n      willEmitClose = false;\n    }\n    if (willEmitClose && (!stream.writable || writable)) {\n      return;\n    }\n    if (!writable || writableFinished) {\n      callback.call(stream);\n    }\n  };\n  const onerror = err => {\n    callback.call(stream, err);\n  };\n  let closed = isClosed(stream);\n  const onclose = () => {\n    closed = true;\n    const errored = isWritableErrored(stream) || isReadableErrored(stream);\n    if (errored && typeof errored !== 'boolean') {\n      return callback.call(stream, errored);\n    }\n    if (readable && !readableFinished && isReadableNodeStream(stream, true)) {\n      if (!isReadableFinished(stream, false)) return callback.call(stream, new ERR_STREAM_PREMATURE_CLOSE());\n    }\n    if (writable && !writableFinished) {\n      if (!isWritableFinished(stream, false)) return callback.call(stream, new ERR_STREAM_PREMATURE_CLOSE());\n    }\n    callback.call(stream);\n  };\n  const onclosed = () => {\n    closed = true;\n    const errored = isWritableErrored(stream) || isReadableErrored(stream);\n    if (errored && typeof errored !== 'boolean') {\n      return callback.call(stream, errored);\n    }\n    callback.call(stream);\n  };\n  const onrequest = () => {\n    stream.req.on('finish', onfinish);\n  };\n  if (isRequest(stream)) {\n    stream.on('complete', onfinish);\n    if (!willEmitClose) {\n      stream.on('abort', onclose);\n    }\n    if (stream.req) {\n      onrequest();\n    } else {\n      stream.on('request', onrequest);\n    }\n  } else if (writable && !wState) {\n    // legacy streams\n    stream.on('end', onlegacyfinish);\n    stream.on('close', onlegacyfinish);\n  }\n\n  // Not all streams will emit 'close' after 'aborted'.\n  if (!willEmitClose && typeof stream.aborted === 'boolean') {\n    stream.on('aborted', onclose);\n  }\n  stream.on('end', onend);\n  stream.on('finish', onfinish);\n  if (options.error !== false) {\n    stream.on('error', onerror);\n  }\n  stream.on('close', onclose);\n  if (closed) {\n    process.nextTick(onclose);\n  } else if (wState !== null && wState !== undefined && wState.errorEmitted || rState !== null && rState !== undefined && rState.errorEmitted) {\n    if (!willEmitClose) {\n      process.nextTick(onclosed);\n    }\n  } else if (!readable && (!willEmitClose || isReadable(stream)) && (writableFinished || isWritable(stream) === false)) {\n    process.nextTick(onclosed);\n  } else if (!writable && (!willEmitClose || isWritable(stream)) && (readableFinished || isReadable(stream) === false)) {\n    process.nextTick(onclosed);\n  } else if (rState && stream.req && stream.aborted) {\n    process.nextTick(onclosed);\n  }\n  const cleanup = () => {\n    callback = nop;\n    stream.removeListener('aborted', onclose);\n    stream.removeListener('complete', onfinish);\n    stream.removeListener('abort', onclose);\n    stream.removeListener('request', onrequest);\n    if (stream.req) stream.req.removeListener('finish', onfinish);\n    stream.removeListener('end', onlegacyfinish);\n    stream.removeListener('close', onlegacyfinish);\n    stream.removeListener('finish', onfinish);\n    stream.removeListener('end', onend);\n    stream.removeListener('error', onerror);\n    stream.removeListener('close', onclose);\n  };\n  if (options.signal && !closed) {\n    const abort = () => {\n      // Keep it because cleanup removes it.\n      const endCallback = callback;\n      cleanup();\n      endCallback.call(stream, new AbortError(undefined, {\n        cause: options.signal.reason\n      }));\n    };\n    if (options.signal.aborted) {\n      process.nextTick(abort);\n    } else {\n      const originalCallback = callback;\n      callback = once(function () {\n        options.signal.removeEventListener('abort', abort);\n        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n          args[_key] = arguments[_key];\n        }\n        originalCallback.apply(stream, args);\n      });\n      options.signal.addEventListener('abort', abort);\n    }\n  }\n  return cleanup;\n}\nfunction eosWeb(stream, options, callback) {\n  let isAborted = false;\n  let abort = nop;\n  if (options.signal) {\n    abort = () => {\n      isAborted = true;\n      callback.call(stream, new AbortError(undefined, {\n        cause: options.signal.reason\n      }));\n    };\n    if (options.signal.aborted) {\n      process.nextTick(abort);\n    } else {\n      const originalCallback = callback;\n      callback = once(function () {\n        options.signal.removeEventListener('abort', abort);\n        for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n          args[_key2] = arguments[_key2];\n        }\n        originalCallback.apply(stream, args);\n      });\n      options.signal.addEventListener('abort', abort);\n    }\n  }\n  const resolverFn = function () {\n    for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n      args[_key3] = arguments[_key3];\n    }\n    if (!isAborted) {\n      process.nextTick(() => callback.apply(stream, args));\n    }\n  };\n  PromisePrototypeThen(stream[kIsClosedPromise].promise, resolverFn, resolverFn);\n  return nop;\n}\nfunction finished(stream, opts) {\n  var _opts;\n  let autoCleanup = false;\n  if (opts === null) {\n    opts = kEmptyObject;\n  }\n  if ((_opts = opts) !== null && _opts !== undefined && _opts.cleanup) {\n    validateBoolean(opts.cleanup, 'cleanup');\n    autoCleanup = opts.cleanup;\n  }\n  return new Promise((resolve, reject) => {\n    const cleanup = eos(stream, opts, err => {\n      if (autoCleanup) {\n        cleanup();\n      }\n      if (err) {\n        reject(err);\n      } else {\n        resolve();\n      }\n    });\n  });\n}\nmodule.exports = eos;\nmodule.exports.finished = finished;","map":{"version":3,"names":["process","require","AbortError","codes","ERR_INVALID_ARG_TYPE","ERR_STREAM_PREMATURE_CLOSE","kEmptyObject","once","validateAbortSignal","validateFunction","validateObject","validateBoolean","Promise","PromisePrototypeThen","isClosed","isReadable","isReadableNodeStream","isReadableStream","isReadableFinished","isReadableErrored","isWritable","isWritableNodeStream","isWritableStream","isWritableFinished","isWritableErrored","isNodeStream","willEmitClose","_willEmitClose","kIsClosedPromise","isRequest","stream","setHeader","abort","nop","eos","options","callback","_options$readable","_options$writable","arguments","length","signal","eosWeb","readable","undefined","writable","wState","_writableState","rState","_readableState","onlegacyfinish","onfinish","writableFinished","destroyed","readableFinished","call","onend","onerror","err","closed","onclose","errored","onclosed","onrequest","req","on","aborted","error","nextTick","errorEmitted","cleanup","removeListener","endCallback","cause","reason","originalCallback","removeEventListener","_len","args","Array","_key","apply","addEventListener","isAborted","_len2","_key2","resolverFn","_len3","_key3","promise","finished","opts","_opts","autoCleanup","resolve","reject","module","exports"],"sources":["/Users/jstanton/Coding/FieldDock/FieldDockMain/node_modules/mqtt/node_modules/readable-stream/lib/internal/streams/end-of-stream.js"],"sourcesContent":["/* replacement start */\n\nconst process = require('process/')\n\n/* replacement end */\n// Ported from https://github.com/mafintosh/end-of-stream with\n// permission from the author, Mathias Buus (@mafintosh).\n\n;('use strict')\nconst { AbortError, codes } = require('../../ours/errors')\nconst { ERR_INVALID_ARG_TYPE, ERR_STREAM_PREMATURE_CLOSE } = codes\nconst { kEmptyObject, once } = require('../../ours/util')\nconst { validateAbortSignal, validateFunction, validateObject, validateBoolean } = require('../validators')\nconst { Promise, PromisePrototypeThen } = require('../../ours/primordials')\nconst {\n  isClosed,\n  isReadable,\n  isReadableNodeStream,\n  isReadableStream,\n  isReadableFinished,\n  isReadableErrored,\n  isWritable,\n  isWritableNodeStream,\n  isWritableStream,\n  isWritableFinished,\n  isWritableErrored,\n  isNodeStream,\n  willEmitClose: _willEmitClose,\n  kIsClosedPromise\n} = require('./utils')\nfunction isRequest(stream) {\n  return stream.setHeader && typeof stream.abort === 'function'\n}\nconst nop = () => {}\nfunction eos(stream, options, callback) {\n  var _options$readable, _options$writable\n  if (arguments.length === 2) {\n    callback = options\n    options = kEmptyObject\n  } else if (options == null) {\n    options = kEmptyObject\n  } else {\n    validateObject(options, 'options')\n  }\n  validateFunction(callback, 'callback')\n  validateAbortSignal(options.signal, 'options.signal')\n  callback = once(callback)\n  if (isReadableStream(stream) || isWritableStream(stream)) {\n    return eosWeb(stream, options, callback)\n  }\n  if (!isNodeStream(stream)) {\n    throw new ERR_INVALID_ARG_TYPE('stream', ['ReadableStream', 'WritableStream', 'Stream'], stream)\n  }\n  const readable =\n    (_options$readable = options.readable) !== null && _options$readable !== undefined\n      ? _options$readable\n      : isReadableNodeStream(stream)\n  const writable =\n    (_options$writable = options.writable) !== null && _options$writable !== undefined\n      ? _options$writable\n      : isWritableNodeStream(stream)\n  const wState = stream._writableState\n  const rState = stream._readableState\n  const onlegacyfinish = () => {\n    if (!stream.writable) {\n      onfinish()\n    }\n  }\n\n  // TODO (ronag): Improve soft detection to include core modules and\n  // common ecosystem modules that do properly emit 'close' but fail\n  // this generic check.\n  let willEmitClose =\n    _willEmitClose(stream) && isReadableNodeStream(stream) === readable && isWritableNodeStream(stream) === writable\n  let writableFinished = isWritableFinished(stream, false)\n  const onfinish = () => {\n    writableFinished = true\n    // Stream should not be destroyed here. If it is that\n    // means that user space is doing something differently and\n    // we cannot trust willEmitClose.\n    if (stream.destroyed) {\n      willEmitClose = false\n    }\n    if (willEmitClose && (!stream.readable || readable)) {\n      return\n    }\n    if (!readable || readableFinished) {\n      callback.call(stream)\n    }\n  }\n  let readableFinished = isReadableFinished(stream, false)\n  const onend = () => {\n    readableFinished = true\n    // Stream should not be destroyed here. If it is that\n    // means that user space is doing something differently and\n    // we cannot trust willEmitClose.\n    if (stream.destroyed) {\n      willEmitClose = false\n    }\n    if (willEmitClose && (!stream.writable || writable)) {\n      return\n    }\n    if (!writable || writableFinished) {\n      callback.call(stream)\n    }\n  }\n  const onerror = (err) => {\n    callback.call(stream, err)\n  }\n  let closed = isClosed(stream)\n  const onclose = () => {\n    closed = true\n    const errored = isWritableErrored(stream) || isReadableErrored(stream)\n    if (errored && typeof errored !== 'boolean') {\n      return callback.call(stream, errored)\n    }\n    if (readable && !readableFinished && isReadableNodeStream(stream, true)) {\n      if (!isReadableFinished(stream, false)) return callback.call(stream, new ERR_STREAM_PREMATURE_CLOSE())\n    }\n    if (writable && !writableFinished) {\n      if (!isWritableFinished(stream, false)) return callback.call(stream, new ERR_STREAM_PREMATURE_CLOSE())\n    }\n    callback.call(stream)\n  }\n  const onclosed = () => {\n    closed = true\n    const errored = isWritableErrored(stream) || isReadableErrored(stream)\n    if (errored && typeof errored !== 'boolean') {\n      return callback.call(stream, errored)\n    }\n    callback.call(stream)\n  }\n  const onrequest = () => {\n    stream.req.on('finish', onfinish)\n  }\n  if (isRequest(stream)) {\n    stream.on('complete', onfinish)\n    if (!willEmitClose) {\n      stream.on('abort', onclose)\n    }\n    if (stream.req) {\n      onrequest()\n    } else {\n      stream.on('request', onrequest)\n    }\n  } else if (writable && !wState) {\n    // legacy streams\n    stream.on('end', onlegacyfinish)\n    stream.on('close', onlegacyfinish)\n  }\n\n  // Not all streams will emit 'close' after 'aborted'.\n  if (!willEmitClose && typeof stream.aborted === 'boolean') {\n    stream.on('aborted', onclose)\n  }\n  stream.on('end', onend)\n  stream.on('finish', onfinish)\n  if (options.error !== false) {\n    stream.on('error', onerror)\n  }\n  stream.on('close', onclose)\n  if (closed) {\n    process.nextTick(onclose)\n  } else if (\n    (wState !== null && wState !== undefined && wState.errorEmitted) ||\n    (rState !== null && rState !== undefined && rState.errorEmitted)\n  ) {\n    if (!willEmitClose) {\n      process.nextTick(onclosed)\n    }\n  } else if (\n    !readable &&\n    (!willEmitClose || isReadable(stream)) &&\n    (writableFinished || isWritable(stream) === false)\n  ) {\n    process.nextTick(onclosed)\n  } else if (\n    !writable &&\n    (!willEmitClose || isWritable(stream)) &&\n    (readableFinished || isReadable(stream) === false)\n  ) {\n    process.nextTick(onclosed)\n  } else if (rState && stream.req && stream.aborted) {\n    process.nextTick(onclosed)\n  }\n  const cleanup = () => {\n    callback = nop\n    stream.removeListener('aborted', onclose)\n    stream.removeListener('complete', onfinish)\n    stream.removeListener('abort', onclose)\n    stream.removeListener('request', onrequest)\n    if (stream.req) stream.req.removeListener('finish', onfinish)\n    stream.removeListener('end', onlegacyfinish)\n    stream.removeListener('close', onlegacyfinish)\n    stream.removeListener('finish', onfinish)\n    stream.removeListener('end', onend)\n    stream.removeListener('error', onerror)\n    stream.removeListener('close', onclose)\n  }\n  if (options.signal && !closed) {\n    const abort = () => {\n      // Keep it because cleanup removes it.\n      const endCallback = callback\n      cleanup()\n      endCallback.call(\n        stream,\n        new AbortError(undefined, {\n          cause: options.signal.reason\n        })\n      )\n    }\n    if (options.signal.aborted) {\n      process.nextTick(abort)\n    } else {\n      const originalCallback = callback\n      callback = once((...args) => {\n        options.signal.removeEventListener('abort', abort)\n        originalCallback.apply(stream, args)\n      })\n      options.signal.addEventListener('abort', abort)\n    }\n  }\n  return cleanup\n}\nfunction eosWeb(stream, options, callback) {\n  let isAborted = false\n  let abort = nop\n  if (options.signal) {\n    abort = () => {\n      isAborted = true\n      callback.call(\n        stream,\n        new AbortError(undefined, {\n          cause: options.signal.reason\n        })\n      )\n    }\n    if (options.signal.aborted) {\n      process.nextTick(abort)\n    } else {\n      const originalCallback = callback\n      callback = once((...args) => {\n        options.signal.removeEventListener('abort', abort)\n        originalCallback.apply(stream, args)\n      })\n      options.signal.addEventListener('abort', abort)\n    }\n  }\n  const resolverFn = (...args) => {\n    if (!isAborted) {\n      process.nextTick(() => callback.apply(stream, args))\n    }\n  }\n  PromisePrototypeThen(stream[kIsClosedPromise].promise, resolverFn, resolverFn)\n  return nop\n}\nfunction finished(stream, opts) {\n  var _opts\n  let autoCleanup = false\n  if (opts === null) {\n    opts = kEmptyObject\n  }\n  if ((_opts = opts) !== null && _opts !== undefined && _opts.cleanup) {\n    validateBoolean(opts.cleanup, 'cleanup')\n    autoCleanup = opts.cleanup\n  }\n  return new Promise((resolve, reject) => {\n    const cleanup = eos(stream, opts, (err) => {\n      if (autoCleanup) {\n        cleanup()\n      }\n      if (err) {\n        reject(err)\n      } else {\n        resolve()\n      }\n    })\n  })\n}\nmodule.exports = eos\nmodule.exports.finished = finished\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}