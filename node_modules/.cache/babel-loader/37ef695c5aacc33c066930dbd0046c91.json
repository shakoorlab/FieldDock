{"ast":null,"code":"/* eslint jsdoc/require-jsdoc: \"error\" */\n\n'use strict';\n\nconst {\n  ArrayIsArray,\n  ArrayPrototypeIncludes,\n  ArrayPrototypeJoin,\n  ArrayPrototypeMap,\n  NumberIsInteger,\n  NumberIsNaN,\n  NumberMAX_SAFE_INTEGER,\n  NumberMIN_SAFE_INTEGER,\n  NumberParseInt,\n  ObjectPrototypeHasOwnProperty,\n  RegExpPrototypeExec,\n  String,\n  StringPrototypeToUpperCase,\n  StringPrototypeTrim\n} = require('../ours/primordials');\nconst {\n  hideStackFrames,\n  codes: {\n    ERR_SOCKET_BAD_PORT,\n    ERR_INVALID_ARG_TYPE,\n    ERR_INVALID_ARG_VALUE,\n    ERR_OUT_OF_RANGE,\n    ERR_UNKNOWN_SIGNAL\n  }\n} = require('../ours/errors');\nconst {\n  normalizeEncoding\n} = require('../ours/util');\nconst {\n  isAsyncFunction,\n  isArrayBufferView\n} = require('../ours/util').types;\nconst signals = {};\n\n/**\n * @param {*} value\n * @returns {boolean}\n */\nfunction isInt32(value) {\n  return value === (value | 0);\n}\n\n/**\n * @param {*} value\n * @returns {boolean}\n */\nfunction isUint32(value) {\n  return value === value >>> 0;\n}\nconst octalReg = /^[0-7]+$/;\nconst modeDesc = 'must be a 32-bit unsigned integer or an octal string';\n\n/**\n * Parse and validate values that will be converted into mode_t (the S_*\n * constants). Only valid numbers and octal strings are allowed. They could be\n * converted to 32-bit unsigned integers or non-negative signed integers in the\n * C++ land, but any value higher than 0o777 will result in platform-specific\n * behaviors.\n *\n * @param {*} value Values to be validated\n * @param {string} name Name of the argument\n * @param {number} [def] If specified, will be returned for invalid values\n * @returns {number}\n */\nfunction parseFileMode(value, name, def) {\n  if (typeof value === 'undefined') {\n    value = def;\n  }\n  if (typeof value === 'string') {\n    if (RegExpPrototypeExec(octalReg, value) === null) {\n      throw new ERR_INVALID_ARG_VALUE(name, value, modeDesc);\n    }\n    value = NumberParseInt(value, 8);\n  }\n  validateUint32(value, name);\n  return value;\n}\n\n/**\n * @callback validateInteger\n * @param {*} value\n * @param {string} name\n * @param {number} [min]\n * @param {number} [max]\n * @returns {asserts value is number}\n */\n\n/** @type {validateInteger} */\nconst validateInteger = hideStackFrames(function (value, name) {\n  let min = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : NumberMIN_SAFE_INTEGER;\n  let max = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : NumberMAX_SAFE_INTEGER;\n  if (typeof value !== 'number') throw new ERR_INVALID_ARG_TYPE(name, 'number', value);\n  if (!NumberIsInteger(value)) throw new ERR_OUT_OF_RANGE(name, 'an integer', value);\n  if (value < min || value > max) throw new ERR_OUT_OF_RANGE(name, `>= ${min} && <= ${max}`, value);\n});\n\n/**\n * @callback validateInt32\n * @param {*} value\n * @param {string} name\n * @param {number} [min]\n * @param {number} [max]\n * @returns {asserts value is number}\n */\n\n/** @type {validateInt32} */\nconst validateInt32 = hideStackFrames(function (value, name) {\n  let min = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : -2147483648;\n  let max = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 2147483647;\n  // The defaults for min and max correspond to the limits of 32-bit integers.\n  if (typeof value !== 'number') {\n    throw new ERR_INVALID_ARG_TYPE(name, 'number', value);\n  }\n  if (!NumberIsInteger(value)) {\n    throw new ERR_OUT_OF_RANGE(name, 'an integer', value);\n  }\n  if (value < min || value > max) {\n    throw new ERR_OUT_OF_RANGE(name, `>= ${min} && <= ${max}`, value);\n  }\n});\n\n/**\n * @callback validateUint32\n * @param {*} value\n * @param {string} name\n * @param {number|boolean} [positive=false]\n * @returns {asserts value is number}\n */\n\n/** @type {validateUint32} */\nconst validateUint32 = hideStackFrames(function (value, name) {\n  let positive = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  if (typeof value !== 'number') {\n    throw new ERR_INVALID_ARG_TYPE(name, 'number', value);\n  }\n  if (!NumberIsInteger(value)) {\n    throw new ERR_OUT_OF_RANGE(name, 'an integer', value);\n  }\n  const min = positive ? 1 : 0;\n  // 2 ** 32 === 4294967296\n  const max = 4294967295;\n  if (value < min || value > max) {\n    throw new ERR_OUT_OF_RANGE(name, `>= ${min} && <= ${max}`, value);\n  }\n});\n\n/**\n * @callback validateString\n * @param {*} value\n * @param {string} name\n * @returns {asserts value is string}\n */\n\n/** @type {validateString} */\nfunction validateString(value, name) {\n  if (typeof value !== 'string') throw new ERR_INVALID_ARG_TYPE(name, 'string', value);\n}\n\n/**\n * @callback validateNumber\n * @param {*} value\n * @param {string} name\n * @param {number} [min]\n * @param {number} [max]\n * @returns {asserts value is number}\n */\n\n/** @type {validateNumber} */\nfunction validateNumber(value, name) {\n  let min = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : undefined;\n  let max = arguments.length > 3 ? arguments[3] : undefined;\n  if (typeof value !== 'number') throw new ERR_INVALID_ARG_TYPE(name, 'number', value);\n  if (min != null && value < min || max != null && value > max || (min != null || max != null) && NumberIsNaN(value)) {\n    throw new ERR_OUT_OF_RANGE(name, `${min != null ? `>= ${min}` : ''}${min != null && max != null ? ' && ' : ''}${max != null ? `<= ${max}` : ''}`, value);\n  }\n}\n\n/**\n * @callback validateOneOf\n * @template T\n * @param {T} value\n * @param {string} name\n * @param {T[]} oneOf\n */\n\n/** @type {validateOneOf} */\nconst validateOneOf = hideStackFrames((value, name, oneOf) => {\n  if (!ArrayPrototypeIncludes(oneOf, value)) {\n    const allowed = ArrayPrototypeJoin(ArrayPrototypeMap(oneOf, v => typeof v === 'string' ? `'${v}'` : String(v)), ', ');\n    const reason = 'must be one of: ' + allowed;\n    throw new ERR_INVALID_ARG_VALUE(name, value, reason);\n  }\n});\n\n/**\n * @callback validateBoolean\n * @param {*} value\n * @param {string} name\n * @returns {asserts value is boolean}\n */\n\n/** @type {validateBoolean} */\nfunction validateBoolean(value, name) {\n  if (typeof value !== 'boolean') throw new ERR_INVALID_ARG_TYPE(name, 'boolean', value);\n}\n\n/**\n * @param {any} options\n * @param {string} key\n * @param {boolean} defaultValue\n * @returns {boolean}\n */\nfunction getOwnPropertyValueOrDefault(options, key, defaultValue) {\n  return options == null || !ObjectPrototypeHasOwnProperty(options, key) ? defaultValue : options[key];\n}\n\n/**\n * @callback validateObject\n * @param {*} value\n * @param {string} name\n * @param {{\n *   allowArray?: boolean,\n *   allowFunction?: boolean,\n *   nullable?: boolean\n * }} [options]\n */\n\n/** @type {validateObject} */\nconst validateObject = hideStackFrames(function (value, name) {\n  let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n  const allowArray = getOwnPropertyValueOrDefault(options, 'allowArray', false);\n  const allowFunction = getOwnPropertyValueOrDefault(options, 'allowFunction', false);\n  const nullable = getOwnPropertyValueOrDefault(options, 'nullable', false);\n  if (!nullable && value === null || !allowArray && ArrayIsArray(value) || typeof value !== 'object' && (!allowFunction || typeof value !== 'function')) {\n    throw new ERR_INVALID_ARG_TYPE(name, 'Object', value);\n  }\n});\n\n/**\n * @callback validateDictionary - We are using the Web IDL Standard definition\n *                                of \"dictionary\" here, which means any value\n *                                whose Type is either Undefined, Null, or\n *                                Object (which includes functions).\n * @param {*} value\n * @param {string} name\n * @see https://webidl.spec.whatwg.org/#es-dictionary\n * @see https://tc39.es/ecma262/#table-typeof-operator-results\n */\n\n/** @type {validateDictionary} */\nconst validateDictionary = hideStackFrames((value, name) => {\n  if (value != null && typeof value !== 'object' && typeof value !== 'function') {\n    throw new ERR_INVALID_ARG_TYPE(name, 'a dictionary', value);\n  }\n});\n\n/**\n * @callback validateArray\n * @param {*} value\n * @param {string} name\n * @param {number} [minLength]\n * @returns {asserts value is any[]}\n */\n\n/** @type {validateArray} */\nconst validateArray = hideStackFrames(function (value, name) {\n  let minLength = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n  if (!ArrayIsArray(value)) {\n    throw new ERR_INVALID_ARG_TYPE(name, 'Array', value);\n  }\n  if (value.length < minLength) {\n    const reason = `must be longer than ${minLength}`;\n    throw new ERR_INVALID_ARG_VALUE(name, value, reason);\n  }\n});\n\n/**\n * @callback validateStringArray\n * @param {*} value\n * @param {string} name\n * @returns {asserts value is string[]}\n */\n\n/** @type {validateStringArray} */\nfunction validateStringArray(value, name) {\n  validateArray(value, name);\n  for (let i = 0; i < value.length; i++) {\n    validateString(value[i], `${name}[${i}]`);\n  }\n}\n\n/**\n * @callback validateBooleanArray\n * @param {*} value\n * @param {string} name\n * @returns {asserts value is boolean[]}\n */\n\n/** @type {validateBooleanArray} */\nfunction validateBooleanArray(value, name) {\n  validateArray(value, name);\n  for (let i = 0; i < value.length; i++) {\n    validateBoolean(value[i], `${name}[${i}]`);\n  }\n}\n\n/**\n * @param {*} signal\n * @param {string} [name='signal']\n * @returns {asserts signal is keyof signals}\n */\nfunction validateSignalName(signal) {\n  let name = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'signal';\n  validateString(signal, name);\n  if (signals[signal] === undefined) {\n    if (signals[StringPrototypeToUpperCase(signal)] !== undefined) {\n      throw new ERR_UNKNOWN_SIGNAL(signal + ' (signals must use all capital letters)');\n    }\n    throw new ERR_UNKNOWN_SIGNAL(signal);\n  }\n}\n\n/**\n * @callback validateBuffer\n * @param {*} buffer\n * @param {string} [name='buffer']\n * @returns {asserts buffer is ArrayBufferView}\n */\n\n/** @type {validateBuffer} */\nconst validateBuffer = hideStackFrames(function (buffer) {\n  let name = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'buffer';\n  if (!isArrayBufferView(buffer)) {\n    throw new ERR_INVALID_ARG_TYPE(name, ['Buffer', 'TypedArray', 'DataView'], buffer);\n  }\n});\n\n/**\n * @param {string} data\n * @param {string} encoding\n */\nfunction validateEncoding(data, encoding) {\n  const normalizedEncoding = normalizeEncoding(encoding);\n  const length = data.length;\n  if (normalizedEncoding === 'hex' && length % 2 !== 0) {\n    throw new ERR_INVALID_ARG_VALUE('encoding', encoding, `is invalid for data of length ${length}`);\n  }\n}\n\n/**\n * Check that the port number is not NaN when coerced to a number,\n * is an integer and that it falls within the legal range of port numbers.\n * @param {*} port\n * @param {string} [name='Port']\n * @param {boolean} [allowZero=true]\n * @returns {number}\n */\nfunction validatePort(port) {\n  let name = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'Port';\n  let allowZero = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n  if (typeof port !== 'number' && typeof port !== 'string' || typeof port === 'string' && StringPrototypeTrim(port).length === 0 || +port !== +port >>> 0 || port > 0xffff || port === 0 && !allowZero) {\n    throw new ERR_SOCKET_BAD_PORT(name, port, allowZero);\n  }\n  return port | 0;\n}\n\n/**\n * @callback validateAbortSignal\n * @param {*} signal\n * @param {string} name\n */\n\n/** @type {validateAbortSignal} */\nconst validateAbortSignal = hideStackFrames((signal, name) => {\n  if (signal !== undefined && (signal === null || typeof signal !== 'object' || !('aborted' in signal))) {\n    throw new ERR_INVALID_ARG_TYPE(name, 'AbortSignal', signal);\n  }\n});\n\n/**\n * @callback validateFunction\n * @param {*} value\n * @param {string} name\n * @returns {asserts value is Function}\n */\n\n/** @type {validateFunction} */\nconst validateFunction = hideStackFrames((value, name) => {\n  if (typeof value !== 'function') throw new ERR_INVALID_ARG_TYPE(name, 'Function', value);\n});\n\n/**\n * @callback validatePlainFunction\n * @param {*} value\n * @param {string} name\n * @returns {asserts value is Function}\n */\n\n/** @type {validatePlainFunction} */\nconst validatePlainFunction = hideStackFrames((value, name) => {\n  if (typeof value !== 'function' || isAsyncFunction(value)) throw new ERR_INVALID_ARG_TYPE(name, 'Function', value);\n});\n\n/**\n * @callback validateUndefined\n * @param {*} value\n * @param {string} name\n * @returns {asserts value is undefined}\n */\n\n/** @type {validateUndefined} */\nconst validateUndefined = hideStackFrames((value, name) => {\n  if (value !== undefined) throw new ERR_INVALID_ARG_TYPE(name, 'undefined', value);\n});\n\n/**\n * @template T\n * @param {T} value\n * @param {string} name\n * @param {T[]} union\n */\nfunction validateUnion(value, name, union) {\n  if (!ArrayPrototypeIncludes(union, value)) {\n    throw new ERR_INVALID_ARG_TYPE(name, `('${ArrayPrototypeJoin(union, '|')}')`, value);\n  }\n}\n\n/*\n  The rules for the Link header field are described here:\n  https://www.rfc-editor.org/rfc/rfc8288.html#section-3\n\n  This regex validates any string surrounded by angle brackets\n  (not necessarily a valid URI reference) followed by zero or more\n  link-params separated by semicolons.\n*/\nconst linkValueRegExp = /^(?:<[^>]*>)(?:\\s*;\\s*[^;\"\\s]+(?:=(\")?[^;\"\\s]*\\1)?)*$/;\n\n/**\n * @param {any} value\n * @param {string} name\n */\nfunction validateLinkHeaderFormat(value, name) {\n  if (typeof value === 'undefined' || !RegExpPrototypeExec(linkValueRegExp, value)) {\n    throw new ERR_INVALID_ARG_VALUE(name, value, 'must be an array or string of format \"</styles.css>; rel=preload; as=style\"');\n  }\n}\n\n/**\n * @param {any} hints\n * @return {string}\n */\nfunction validateLinkHeaderValue(hints) {\n  if (typeof hints === 'string') {\n    validateLinkHeaderFormat(hints, 'hints');\n    return hints;\n  } else if (ArrayIsArray(hints)) {\n    const hintsLength = hints.length;\n    let result = '';\n    if (hintsLength === 0) {\n      return result;\n    }\n    for (let i = 0; i < hintsLength; i++) {\n      const link = hints[i];\n      validateLinkHeaderFormat(link, 'hints');\n      result += link;\n      if (i !== hintsLength - 1) {\n        result += ', ';\n      }\n    }\n    return result;\n  }\n  throw new ERR_INVALID_ARG_VALUE('hints', hints, 'must be an array or string of format \"</styles.css>; rel=preload; as=style\"');\n}\nmodule.exports = {\n  isInt32,\n  isUint32,\n  parseFileMode,\n  validateArray,\n  validateStringArray,\n  validateBooleanArray,\n  validateBoolean,\n  validateBuffer,\n  validateDictionary,\n  validateEncoding,\n  validateFunction,\n  validateInt32,\n  validateInteger,\n  validateNumber,\n  validateObject,\n  validateOneOf,\n  validatePlainFunction,\n  validatePort,\n  validateSignalName,\n  validateString,\n  validateUint32,\n  validateUndefined,\n  validateUnion,\n  validateAbortSignal,\n  validateLinkHeaderValue\n};","map":{"version":3,"names":["ArrayIsArray","ArrayPrototypeIncludes","ArrayPrototypeJoin","ArrayPrototypeMap","NumberIsInteger","NumberIsNaN","NumberMAX_SAFE_INTEGER","NumberMIN_SAFE_INTEGER","NumberParseInt","ObjectPrototypeHasOwnProperty","RegExpPrototypeExec","String","StringPrototypeToUpperCase","StringPrototypeTrim","require","hideStackFrames","codes","ERR_SOCKET_BAD_PORT","ERR_INVALID_ARG_TYPE","ERR_INVALID_ARG_VALUE","ERR_OUT_OF_RANGE","ERR_UNKNOWN_SIGNAL","normalizeEncoding","isAsyncFunction","isArrayBufferView","types","signals","isInt32","value","isUint32","octalReg","modeDesc","parseFileMode","name","def","validateUint32","validateInteger","min","arguments","length","undefined","max","validateInt32","positive","validateString","validateNumber","validateOneOf","oneOf","allowed","v","reason","validateBoolean","getOwnPropertyValueOrDefault","options","key","defaultValue","validateObject","allowArray","allowFunction","nullable","validateDictionary","validateArray","minLength","validateStringArray","i","validateBooleanArray","validateSignalName","signal","validateBuffer","buffer","validateEncoding","data","encoding","normalizedEncoding","validatePort","port","allowZero","validateAbortSignal","validateFunction","validatePlainFunction","validateUndefined","validateUnion","union","linkValueRegExp","validateLinkHeaderFormat","validateLinkHeaderValue","hints","hintsLength","result","link","module","exports"],"sources":["/Users/jstanton/Coding/FieldDock/FieldDockMain/node_modules/mqtt/node_modules/readable-stream/lib/internal/validators.js"],"sourcesContent":["/* eslint jsdoc/require-jsdoc: \"error\" */\n\n'use strict'\n\nconst {\n  ArrayIsArray,\n  ArrayPrototypeIncludes,\n  ArrayPrototypeJoin,\n  ArrayPrototypeMap,\n  NumberIsInteger,\n  NumberIsNaN,\n  NumberMAX_SAFE_INTEGER,\n  NumberMIN_SAFE_INTEGER,\n  NumberParseInt,\n  ObjectPrototypeHasOwnProperty,\n  RegExpPrototypeExec,\n  String,\n  StringPrototypeToUpperCase,\n  StringPrototypeTrim\n} = require('../ours/primordials')\nconst {\n  hideStackFrames,\n  codes: { ERR_SOCKET_BAD_PORT, ERR_INVALID_ARG_TYPE, ERR_INVALID_ARG_VALUE, ERR_OUT_OF_RANGE, ERR_UNKNOWN_SIGNAL }\n} = require('../ours/errors')\nconst { normalizeEncoding } = require('../ours/util')\nconst { isAsyncFunction, isArrayBufferView } = require('../ours/util').types\nconst signals = {}\n\n/**\n * @param {*} value\n * @returns {boolean}\n */\nfunction isInt32(value) {\n  return value === (value | 0)\n}\n\n/**\n * @param {*} value\n * @returns {boolean}\n */\nfunction isUint32(value) {\n  return value === value >>> 0\n}\nconst octalReg = /^[0-7]+$/\nconst modeDesc = 'must be a 32-bit unsigned integer or an octal string'\n\n/**\n * Parse and validate values that will be converted into mode_t (the S_*\n * constants). Only valid numbers and octal strings are allowed. They could be\n * converted to 32-bit unsigned integers or non-negative signed integers in the\n * C++ land, but any value higher than 0o777 will result in platform-specific\n * behaviors.\n *\n * @param {*} value Values to be validated\n * @param {string} name Name of the argument\n * @param {number} [def] If specified, will be returned for invalid values\n * @returns {number}\n */\nfunction parseFileMode(value, name, def) {\n  if (typeof value === 'undefined') {\n    value = def\n  }\n  if (typeof value === 'string') {\n    if (RegExpPrototypeExec(octalReg, value) === null) {\n      throw new ERR_INVALID_ARG_VALUE(name, value, modeDesc)\n    }\n    value = NumberParseInt(value, 8)\n  }\n  validateUint32(value, name)\n  return value\n}\n\n/**\n * @callback validateInteger\n * @param {*} value\n * @param {string} name\n * @param {number} [min]\n * @param {number} [max]\n * @returns {asserts value is number}\n */\n\n/** @type {validateInteger} */\nconst validateInteger = hideStackFrames((value, name, min = NumberMIN_SAFE_INTEGER, max = NumberMAX_SAFE_INTEGER) => {\n  if (typeof value !== 'number') throw new ERR_INVALID_ARG_TYPE(name, 'number', value)\n  if (!NumberIsInteger(value)) throw new ERR_OUT_OF_RANGE(name, 'an integer', value)\n  if (value < min || value > max) throw new ERR_OUT_OF_RANGE(name, `>= ${min} && <= ${max}`, value)\n})\n\n/**\n * @callback validateInt32\n * @param {*} value\n * @param {string} name\n * @param {number} [min]\n * @param {number} [max]\n * @returns {asserts value is number}\n */\n\n/** @type {validateInt32} */\nconst validateInt32 = hideStackFrames((value, name, min = -2147483648, max = 2147483647) => {\n  // The defaults for min and max correspond to the limits of 32-bit integers.\n  if (typeof value !== 'number') {\n    throw new ERR_INVALID_ARG_TYPE(name, 'number', value)\n  }\n  if (!NumberIsInteger(value)) {\n    throw new ERR_OUT_OF_RANGE(name, 'an integer', value)\n  }\n  if (value < min || value > max) {\n    throw new ERR_OUT_OF_RANGE(name, `>= ${min} && <= ${max}`, value)\n  }\n})\n\n/**\n * @callback validateUint32\n * @param {*} value\n * @param {string} name\n * @param {number|boolean} [positive=false]\n * @returns {asserts value is number}\n */\n\n/** @type {validateUint32} */\nconst validateUint32 = hideStackFrames((value, name, positive = false) => {\n  if (typeof value !== 'number') {\n    throw new ERR_INVALID_ARG_TYPE(name, 'number', value)\n  }\n  if (!NumberIsInteger(value)) {\n    throw new ERR_OUT_OF_RANGE(name, 'an integer', value)\n  }\n  const min = positive ? 1 : 0\n  // 2 ** 32 === 4294967296\n  const max = 4294967295\n  if (value < min || value > max) {\n    throw new ERR_OUT_OF_RANGE(name, `>= ${min} && <= ${max}`, value)\n  }\n})\n\n/**\n * @callback validateString\n * @param {*} value\n * @param {string} name\n * @returns {asserts value is string}\n */\n\n/** @type {validateString} */\nfunction validateString(value, name) {\n  if (typeof value !== 'string') throw new ERR_INVALID_ARG_TYPE(name, 'string', value)\n}\n\n/**\n * @callback validateNumber\n * @param {*} value\n * @param {string} name\n * @param {number} [min]\n * @param {number} [max]\n * @returns {asserts value is number}\n */\n\n/** @type {validateNumber} */\nfunction validateNumber(value, name, min = undefined, max) {\n  if (typeof value !== 'number') throw new ERR_INVALID_ARG_TYPE(name, 'number', value)\n  if (\n    (min != null && value < min) ||\n    (max != null && value > max) ||\n    ((min != null || max != null) && NumberIsNaN(value))\n  ) {\n    throw new ERR_OUT_OF_RANGE(\n      name,\n      `${min != null ? `>= ${min}` : ''}${min != null && max != null ? ' && ' : ''}${max != null ? `<= ${max}` : ''}`,\n      value\n    )\n  }\n}\n\n/**\n * @callback validateOneOf\n * @template T\n * @param {T} value\n * @param {string} name\n * @param {T[]} oneOf\n */\n\n/** @type {validateOneOf} */\nconst validateOneOf = hideStackFrames((value, name, oneOf) => {\n  if (!ArrayPrototypeIncludes(oneOf, value)) {\n    const allowed = ArrayPrototypeJoin(\n      ArrayPrototypeMap(oneOf, (v) => (typeof v === 'string' ? `'${v}'` : String(v))),\n      ', '\n    )\n    const reason = 'must be one of: ' + allowed\n    throw new ERR_INVALID_ARG_VALUE(name, value, reason)\n  }\n})\n\n/**\n * @callback validateBoolean\n * @param {*} value\n * @param {string} name\n * @returns {asserts value is boolean}\n */\n\n/** @type {validateBoolean} */\nfunction validateBoolean(value, name) {\n  if (typeof value !== 'boolean') throw new ERR_INVALID_ARG_TYPE(name, 'boolean', value)\n}\n\n/**\n * @param {any} options\n * @param {string} key\n * @param {boolean} defaultValue\n * @returns {boolean}\n */\nfunction getOwnPropertyValueOrDefault(options, key, defaultValue) {\n  return options == null || !ObjectPrototypeHasOwnProperty(options, key) ? defaultValue : options[key]\n}\n\n/**\n * @callback validateObject\n * @param {*} value\n * @param {string} name\n * @param {{\n *   allowArray?: boolean,\n *   allowFunction?: boolean,\n *   nullable?: boolean\n * }} [options]\n */\n\n/** @type {validateObject} */\nconst validateObject = hideStackFrames((value, name, options = null) => {\n  const allowArray = getOwnPropertyValueOrDefault(options, 'allowArray', false)\n  const allowFunction = getOwnPropertyValueOrDefault(options, 'allowFunction', false)\n  const nullable = getOwnPropertyValueOrDefault(options, 'nullable', false)\n  if (\n    (!nullable && value === null) ||\n    (!allowArray && ArrayIsArray(value)) ||\n    (typeof value !== 'object' && (!allowFunction || typeof value !== 'function'))\n  ) {\n    throw new ERR_INVALID_ARG_TYPE(name, 'Object', value)\n  }\n})\n\n/**\n * @callback validateDictionary - We are using the Web IDL Standard definition\n *                                of \"dictionary\" here, which means any value\n *                                whose Type is either Undefined, Null, or\n *                                Object (which includes functions).\n * @param {*} value\n * @param {string} name\n * @see https://webidl.spec.whatwg.org/#es-dictionary\n * @see https://tc39.es/ecma262/#table-typeof-operator-results\n */\n\n/** @type {validateDictionary} */\nconst validateDictionary = hideStackFrames((value, name) => {\n  if (value != null && typeof value !== 'object' && typeof value !== 'function') {\n    throw new ERR_INVALID_ARG_TYPE(name, 'a dictionary', value)\n  }\n})\n\n/**\n * @callback validateArray\n * @param {*} value\n * @param {string} name\n * @param {number} [minLength]\n * @returns {asserts value is any[]}\n */\n\n/** @type {validateArray} */\nconst validateArray = hideStackFrames((value, name, minLength = 0) => {\n  if (!ArrayIsArray(value)) {\n    throw new ERR_INVALID_ARG_TYPE(name, 'Array', value)\n  }\n  if (value.length < minLength) {\n    const reason = `must be longer than ${minLength}`\n    throw new ERR_INVALID_ARG_VALUE(name, value, reason)\n  }\n})\n\n/**\n * @callback validateStringArray\n * @param {*} value\n * @param {string} name\n * @returns {asserts value is string[]}\n */\n\n/** @type {validateStringArray} */\nfunction validateStringArray(value, name) {\n  validateArray(value, name)\n  for (let i = 0; i < value.length; i++) {\n    validateString(value[i], `${name}[${i}]`)\n  }\n}\n\n/**\n * @callback validateBooleanArray\n * @param {*} value\n * @param {string} name\n * @returns {asserts value is boolean[]}\n */\n\n/** @type {validateBooleanArray} */\nfunction validateBooleanArray(value, name) {\n  validateArray(value, name)\n  for (let i = 0; i < value.length; i++) {\n    validateBoolean(value[i], `${name}[${i}]`)\n  }\n}\n\n/**\n * @param {*} signal\n * @param {string} [name='signal']\n * @returns {asserts signal is keyof signals}\n */\nfunction validateSignalName(signal, name = 'signal') {\n  validateString(signal, name)\n  if (signals[signal] === undefined) {\n    if (signals[StringPrototypeToUpperCase(signal)] !== undefined) {\n      throw new ERR_UNKNOWN_SIGNAL(signal + ' (signals must use all capital letters)')\n    }\n    throw new ERR_UNKNOWN_SIGNAL(signal)\n  }\n}\n\n/**\n * @callback validateBuffer\n * @param {*} buffer\n * @param {string} [name='buffer']\n * @returns {asserts buffer is ArrayBufferView}\n */\n\n/** @type {validateBuffer} */\nconst validateBuffer = hideStackFrames((buffer, name = 'buffer') => {\n  if (!isArrayBufferView(buffer)) {\n    throw new ERR_INVALID_ARG_TYPE(name, ['Buffer', 'TypedArray', 'DataView'], buffer)\n  }\n})\n\n/**\n * @param {string} data\n * @param {string} encoding\n */\nfunction validateEncoding(data, encoding) {\n  const normalizedEncoding = normalizeEncoding(encoding)\n  const length = data.length\n  if (normalizedEncoding === 'hex' && length % 2 !== 0) {\n    throw new ERR_INVALID_ARG_VALUE('encoding', encoding, `is invalid for data of length ${length}`)\n  }\n}\n\n/**\n * Check that the port number is not NaN when coerced to a number,\n * is an integer and that it falls within the legal range of port numbers.\n * @param {*} port\n * @param {string} [name='Port']\n * @param {boolean} [allowZero=true]\n * @returns {number}\n */\nfunction validatePort(port, name = 'Port', allowZero = true) {\n  if (\n    (typeof port !== 'number' && typeof port !== 'string') ||\n    (typeof port === 'string' && StringPrototypeTrim(port).length === 0) ||\n    +port !== +port >>> 0 ||\n    port > 0xffff ||\n    (port === 0 && !allowZero)\n  ) {\n    throw new ERR_SOCKET_BAD_PORT(name, port, allowZero)\n  }\n  return port | 0\n}\n\n/**\n * @callback validateAbortSignal\n * @param {*} signal\n * @param {string} name\n */\n\n/** @type {validateAbortSignal} */\nconst validateAbortSignal = hideStackFrames((signal, name) => {\n  if (signal !== undefined && (signal === null || typeof signal !== 'object' || !('aborted' in signal))) {\n    throw new ERR_INVALID_ARG_TYPE(name, 'AbortSignal', signal)\n  }\n})\n\n/**\n * @callback validateFunction\n * @param {*} value\n * @param {string} name\n * @returns {asserts value is Function}\n */\n\n/** @type {validateFunction} */\nconst validateFunction = hideStackFrames((value, name) => {\n  if (typeof value !== 'function') throw new ERR_INVALID_ARG_TYPE(name, 'Function', value)\n})\n\n/**\n * @callback validatePlainFunction\n * @param {*} value\n * @param {string} name\n * @returns {asserts value is Function}\n */\n\n/** @type {validatePlainFunction} */\nconst validatePlainFunction = hideStackFrames((value, name) => {\n  if (typeof value !== 'function' || isAsyncFunction(value)) throw new ERR_INVALID_ARG_TYPE(name, 'Function', value)\n})\n\n/**\n * @callback validateUndefined\n * @param {*} value\n * @param {string} name\n * @returns {asserts value is undefined}\n */\n\n/** @type {validateUndefined} */\nconst validateUndefined = hideStackFrames((value, name) => {\n  if (value !== undefined) throw new ERR_INVALID_ARG_TYPE(name, 'undefined', value)\n})\n\n/**\n * @template T\n * @param {T} value\n * @param {string} name\n * @param {T[]} union\n */\nfunction validateUnion(value, name, union) {\n  if (!ArrayPrototypeIncludes(union, value)) {\n    throw new ERR_INVALID_ARG_TYPE(name, `('${ArrayPrototypeJoin(union, '|')}')`, value)\n  }\n}\n\n/*\n  The rules for the Link header field are described here:\n  https://www.rfc-editor.org/rfc/rfc8288.html#section-3\n\n  This regex validates any string surrounded by angle brackets\n  (not necessarily a valid URI reference) followed by zero or more\n  link-params separated by semicolons.\n*/\nconst linkValueRegExp = /^(?:<[^>]*>)(?:\\s*;\\s*[^;\"\\s]+(?:=(\")?[^;\"\\s]*\\1)?)*$/\n\n/**\n * @param {any} value\n * @param {string} name\n */\nfunction validateLinkHeaderFormat(value, name) {\n  if (typeof value === 'undefined' || !RegExpPrototypeExec(linkValueRegExp, value)) {\n    throw new ERR_INVALID_ARG_VALUE(\n      name,\n      value,\n      'must be an array or string of format \"</styles.css>; rel=preload; as=style\"'\n    )\n  }\n}\n\n/**\n * @param {any} hints\n * @return {string}\n */\nfunction validateLinkHeaderValue(hints) {\n  if (typeof hints === 'string') {\n    validateLinkHeaderFormat(hints, 'hints')\n    return hints\n  } else if (ArrayIsArray(hints)) {\n    const hintsLength = hints.length\n    let result = ''\n    if (hintsLength === 0) {\n      return result\n    }\n    for (let i = 0; i < hintsLength; i++) {\n      const link = hints[i]\n      validateLinkHeaderFormat(link, 'hints')\n      result += link\n      if (i !== hintsLength - 1) {\n        result += ', '\n      }\n    }\n    return result\n  }\n  throw new ERR_INVALID_ARG_VALUE(\n    'hints',\n    hints,\n    'must be an array or string of format \"</styles.css>; rel=preload; as=style\"'\n  )\n}\nmodule.exports = {\n  isInt32,\n  isUint32,\n  parseFileMode,\n  validateArray,\n  validateStringArray,\n  validateBooleanArray,\n  validateBoolean,\n  validateBuffer,\n  validateDictionary,\n  validateEncoding,\n  validateFunction,\n  validateInt32,\n  validateInteger,\n  validateNumber,\n  validateObject,\n  validateOneOf,\n  validatePlainFunction,\n  validatePort,\n  validateSignalName,\n  validateString,\n  validateUint32,\n  validateUndefined,\n  validateUnion,\n  validateAbortSignal,\n  validateLinkHeaderValue\n}\n"],"mappings":"AAAA;;AAEA,YAAY;;AAEZ,MAAM;EACJA,YAAY;EACZC,sBAAsB;EACtBC,kBAAkB;EAClBC,iBAAiB;EACjBC,eAAe;EACfC,WAAW;EACXC,sBAAsB;EACtBC,sBAAsB;EACtBC,cAAc;EACdC,6BAA6B;EAC7BC,mBAAmB;EACnBC,MAAM;EACNC,0BAA0B;EAC1BC;AACF,CAAC,GAAGC,OAAO,CAAC,qBAAqB,CAAC;AAClC,MAAM;EACJC,eAAe;EACfC,KAAK,EAAE;IAAEC,mBAAmB;IAAEC,oBAAoB;IAAEC,qBAAqB;IAAEC,gBAAgB;IAAEC;EAAmB;AAClH,CAAC,GAAGP,OAAO,CAAC,gBAAgB,CAAC;AAC7B,MAAM;EAAEQ;AAAkB,CAAC,GAAGR,OAAO,CAAC,cAAc,CAAC;AACrD,MAAM;EAAES,eAAe;EAAEC;AAAkB,CAAC,GAAGV,OAAO,CAAC,cAAc,CAAC,CAACW,KAAK;AAC5E,MAAMC,OAAO,GAAG,CAAC,CAAC;;AAElB;AACA;AACA;AACA;AACA,SAASC,OAAOA,CAACC,KAAK,EAAE;EACtB,OAAOA,KAAK,MAAMA,KAAK,GAAG,CAAC,CAAC;AAC9B;;AAEA;AACA;AACA;AACA;AACA,SAASC,QAAQA,CAACD,KAAK,EAAE;EACvB,OAAOA,KAAK,KAAKA,KAAK,KAAK,CAAC;AAC9B;AACA,MAAME,QAAQ,GAAG,UAAU;AAC3B,MAAMC,QAAQ,GAAG,sDAAsD;;AAEvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASC,aAAaA,CAACJ,KAAK,EAAEK,IAAI,EAAEC,GAAG,EAAE;EACvC,IAAI,OAAON,KAAK,KAAK,WAAW,EAAE;IAChCA,KAAK,GAAGM,GAAG;EACb;EACA,IAAI,OAAON,KAAK,KAAK,QAAQ,EAAE;IAC7B,IAAIlB,mBAAmB,CAACoB,QAAQ,EAAEF,KAAK,CAAC,KAAK,IAAI,EAAE;MACjD,MAAM,IAAIT,qBAAqB,CAACc,IAAI,EAAEL,KAAK,EAAEG,QAAQ,CAAC;IACxD;IACAH,KAAK,GAAGpB,cAAc,CAACoB,KAAK,EAAE,CAAC,CAAC;EAClC;EACAO,cAAc,CAACP,KAAK,EAAEK,IAAI,CAAC;EAC3B,OAAOL,KAAK;AACd;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,MAAMQ,eAAe,GAAGrB,eAAe,CAAC,UAACa,KAAK,EAAEK,IAAI,EAAiE;EAAA,IAA/DI,GAAG,GAAAC,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAG/B,sBAAsB;EAAA,IAAEkC,GAAG,GAAAH,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAGhC,sBAAsB;EAC9G,IAAI,OAAOsB,KAAK,KAAK,QAAQ,EAAE,MAAM,IAAIV,oBAAoB,CAACe,IAAI,EAAE,QAAQ,EAAEL,KAAK,CAAC;EACpF,IAAI,CAACxB,eAAe,CAACwB,KAAK,CAAC,EAAE,MAAM,IAAIR,gBAAgB,CAACa,IAAI,EAAE,YAAY,EAAEL,KAAK,CAAC;EAClF,IAAIA,KAAK,GAAGS,GAAG,IAAIT,KAAK,GAAGa,GAAG,EAAE,MAAM,IAAIrB,gBAAgB,CAACa,IAAI,EAAG,MAAKI,GAAI,UAASI,GAAI,EAAC,EAAEb,KAAK,CAAC;AACnG,CAAC,CAAC;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,MAAMc,aAAa,GAAG3B,eAAe,CAAC,UAACa,KAAK,EAAEK,IAAI,EAA0C;EAAA,IAAxCI,GAAG,GAAAC,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAG,CAAC,UAAU;EAAA,IAAEG,GAAG,GAAAH,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAG,UAAU;EACrF;EACA,IAAI,OAAOV,KAAK,KAAK,QAAQ,EAAE;IAC7B,MAAM,IAAIV,oBAAoB,CAACe,IAAI,EAAE,QAAQ,EAAEL,KAAK,CAAC;EACvD;EACA,IAAI,CAACxB,eAAe,CAACwB,KAAK,CAAC,EAAE;IAC3B,MAAM,IAAIR,gBAAgB,CAACa,IAAI,EAAE,YAAY,EAAEL,KAAK,CAAC;EACvD;EACA,IAAIA,KAAK,GAAGS,GAAG,IAAIT,KAAK,GAAGa,GAAG,EAAE;IAC9B,MAAM,IAAIrB,gBAAgB,CAACa,IAAI,EAAG,MAAKI,GAAI,UAASI,GAAI,EAAC,EAAEb,KAAK,CAAC;EACnE;AACF,CAAC,CAAC;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,MAAMO,cAAc,GAAGpB,eAAe,CAAC,UAACa,KAAK,EAAEK,IAAI,EAAuB;EAAA,IAArBU,QAAQ,GAAAL,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAG,KAAK;EACnE,IAAI,OAAOV,KAAK,KAAK,QAAQ,EAAE;IAC7B,MAAM,IAAIV,oBAAoB,CAACe,IAAI,EAAE,QAAQ,EAAEL,KAAK,CAAC;EACvD;EACA,IAAI,CAACxB,eAAe,CAACwB,KAAK,CAAC,EAAE;IAC3B,MAAM,IAAIR,gBAAgB,CAACa,IAAI,EAAE,YAAY,EAAEL,KAAK,CAAC;EACvD;EACA,MAAMS,GAAG,GAAGM,QAAQ,GAAG,CAAC,GAAG,CAAC;EAC5B;EACA,MAAMF,GAAG,GAAG,UAAU;EACtB,IAAIb,KAAK,GAAGS,GAAG,IAAIT,KAAK,GAAGa,GAAG,EAAE;IAC9B,MAAM,IAAIrB,gBAAgB,CAACa,IAAI,EAAG,MAAKI,GAAI,UAASI,GAAI,EAAC,EAAEb,KAAK,CAAC;EACnE;AACF,CAAC,CAAC;;AAEF;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,SAASgB,cAAcA,CAAChB,KAAK,EAAEK,IAAI,EAAE;EACnC,IAAI,OAAOL,KAAK,KAAK,QAAQ,EAAE,MAAM,IAAIV,oBAAoB,CAACe,IAAI,EAAE,QAAQ,EAAEL,KAAK,CAAC;AACtF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,SAASiB,cAAcA,CAACjB,KAAK,EAAEK,IAAI,EAAwB;EAAA,IAAtBI,GAAG,GAAAC,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAGE,SAAS;EAAA,IAAEC,GAAG,GAAAH,SAAA,CAAAC,MAAA,OAAAD,SAAA,MAAAE,SAAA;EACvD,IAAI,OAAOZ,KAAK,KAAK,QAAQ,EAAE,MAAM,IAAIV,oBAAoB,CAACe,IAAI,EAAE,QAAQ,EAAEL,KAAK,CAAC;EACpF,IACGS,GAAG,IAAI,IAAI,IAAIT,KAAK,GAAGS,GAAG,IAC1BI,GAAG,IAAI,IAAI,IAAIb,KAAK,GAAGa,GAAI,IAC3B,CAACJ,GAAG,IAAI,IAAI,IAAII,GAAG,IAAI,IAAI,KAAKpC,WAAW,CAACuB,KAAK,CAAE,EACpD;IACA,MAAM,IAAIR,gBAAgB,CACxBa,IAAI,EACH,GAAEI,GAAG,IAAI,IAAI,GAAI,MAAKA,GAAI,EAAC,GAAG,EAAG,GAAEA,GAAG,IAAI,IAAI,IAAII,GAAG,IAAI,IAAI,GAAG,MAAM,GAAG,EAAG,GAAEA,GAAG,IAAI,IAAI,GAAI,MAAKA,GAAI,EAAC,GAAG,EAAG,EAAC,EAC/Gb,KACF,CAAC;EACH;AACF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,MAAMkB,aAAa,GAAG/B,eAAe,CAAC,CAACa,KAAK,EAAEK,IAAI,EAAEc,KAAK,KAAK;EAC5D,IAAI,CAAC9C,sBAAsB,CAAC8C,KAAK,EAAEnB,KAAK,CAAC,EAAE;IACzC,MAAMoB,OAAO,GAAG9C,kBAAkB,CAChCC,iBAAiB,CAAC4C,KAAK,EAAGE,CAAC,IAAM,OAAOA,CAAC,KAAK,QAAQ,GAAI,IAAGA,CAAE,GAAE,GAAGtC,MAAM,CAACsC,CAAC,CAAE,CAAC,EAC/E,IACF,CAAC;IACD,MAAMC,MAAM,GAAG,kBAAkB,GAAGF,OAAO;IAC3C,MAAM,IAAI7B,qBAAqB,CAACc,IAAI,EAAEL,KAAK,EAAEsB,MAAM,CAAC;EACtD;AACF,CAAC,CAAC;;AAEF;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,SAASC,eAAeA,CAACvB,KAAK,EAAEK,IAAI,EAAE;EACpC,IAAI,OAAOL,KAAK,KAAK,SAAS,EAAE,MAAM,IAAIV,oBAAoB,CAACe,IAAI,EAAE,SAAS,EAAEL,KAAK,CAAC;AACxF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAASwB,4BAA4BA,CAACC,OAAO,EAAEC,GAAG,EAAEC,YAAY,EAAE;EAChE,OAAOF,OAAO,IAAI,IAAI,IAAI,CAAC5C,6BAA6B,CAAC4C,OAAO,EAAEC,GAAG,CAAC,GAAGC,YAAY,GAAGF,OAAO,CAACC,GAAG,CAAC;AACtG;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,MAAME,cAAc,GAAGzC,eAAe,CAAC,UAACa,KAAK,EAAEK,IAAI,EAAqB;EAAA,IAAnBoB,OAAO,GAAAf,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAG,IAAI;EACjE,MAAMmB,UAAU,GAAGL,4BAA4B,CAACC,OAAO,EAAE,YAAY,EAAE,KAAK,CAAC;EAC7E,MAAMK,aAAa,GAAGN,4BAA4B,CAACC,OAAO,EAAE,eAAe,EAAE,KAAK,CAAC;EACnF,MAAMM,QAAQ,GAAGP,4BAA4B,CAACC,OAAO,EAAE,UAAU,EAAE,KAAK,CAAC;EACzE,IACG,CAACM,QAAQ,IAAI/B,KAAK,KAAK,IAAI,IAC3B,CAAC6B,UAAU,IAAIzD,YAAY,CAAC4B,KAAK,CAAE,IACnC,OAAOA,KAAK,KAAK,QAAQ,KAAK,CAAC8B,aAAa,IAAI,OAAO9B,KAAK,KAAK,UAAU,CAAE,EAC9E;IACA,MAAM,IAAIV,oBAAoB,CAACe,IAAI,EAAE,QAAQ,EAAEL,KAAK,CAAC;EACvD;AACF,CAAC,CAAC;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,MAAMgC,kBAAkB,GAAG7C,eAAe,CAAC,CAACa,KAAK,EAAEK,IAAI,KAAK;EAC1D,IAAIL,KAAK,IAAI,IAAI,IAAI,OAAOA,KAAK,KAAK,QAAQ,IAAI,OAAOA,KAAK,KAAK,UAAU,EAAE;IAC7E,MAAM,IAAIV,oBAAoB,CAACe,IAAI,EAAE,cAAc,EAAEL,KAAK,CAAC;EAC7D;AACF,CAAC,CAAC;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,MAAMiC,aAAa,GAAG9C,eAAe,CAAC,UAACa,KAAK,EAAEK,IAAI,EAAoB;EAAA,IAAlB6B,SAAS,GAAAxB,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAG,CAAC;EAC/D,IAAI,CAACtC,YAAY,CAAC4B,KAAK,CAAC,EAAE;IACxB,MAAM,IAAIV,oBAAoB,CAACe,IAAI,EAAE,OAAO,EAAEL,KAAK,CAAC;EACtD;EACA,IAAIA,KAAK,CAACW,MAAM,GAAGuB,SAAS,EAAE;IAC5B,MAAMZ,MAAM,GAAI,uBAAsBY,SAAU,EAAC;IACjD,MAAM,IAAI3C,qBAAqB,CAACc,IAAI,EAAEL,KAAK,EAAEsB,MAAM,CAAC;EACtD;AACF,CAAC,CAAC;;AAEF;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,SAASa,mBAAmBA,CAACnC,KAAK,EAAEK,IAAI,EAAE;EACxC4B,aAAa,CAACjC,KAAK,EAAEK,IAAI,CAAC;EAC1B,KAAK,IAAI+B,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGpC,KAAK,CAACW,MAAM,EAAEyB,CAAC,EAAE,EAAE;IACrCpB,cAAc,CAAChB,KAAK,CAACoC,CAAC,CAAC,EAAG,GAAE/B,IAAK,IAAG+B,CAAE,GAAE,CAAC;EAC3C;AACF;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,SAASC,oBAAoBA,CAACrC,KAAK,EAAEK,IAAI,EAAE;EACzC4B,aAAa,CAACjC,KAAK,EAAEK,IAAI,CAAC;EAC1B,KAAK,IAAI+B,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGpC,KAAK,CAACW,MAAM,EAAEyB,CAAC,EAAE,EAAE;IACrCb,eAAe,CAACvB,KAAK,CAACoC,CAAC,CAAC,EAAG,GAAE/B,IAAK,IAAG+B,CAAE,GAAE,CAAC;EAC5C;AACF;;AAEA;AACA;AACA;AACA;AACA;AACA,SAASE,kBAAkBA,CAACC,MAAM,EAAmB;EAAA,IAAjBlC,IAAI,GAAAK,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAG,QAAQ;EACjDM,cAAc,CAACuB,MAAM,EAAElC,IAAI,CAAC;EAC5B,IAAIP,OAAO,CAACyC,MAAM,CAAC,KAAK3B,SAAS,EAAE;IACjC,IAAId,OAAO,CAACd,0BAA0B,CAACuD,MAAM,CAAC,CAAC,KAAK3B,SAAS,EAAE;MAC7D,MAAM,IAAInB,kBAAkB,CAAC8C,MAAM,GAAG,yCAAyC,CAAC;IAClF;IACA,MAAM,IAAI9C,kBAAkB,CAAC8C,MAAM,CAAC;EACtC;AACF;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,MAAMC,cAAc,GAAGrD,eAAe,CAAC,UAACsD,MAAM,EAAsB;EAAA,IAApBpC,IAAI,GAAAK,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAG,QAAQ;EAC7D,IAAI,CAACd,iBAAiB,CAAC6C,MAAM,CAAC,EAAE;IAC9B,MAAM,IAAInD,oBAAoB,CAACe,IAAI,EAAE,CAAC,QAAQ,EAAE,YAAY,EAAE,UAAU,CAAC,EAAEoC,MAAM,CAAC;EACpF;AACF,CAAC,CAAC;;AAEF;AACA;AACA;AACA;AACA,SAASC,gBAAgBA,CAACC,IAAI,EAAEC,QAAQ,EAAE;EACxC,MAAMC,kBAAkB,GAAGnD,iBAAiB,CAACkD,QAAQ,CAAC;EACtD,MAAMjC,MAAM,GAAGgC,IAAI,CAAChC,MAAM;EAC1B,IAAIkC,kBAAkB,KAAK,KAAK,IAAIlC,MAAM,GAAG,CAAC,KAAK,CAAC,EAAE;IACpD,MAAM,IAAIpB,qBAAqB,CAAC,UAAU,EAAEqD,QAAQ,EAAG,iCAAgCjC,MAAO,EAAC,CAAC;EAClG;AACF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASmC,YAAYA,CAACC,IAAI,EAAmC;EAAA,IAAjC1C,IAAI,GAAAK,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAG,MAAM;EAAA,IAAEsC,SAAS,GAAAtC,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAG,IAAI;EACzD,IACG,OAAOqC,IAAI,KAAK,QAAQ,IAAI,OAAOA,IAAI,KAAK,QAAQ,IACpD,OAAOA,IAAI,KAAK,QAAQ,IAAI9D,mBAAmB,CAAC8D,IAAI,CAAC,CAACpC,MAAM,KAAK,CAAE,IACpE,CAACoC,IAAI,KAAK,CAACA,IAAI,KAAK,CAAC,IACrBA,IAAI,GAAG,MAAM,IACZA,IAAI,KAAK,CAAC,IAAI,CAACC,SAAU,EAC1B;IACA,MAAM,IAAI3D,mBAAmB,CAACgB,IAAI,EAAE0C,IAAI,EAAEC,SAAS,CAAC;EACtD;EACA,OAAOD,IAAI,GAAG,CAAC;AACjB;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,MAAME,mBAAmB,GAAG9D,eAAe,CAAC,CAACoD,MAAM,EAAElC,IAAI,KAAK;EAC5D,IAAIkC,MAAM,KAAK3B,SAAS,KAAK2B,MAAM,KAAK,IAAI,IAAI,OAAOA,MAAM,KAAK,QAAQ,IAAI,EAAE,SAAS,IAAIA,MAAM,CAAC,CAAC,EAAE;IACrG,MAAM,IAAIjD,oBAAoB,CAACe,IAAI,EAAE,aAAa,EAAEkC,MAAM,CAAC;EAC7D;AACF,CAAC,CAAC;;AAEF;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,MAAMW,gBAAgB,GAAG/D,eAAe,CAAC,CAACa,KAAK,EAAEK,IAAI,KAAK;EACxD,IAAI,OAAOL,KAAK,KAAK,UAAU,EAAE,MAAM,IAAIV,oBAAoB,CAACe,IAAI,EAAE,UAAU,EAAEL,KAAK,CAAC;AAC1F,CAAC,CAAC;;AAEF;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,MAAMmD,qBAAqB,GAAGhE,eAAe,CAAC,CAACa,KAAK,EAAEK,IAAI,KAAK;EAC7D,IAAI,OAAOL,KAAK,KAAK,UAAU,IAAIL,eAAe,CAACK,KAAK,CAAC,EAAE,MAAM,IAAIV,oBAAoB,CAACe,IAAI,EAAE,UAAU,EAAEL,KAAK,CAAC;AACpH,CAAC,CAAC;;AAEF;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,MAAMoD,iBAAiB,GAAGjE,eAAe,CAAC,CAACa,KAAK,EAAEK,IAAI,KAAK;EACzD,IAAIL,KAAK,KAAKY,SAAS,EAAE,MAAM,IAAItB,oBAAoB,CAACe,IAAI,EAAE,WAAW,EAAEL,KAAK,CAAC;AACnF,CAAC,CAAC;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA,SAASqD,aAAaA,CAACrD,KAAK,EAAEK,IAAI,EAAEiD,KAAK,EAAE;EACzC,IAAI,CAACjF,sBAAsB,CAACiF,KAAK,EAAEtD,KAAK,CAAC,EAAE;IACzC,MAAM,IAAIV,oBAAoB,CAACe,IAAI,EAAG,KAAI/B,kBAAkB,CAACgF,KAAK,EAAE,GAAG,CAAE,IAAG,EAAEtD,KAAK,CAAC;EACtF;AACF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAMuD,eAAe,GAAG,uDAAuD;;AAE/E;AACA;AACA;AACA;AACA,SAASC,wBAAwBA,CAACxD,KAAK,EAAEK,IAAI,EAAE;EAC7C,IAAI,OAAOL,KAAK,KAAK,WAAW,IAAI,CAAClB,mBAAmB,CAACyE,eAAe,EAAEvD,KAAK,CAAC,EAAE;IAChF,MAAM,IAAIT,qBAAqB,CAC7Bc,IAAI,EACJL,KAAK,EACL,6EACF,CAAC;EACH;AACF;;AAEA;AACA;AACA;AACA;AACA,SAASyD,uBAAuBA,CAACC,KAAK,EAAE;EACtC,IAAI,OAAOA,KAAK,KAAK,QAAQ,EAAE;IAC7BF,wBAAwB,CAACE,KAAK,EAAE,OAAO,CAAC;IACxC,OAAOA,KAAK;EACd,CAAC,MAAM,IAAItF,YAAY,CAACsF,KAAK,CAAC,EAAE;IAC9B,MAAMC,WAAW,GAAGD,KAAK,CAAC/C,MAAM;IAChC,IAAIiD,MAAM,GAAG,EAAE;IACf,IAAID,WAAW,KAAK,CAAC,EAAE;MACrB,OAAOC,MAAM;IACf;IACA,KAAK,IAAIxB,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGuB,WAAW,EAAEvB,CAAC,EAAE,EAAE;MACpC,MAAMyB,IAAI,GAAGH,KAAK,CAACtB,CAAC,CAAC;MACrBoB,wBAAwB,CAACK,IAAI,EAAE,OAAO,CAAC;MACvCD,MAAM,IAAIC,IAAI;MACd,IAAIzB,CAAC,KAAKuB,WAAW,GAAG,CAAC,EAAE;QACzBC,MAAM,IAAI,IAAI;MAChB;IACF;IACA,OAAOA,MAAM;EACf;EACA,MAAM,IAAIrE,qBAAqB,CAC7B,OAAO,EACPmE,KAAK,EACL,6EACF,CAAC;AACH;AACAI,MAAM,CAACC,OAAO,GAAG;EACfhE,OAAO;EACPE,QAAQ;EACRG,aAAa;EACb6B,aAAa;EACbE,mBAAmB;EACnBE,oBAAoB;EACpBd,eAAe;EACfiB,cAAc;EACdR,kBAAkB;EAClBU,gBAAgB;EAChBQ,gBAAgB;EAChBpC,aAAa;EACbN,eAAe;EACfS,cAAc;EACdW,cAAc;EACdV,aAAa;EACbiC,qBAAqB;EACrBL,YAAY;EACZR,kBAAkB;EAClBtB,cAAc;EACdT,cAAc;EACd6C,iBAAiB;EACjBC,aAAa;EACbJ,mBAAmB;EACnBQ;AACF,CAAC"},"metadata":{},"sourceType":"script"}