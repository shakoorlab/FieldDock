{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nconst readable_stream_1 = require(\"readable-stream\");\nconst streamsOpts = {\n  objectMode: true\n};\nconst defaultStoreOptions = {\n  clean: true\n};\nclass Store {\n  constructor(options) {\n    this.options = options || {};\n    this.options = Object.assign(Object.assign({}, defaultStoreOptions), options);\n    this._inflights = new Map();\n  }\n  put(packet, cb) {\n    this._inflights.set(packet.messageId, packet);\n    if (cb) {\n      cb();\n    }\n    return this;\n  }\n  createStream() {\n    const stream = new readable_stream_1.Readable(streamsOpts);\n    const values = [];\n    let destroyed = false;\n    let i = 0;\n    this._inflights.forEach((value, key) => {\n      values.push(value);\n    });\n    stream._read = () => {\n      if (!destroyed && i < values.length) {\n        stream.push(values[i++]);\n      } else {\n        stream.push(null);\n      }\n    };\n    stream.destroy = err => {\n      if (destroyed) {\n        return;\n      }\n      destroyed = true;\n      setTimeout(() => {\n        stream.emit('close');\n      }, 0);\n      return stream;\n    };\n    return stream;\n  }\n  del(packet, cb) {\n    const toDelete = this._inflights.get(packet.messageId);\n    if (toDelete) {\n      this._inflights.delete(packet.messageId);\n      cb(null, toDelete);\n    } else if (cb) {\n      cb(new Error('missing packet'));\n    }\n    return this;\n  }\n  get(packet, cb) {\n    const storedPacket = this._inflights.get(packet.messageId);\n    if (storedPacket) {\n      cb(null, storedPacket);\n    } else if (cb) {\n      cb(new Error('missing packet'));\n    }\n    return this;\n  }\n  close(cb) {\n    if (this.options.clean) {\n      this._inflights = null;\n    }\n    if (cb) {\n      cb();\n    }\n  }\n}\nexports.default = Store;","map":{"version":3,"names":["readable_stream_1","require","streamsOpts","objectMode","defaultStoreOptions","clean","Store","constructor","options","Object","assign","_inflights","Map","put","packet","cb","set","messageId","createStream","stream","Readable","values","destroyed","i","forEach","value","key","push","_read","length","destroy","err","setTimeout","emit","del","toDelete","get","delete","Error","storedPacket","close","exports","default"],"sources":["/Users/jstanton/Coding/FieldDock/FieldDockMain/node_modules/mqtt/src/lib/store.ts"],"sourcesContent":["/**\n * Module dependencies\n */\nimport { Readable } from 'readable-stream'\nimport { Packet } from 'mqtt-packet'\nimport { DoneCallback } from './shared'\n\nconst streamsOpts = { objectMode: true }\nconst defaultStoreOptions = {\n\tclean: true,\n}\n\nexport interface IStoreOptions {\n\t/**\n\t * true, clear _inflights at close\n\t */\n\tclean?: boolean\n}\n\nexport type PacketCallback = (error?: Error, packet?: Packet) => void\n\nexport interface IStore {\n\t/**\n\t * Adds a packet to the store, a packet is\n\t * anything that has a messageId property.\n\t *\n\t */\n\tput(packet: Packet, cb: DoneCallback): IStore\n\n\t/**\n\t * Creates a stream with all the packets in the store\n\t *\n\t */\n\tcreateStream(): Readable\n\n\t/**\n\t * deletes a packet from the store.\n\t */\n\tdel(packet: Pick<Packet, 'messageId'>, cb: PacketCallback): IStore\n\n\t/**\n\t * get a packet from the store.\n\t */\n\tget(packet: Pick<Packet, 'messageId'>, cb: PacketCallback): IStore\n\n\t/**\n\t * Close the store\n\t */\n\tclose(cb: DoneCallback): void\n}\n\n/**\n * In-memory implementation of the message store\n * This can actually be saved into files.\n *\n * @param {Object} [options] - store options\n */\nexport default class Store implements IStore {\n\tprivate options: IStoreOptions\n\n\tprivate _inflights: Map<number, Packet>\n\n\tconstructor(options?: IStoreOptions) {\n\t\tthis.options = options || {}\n\n\t\t// Defaults\n\t\tthis.options = { ...defaultStoreOptions, ...options }\n\n\t\tthis._inflights = new Map()\n\t}\n\n\t/**\n\t * Adds a packet to the store, a packet is\n\t * anything that has a messageId property.\n\t *\n\t */\n\tput(packet: Packet, cb: DoneCallback) {\n\t\tthis._inflights.set(packet.messageId, packet)\n\n\t\tif (cb) {\n\t\t\tcb()\n\t\t}\n\n\t\treturn this\n\t}\n\n\t/**\n\t * Creates a stream with all the packets in the store\n\t *\n\t */\n\tcreateStream() {\n\t\tconst stream = new Readable(streamsOpts)\n\t\tconst values = []\n\t\tlet destroyed = false\n\t\tlet i = 0\n\n\t\tthis._inflights.forEach((value, key) => {\n\t\t\tvalues.push(value)\n\t\t})\n\n\t\tstream._read = () => {\n\t\t\tif (!destroyed && i < values.length) {\n\t\t\t\tstream.push(values[i++])\n\t\t\t} else {\n\t\t\t\tstream.push(null)\n\t\t\t}\n\t\t}\n\n\t\tstream.destroy = (err) => {\n\t\t\tif (destroyed) {\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tdestroyed = true\n\n\t\t\tsetTimeout(() => {\n\t\t\t\tstream.emit('close')\n\t\t\t}, 0)\n\n\t\t\treturn stream\n\t\t}\n\n\t\treturn stream\n\t}\n\n\t/**\n\t * deletes a packet from the store.\n\t */\n\tdel(packet: Pick<Packet, 'messageId'>, cb: PacketCallback) {\n\t\tconst toDelete = this._inflights.get(packet.messageId)\n\t\tif (toDelete) {\n\t\t\tthis._inflights.delete(packet.messageId)\n\t\t\tcb(null, toDelete)\n\t\t} else if (cb) {\n\t\t\tcb(new Error('missing packet'))\n\t\t}\n\n\t\treturn this\n\t}\n\n\t/**\n\t * get a packet from the store.\n\t */\n\tget(packet: Pick<Packet, 'messageId'>, cb: PacketCallback) {\n\t\tconst storedPacket = this._inflights.get(packet.messageId)\n\t\tif (storedPacket) {\n\t\t\tcb(null, storedPacket)\n\t\t} else if (cb) {\n\t\t\tcb(new Error('missing packet'))\n\t\t}\n\n\t\treturn this\n\t}\n\n\t/**\n\t * Close the store\n\t */\n\tclose(cb: DoneCallback) {\n\t\tif (this.options.clean) {\n\t\t\tthis._inflights = null\n\t\t}\n\t\tif (cb) {\n\t\t\tcb()\n\t\t}\n\t}\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}