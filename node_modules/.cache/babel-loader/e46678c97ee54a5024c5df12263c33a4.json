{"ast":null,"code":"import _isEqual from \"lodash/isEqual\";\nimport _sortBy from \"lodash/sortBy\";\nimport _upperFirst from \"lodash/upperFirst\";\nimport _isString from \"lodash/isString\";\nimport _isNaN from \"lodash/isNaN\";\nimport _isArray from \"lodash/isArray\";\nimport _max from \"lodash/max\";\nimport _min from \"lodash/min\";\nimport _flatMap from \"lodash/flatMap\";\nimport _isFunction from \"lodash/isFunction\";\nimport _get from \"lodash/get\";\nimport _isNil from \"lodash/isNil\";\n\nfunction _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) {\n    return typeof obj;\n  } : function (obj) {\n    return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n  }, _typeof(obj);\n}\n\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n}\n\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter);\n}\n\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\n\n  return arr2;\n}\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    enumerableOnly && (symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    })), keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = null != arguments[i] ? arguments[i] : {};\n    i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {\n      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n    });\n  }\n\n  return target;\n}\n\nfunction _defineProperty(obj, key, value) {\n  key = _toPropertyKey(key);\n\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction _toPropertyKey(arg) {\n  var key = _toPrimitive(arg, \"string\");\n\n  return _typeof(key) === \"symbol\" ? key : String(key);\n}\n\nfunction _toPrimitive(input, hint) {\n  if (_typeof(input) !== \"object\" || input === null) return input;\n  var prim = input[Symbol.toPrimitive];\n\n  if (prim !== undefined) {\n    var res = prim.call(input, hint || \"default\");\n    if (_typeof(res) !== \"object\") return res;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n\n  return (hint === \"string\" ? String : Number)(input);\n}\n\nimport * as d3Scales from 'victory-vendor/d3-scale';\nimport { stack as shapeStack, stackOffsetExpand, stackOffsetNone, stackOffsetSilhouette, stackOffsetWiggle, stackOrderNone } from 'victory-vendor/d3-shape';\nimport { getNiceTickValues, getTickValuesFixedDomain } from 'recharts-scale';\nimport { ErrorBar } from '../cartesian/ErrorBar';\nimport { Legend } from '../component/Legend';\nimport { findEntryInArray, getPercentValue, isNumber, isNumOrStr, mathSign, uniqueId } from './DataUtils';\nimport { filterProps, findAllByType, findChildByType, getDisplayName } from './ReactUtils'; // TODO: Cause of circular dependency. Needs refactor.\n// import { RadiusAxisProps, AngleAxisProps } from '../polar/types';\n\nexport function getValueByDataKey(obj, dataKey, defaultValue) {\n  if (_isNil(obj) || _isNil(dataKey)) {\n    return defaultValue;\n  }\n\n  if (isNumOrStr(dataKey)) {\n    return _get(obj, dataKey, defaultValue);\n  }\n\n  if (_isFunction(dataKey)) {\n    return dataKey(obj);\n  }\n\n  return defaultValue;\n}\n/**\n * Get domain of data by key\n * @param  {Array}   data      The data displayed in the chart\n * @param  {String}  key       The unique key of a group of data\n * @param  {String}  type      The type of axis\n * @param  {Boolean} filterNil Whether or not filter nil values\n * @return {Array} Domain of data\n */\n\nexport function getDomainOfDataByKey(data, key, type, filterNil) {\n  var flattenData = _flatMap(data, function (entry) {\n    return getValueByDataKey(entry, key);\n  });\n\n  if (type === 'number') {\n    var domain = flattenData.filter(function (entry) {\n      return isNumber(entry) || parseFloat(entry);\n    });\n    return domain.length ? [_min(domain), _max(domain)] : [Infinity, -Infinity];\n  }\n\n  var validateData = filterNil ? flattenData.filter(function (entry) {\n    return !_isNil(entry);\n  }) : flattenData; // 支持Date类型的x轴\n\n  return validateData.map(function (entry) {\n    return isNumOrStr(entry) || entry instanceof Date ? entry : '';\n  });\n}\nexport var calculateActiveTickIndex = function calculateActiveTickIndex(coordinate) {\n  var _ticks$length;\n\n  var ticks = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n  var unsortedTicks = arguments.length > 2 ? arguments[2] : undefined;\n  var axis = arguments.length > 3 ? arguments[3] : undefined;\n  var index = -1;\n  var len = (_ticks$length = ticks === null || ticks === void 0 ? void 0 : ticks.length) !== null && _ticks$length !== void 0 ? _ticks$length : 0; // if there are 1 or less ticks ticks then the active tick is at index 0\n\n  if (len <= 1) {\n    return 0;\n  }\n\n  if (axis && axis.axisType === 'angleAxis' && Math.abs(Math.abs(axis.range[1] - axis.range[0]) - 360) <= 1e-6) {\n    var range = axis.range; // ticks are distributed in a circle\n\n    for (var i = 0; i < len; i++) {\n      var before = i > 0 ? unsortedTicks[i - 1].coordinate : unsortedTicks[len - 1].coordinate;\n      var cur = unsortedTicks[i].coordinate;\n      var after = i >= len - 1 ? unsortedTicks[0].coordinate : unsortedTicks[i + 1].coordinate;\n      var sameDirectionCoord = void 0;\n\n      if (mathSign(cur - before) !== mathSign(after - cur)) {\n        var diffInterval = [];\n\n        if (mathSign(after - cur) === mathSign(range[1] - range[0])) {\n          sameDirectionCoord = after;\n          var curInRange = cur + range[1] - range[0];\n          diffInterval[0] = Math.min(curInRange, (curInRange + before) / 2);\n          diffInterval[1] = Math.max(curInRange, (curInRange + before) / 2);\n        } else {\n          sameDirectionCoord = before;\n          var afterInRange = after + range[1] - range[0];\n          diffInterval[0] = Math.min(cur, (afterInRange + cur) / 2);\n          diffInterval[1] = Math.max(cur, (afterInRange + cur) / 2);\n        }\n\n        var sameInterval = [Math.min(cur, (sameDirectionCoord + cur) / 2), Math.max(cur, (sameDirectionCoord + cur) / 2)];\n\n        if (coordinate > sameInterval[0] && coordinate <= sameInterval[1] || coordinate >= diffInterval[0] && coordinate <= diffInterval[1]) {\n          index = unsortedTicks[i].index;\n          break;\n        }\n      } else {\n        var min = Math.min(before, after);\n        var max = Math.max(before, after);\n\n        if (coordinate > (min + cur) / 2 && coordinate <= (max + cur) / 2) {\n          index = unsortedTicks[i].index;\n          break;\n        }\n      }\n    }\n  } else {\n    // ticks are distributed in a single direction\n    for (var _i = 0; _i < len; _i++) {\n      if (_i === 0 && coordinate <= (ticks[_i].coordinate + ticks[_i + 1].coordinate) / 2 || _i > 0 && _i < len - 1 && coordinate > (ticks[_i].coordinate + ticks[_i - 1].coordinate) / 2 && coordinate <= (ticks[_i].coordinate + ticks[_i + 1].coordinate) / 2 || _i === len - 1 && coordinate > (ticks[_i].coordinate + ticks[_i - 1].coordinate) / 2) {\n        index = ticks[_i].index;\n        break;\n      }\n    }\n  }\n\n  return index;\n};\n/**\n * Get the main color of each graphic item\n * @param  {ReactElement} item A graphic item\n * @return {String}            Color\n */\n\nexport var getMainColorOfGraphicItem = function getMainColorOfGraphicItem(item) {\n  var _ref = item,\n      displayName = _ref.type.displayName; // TODO: check if displayName is valid.\n\n  var _item$props = item.props,\n      stroke = _item$props.stroke,\n      fill = _item$props.fill;\n  var result;\n\n  switch (displayName) {\n    case 'Line':\n      result = stroke;\n      break;\n\n    case 'Area':\n    case 'Radar':\n      result = stroke && stroke !== 'none' ? stroke : fill;\n      break;\n\n    default:\n      result = fill;\n      break;\n  }\n\n  return result;\n};\nexport var getLegendProps = function getLegendProps(_ref2) {\n  var children = _ref2.children,\n      formattedGraphicalItems = _ref2.formattedGraphicalItems,\n      legendWidth = _ref2.legendWidth,\n      legendContent = _ref2.legendContent;\n  var legendItem = findChildByType(children, Legend);\n\n  if (!legendItem) {\n    return null;\n  }\n\n  var legendData;\n\n  if (legendItem.props && legendItem.props.payload) {\n    legendData = legendItem.props && legendItem.props.payload;\n  } else if (legendContent === 'children') {\n    legendData = (formattedGraphicalItems || []).reduce(function (result, _ref3) {\n      var item = _ref3.item,\n          props = _ref3.props;\n      var data = props.sectors || props.data || [];\n      return result.concat(data.map(function (entry) {\n        return {\n          type: legendItem.props.iconType || item.props.legendType,\n          value: entry.name,\n          color: entry.fill,\n          payload: entry\n        };\n      }));\n    }, []);\n  } else {\n    legendData = (formattedGraphicalItems || []).map(function (_ref4) {\n      var item = _ref4.item;\n      var _item$props2 = item.props,\n          dataKey = _item$props2.dataKey,\n          name = _item$props2.name,\n          legendType = _item$props2.legendType,\n          hide = _item$props2.hide;\n      return {\n        inactive: hide,\n        dataKey: dataKey,\n        type: legendItem.props.iconType || legendType || 'square',\n        color: getMainColorOfGraphicItem(item),\n        value: name || dataKey,\n        payload: item.props\n      };\n    });\n  }\n\n  return _objectSpread(_objectSpread(_objectSpread({}, legendItem.props), Legend.getWithHeight(legendItem, legendWidth)), {}, {\n    payload: legendData,\n    item: legendItem\n  });\n};\n/**\n * Calculate the size of all groups for stacked bar graph\n * @param  {Object} stackGroups The items grouped by axisId and stackId\n * @return {Object} The size of all groups\n */\n\nexport var getBarSizeList = function getBarSizeList(_ref5) {\n  var globalSize = _ref5.barSize,\n      _ref5$stackGroups = _ref5.stackGroups,\n      stackGroups = _ref5$stackGroups === void 0 ? {} : _ref5$stackGroups;\n\n  if (!stackGroups) {\n    return {};\n  }\n\n  var result = {};\n  var numericAxisIds = Object.keys(stackGroups);\n\n  for (var i = 0, len = numericAxisIds.length; i < len; i++) {\n    var sgs = stackGroups[numericAxisIds[i]].stackGroups;\n    var stackIds = Object.keys(sgs);\n\n    for (var j = 0, sLen = stackIds.length; j < sLen; j++) {\n      var _sgs$stackIds$j = sgs[stackIds[j]],\n          items = _sgs$stackIds$j.items,\n          cateAxisId = _sgs$stackIds$j.cateAxisId;\n      var barItems = items.filter(function (item) {\n        return getDisplayName(item.type).indexOf('Bar') >= 0;\n      });\n\n      if (barItems && barItems.length) {\n        var selfSize = barItems[0].props.barSize;\n        var cateId = barItems[0].props[cateAxisId];\n\n        if (!result[cateId]) {\n          result[cateId] = [];\n        }\n\n        result[cateId].push({\n          item: barItems[0],\n          stackList: barItems.slice(1),\n          barSize: _isNil(selfSize) ? globalSize : selfSize\n        });\n      }\n    }\n  }\n\n  return result;\n};\n/**\n * Calculate the size of each bar and the gap between two bars\n * @param  {Number} bandSize  The size of each category\n * @param  {sizeList} sizeList  The size of all groups\n * @param  {maxBarSize} maxBarSize The maximum size of bar\n * @return {Number} The size of each bar and the gap between two bars\n */\n\nexport var getBarPosition = function getBarPosition(_ref6) {\n  var barGap = _ref6.barGap,\n      barCategoryGap = _ref6.barCategoryGap,\n      bandSize = _ref6.bandSize,\n      _ref6$sizeList = _ref6.sizeList,\n      sizeList = _ref6$sizeList === void 0 ? [] : _ref6$sizeList,\n      maxBarSize = _ref6.maxBarSize;\n  var len = sizeList.length;\n  if (len < 1) return null;\n  var realBarGap = getPercentValue(barGap, bandSize, 0, true);\n  var result; // whether or not is barSize setted by user\n\n  if (sizeList[0].barSize === +sizeList[0].barSize) {\n    var useFull = false;\n    var fullBarSize = bandSize / len;\n    var sum = sizeList.reduce(function (res, entry) {\n      return res + entry.barSize || 0;\n    }, 0);\n    sum += (len - 1) * realBarGap;\n\n    if (sum >= bandSize) {\n      sum -= (len - 1) * realBarGap;\n      realBarGap = 0;\n    }\n\n    if (sum >= bandSize && fullBarSize > 0) {\n      useFull = true;\n      fullBarSize *= 0.9;\n      sum = len * fullBarSize;\n    }\n\n    var offset = (bandSize - sum) / 2 >> 0;\n    var prev = {\n      offset: offset - realBarGap,\n      size: 0\n    };\n    result = sizeList.reduce(function (res, entry) {\n      var newRes = [].concat(_toConsumableArray(res), [{\n        item: entry.item,\n        position: {\n          offset: prev.offset + prev.size + realBarGap,\n          size: useFull ? fullBarSize : entry.barSize\n        }\n      }]);\n      prev = newRes[newRes.length - 1].position;\n\n      if (entry.stackList && entry.stackList.length) {\n        entry.stackList.forEach(function (item) {\n          newRes.push({\n            item: item,\n            position: prev\n          });\n        });\n      }\n\n      return newRes;\n    }, []);\n  } else {\n    var _offset = getPercentValue(barCategoryGap, bandSize, 0, true);\n\n    if (bandSize - 2 * _offset - (len - 1) * realBarGap <= 0) {\n      realBarGap = 0;\n    }\n\n    var originalSize = (bandSize - 2 * _offset - (len - 1) * realBarGap) / len;\n\n    if (originalSize > 1) {\n      originalSize >>= 0;\n    }\n\n    var size = maxBarSize === +maxBarSize ? Math.min(originalSize, maxBarSize) : originalSize;\n    result = sizeList.reduce(function (res, entry, i) {\n      var newRes = [].concat(_toConsumableArray(res), [{\n        item: entry.item,\n        position: {\n          offset: _offset + (originalSize + realBarGap) * i + (originalSize - size) / 2,\n          size: size\n        }\n      }]);\n\n      if (entry.stackList && entry.stackList.length) {\n        entry.stackList.forEach(function (item) {\n          newRes.push({\n            item: item,\n            position: newRes[newRes.length - 1].position\n          });\n        });\n      }\n\n      return newRes;\n    }, []);\n  }\n\n  return result;\n};\nexport var appendOffsetOfLegend = function appendOffsetOfLegend(offset, items, props, legendBox) {\n  var children = props.children,\n      width = props.width,\n      margin = props.margin;\n  var legendWidth = width - (margin.left || 0) - (margin.right || 0); // const legendHeight = height - (margin.top || 0) - (margin.bottom || 0);\n\n  var legendProps = getLegendProps({\n    children: children,\n    legendWidth: legendWidth\n  });\n  var newOffset = offset;\n\n  if (legendProps) {\n    var box = legendBox || {};\n    var align = legendProps.align,\n        verticalAlign = legendProps.verticalAlign,\n        layout = legendProps.layout;\n\n    if ((layout === 'vertical' || layout === 'horizontal' && verticalAlign === 'middle') && isNumber(offset[align])) {\n      newOffset = _objectSpread(_objectSpread({}, offset), {}, _defineProperty({}, align, newOffset[align] + (box.width || 0)));\n    }\n\n    if ((layout === 'horizontal' || layout === 'vertical' && align === 'center') && isNumber(offset[verticalAlign])) {\n      newOffset = _objectSpread(_objectSpread({}, offset), {}, _defineProperty({}, verticalAlign, newOffset[verticalAlign] + (box.height || 0)));\n    }\n  }\n\n  return newOffset;\n};\n\nvar isErrorBarRelevantForAxis = function isErrorBarRelevantForAxis(layout, axisType, direction) {\n  if (_isNil(axisType)) {\n    return true;\n  }\n\n  if (layout === 'horizontal') {\n    return axisType === 'yAxis';\n  }\n\n  if (layout === 'vertical') {\n    return axisType === 'xAxis';\n  }\n\n  if (direction === 'x') {\n    return axisType === 'xAxis';\n  }\n\n  if (direction === 'y') {\n    return axisType === 'yAxis';\n  }\n\n  return true;\n};\n\nexport var getDomainOfErrorBars = function getDomainOfErrorBars(data, item, dataKey, layout, axisType) {\n  var children = item.props.children;\n  var errorBars = findAllByType(children, ErrorBar).filter(function (errorBarChild) {\n    return isErrorBarRelevantForAxis(layout, axisType, errorBarChild.props.direction);\n  });\n\n  if (errorBars && errorBars.length) {\n    var keys = errorBars.map(function (errorBarChild) {\n      return errorBarChild.props.dataKey;\n    });\n    return data.reduce(function (result, entry) {\n      var entryValue = getValueByDataKey(entry, dataKey, 0);\n      var mainValue = _isArray(entryValue) ? [_min(entryValue), _max(entryValue)] : [entryValue, entryValue];\n      var errorDomain = keys.reduce(function (prevErrorArr, k) {\n        var errorValue = getValueByDataKey(entry, k, 0);\n        var lowerValue = mainValue[0] - Math.abs(_isArray(errorValue) ? errorValue[0] : errorValue);\n        var upperValue = mainValue[1] + Math.abs(_isArray(errorValue) ? errorValue[1] : errorValue);\n        return [Math.min(lowerValue, prevErrorArr[0]), Math.max(upperValue, prevErrorArr[1])];\n      }, [Infinity, -Infinity]);\n      return [Math.min(errorDomain[0], result[0]), Math.max(errorDomain[1], result[1])];\n    }, [Infinity, -Infinity]);\n  }\n\n  return null;\n};\nexport var parseErrorBarsOfAxis = function parseErrorBarsOfAxis(data, items, dataKey, axisType, layout) {\n  var domains = items.map(function (item) {\n    return getDomainOfErrorBars(data, item, dataKey, layout, axisType);\n  }).filter(function (entry) {\n    return !_isNil(entry);\n  });\n\n  if (domains && domains.length) {\n    return domains.reduce(function (result, entry) {\n      return [Math.min(result[0], entry[0]), Math.max(result[1], entry[1])];\n    }, [Infinity, -Infinity]);\n  }\n\n  return null;\n};\n/**\n * Get domain of data by the configuration of item element\n * @param  {Array}   data      The data displayed in the chart\n * @param  {Array}   items     The instances of item\n * @param  {String}  type      The type of axis, number - Number Axis, category - Category Axis\n * @param  {LayoutType} layout The type of layout\n * @param  {Boolean} filterNil Whether or not filter nil values\n * @return {Array}        Domain\n */\n\nexport var getDomainOfItemsWithSameAxis = function getDomainOfItemsWithSameAxis(data, items, type, layout, filterNil) {\n  var domains = items.map(function (item) {\n    var dataKey = item.props.dataKey;\n\n    if (type === 'number' && dataKey) {\n      return getDomainOfErrorBars(data, item, dataKey, layout) || getDomainOfDataByKey(data, dataKey, type, filterNil);\n    }\n\n    return getDomainOfDataByKey(data, dataKey, type, filterNil);\n  });\n\n  if (type === 'number') {\n    // Calculate the domain of number axis\n    return domains.reduce(function (result, entry) {\n      return [Math.min(result[0], entry[0]), Math.max(result[1], entry[1])];\n    }, [Infinity, -Infinity]);\n  }\n\n  var tag = {}; // Get the union set of category axis\n\n  return domains.reduce(function (result, entry) {\n    for (var i = 0, len = entry.length; i < len; i++) {\n      if (!tag[entry[i]]) {\n        tag[entry[i]] = true;\n        result.push(entry[i]);\n      }\n    }\n\n    return result;\n  }, []);\n};\nexport var isCategoricalAxis = function isCategoricalAxis(layout, axisType) {\n  return layout === 'horizontal' && axisType === 'xAxis' || layout === 'vertical' && axisType === 'yAxis' || layout === 'centric' && axisType === 'angleAxis' || layout === 'radial' && axisType === 'radiusAxis';\n};\n/**\n * Calculate the Coordinates of grid\n * @param  {Array} ticks The ticks in axis\n * @param {Number} min   The minimun value of axis\n * @param {Number} max   The maximun value of axis\n * @return {Array}       Coordinates\n */\n\nexport var getCoordinatesOfGrid = function getCoordinatesOfGrid(ticks, min, max) {\n  var hasMin, hasMax;\n  var values = ticks.map(function (entry) {\n    if (entry.coordinate === min) {\n      hasMin = true;\n    }\n\n    if (entry.coordinate === max) {\n      hasMax = true;\n    }\n\n    return entry.coordinate;\n  });\n\n  if (!hasMin) {\n    values.push(min);\n  }\n\n  if (!hasMax) {\n    values.push(max);\n  }\n\n  return values;\n};\n/**\n * Get the ticks of an axis\n * @param  {Object}  axis The configuration of an axis\n * @param {Boolean} isGrid Whether or not are the ticks in grid\n * @param {Boolean} isAll Return the ticks of all the points or not\n * @return {Array}  Ticks\n */\n\nexport var getTicksOfAxis = function getTicksOfAxis(axis, isGrid, isAll) {\n  if (!axis) return null;\n  var scale = axis.scale;\n  var duplicateDomain = axis.duplicateDomain,\n      type = axis.type,\n      range = axis.range;\n  var offsetForBand = axis.realScaleType === 'scaleBand' ? scale.bandwidth() / 2 : 2;\n  var offset = (isGrid || isAll) && type === 'category' && scale.bandwidth ? scale.bandwidth() / offsetForBand : 0;\n  offset = axis.axisType === 'angleAxis' && (range === null || range === void 0 ? void 0 : range.length) >= 2 ? mathSign(range[0] - range[1]) * 2 * offset : offset; // The ticks set by user should only affect the ticks adjacent to axis line\n\n  if (isGrid && (axis.ticks || axis.niceTicks)) {\n    var result = (axis.ticks || axis.niceTicks).map(function (entry) {\n      var scaleContent = duplicateDomain ? duplicateDomain.indexOf(entry) : entry;\n      return {\n        // If the scaleContent is not a number, the coordinate will be NaN.\n        // That could be the case for example with a PointScale and a string as domain.\n        coordinate: scale(scaleContent) + offset,\n        value: entry,\n        offset: offset\n      };\n    });\n    return result.filter(function (row) {\n      return !_isNaN(row.coordinate);\n    });\n  } // When axis is a categorial axis, but the type of axis is number or the scale of axis is not \"auto\"\n\n\n  if (axis.isCategorical && axis.categoricalDomain) {\n    return axis.categoricalDomain.map(function (entry, index) {\n      return {\n        coordinate: scale(entry) + offset,\n        value: entry,\n        index: index,\n        offset: offset\n      };\n    });\n  }\n\n  if (scale.ticks && !isAll) {\n    return scale.ticks(axis.tickCount).map(function (entry) {\n      return {\n        coordinate: scale(entry) + offset,\n        value: entry,\n        offset: offset\n      };\n    });\n  } // When axis has duplicated text, serial numbers are used to generate scale\n\n\n  return scale.domain().map(function (entry, index) {\n    return {\n      coordinate: scale(entry) + offset,\n      value: duplicateDomain ? duplicateDomain[entry] : entry,\n      index: index,\n      offset: offset\n    };\n  });\n};\n/**\n * combine the handlers\n * @param  {Function} defaultHandler Internal private handler\n * @param  {Function} parentHandler  Handler function specified in parent component\n * @param  {Function} childHandler   Handler function specified in child component\n * @return {Function}                The combined handler\n */\n\nexport var combineEventHandlers = function combineEventHandlers(defaultHandler, parentHandler, childHandler) {\n  var customizedHandler;\n\n  if (_isFunction(childHandler)) {\n    customizedHandler = childHandler;\n  } else if (_isFunction(parentHandler)) {\n    customizedHandler = parentHandler;\n  }\n\n  if (_isFunction(defaultHandler) || customizedHandler) {\n    return function (arg1, arg2, arg3, arg4) {\n      if (_isFunction(defaultHandler)) {\n        defaultHandler(arg1, arg2, arg3, arg4);\n      }\n\n      if (_isFunction(customizedHandler)) {\n        customizedHandler(arg1, arg2, arg3, arg4);\n      }\n    };\n  }\n\n  return null;\n};\n/**\n * Parse the scale function of axis\n * @param  {Object}   axis          The option of axis\n * @param  {String}   chartType     The displayName of chart\n * @param  {Boolean}  hasBar        if it has a bar\n * @return {Function}               The scale function\n */\n\nexport var parseScale = function parseScale(axis, chartType, hasBar) {\n  var scale = axis.scale,\n      type = axis.type,\n      layout = axis.layout,\n      axisType = axis.axisType;\n\n  if (scale === 'auto') {\n    if (layout === 'radial' && axisType === 'radiusAxis') {\n      return {\n        scale: d3Scales.scaleBand(),\n        realScaleType: 'band'\n      };\n    }\n\n    if (layout === 'radial' && axisType === 'angleAxis') {\n      return {\n        scale: d3Scales.scaleLinear(),\n        realScaleType: 'linear'\n      };\n    }\n\n    if (type === 'category' && chartType && (chartType.indexOf('LineChart') >= 0 || chartType.indexOf('AreaChart') >= 0 || chartType.indexOf('ComposedChart') >= 0 && !hasBar)) {\n      return {\n        scale: d3Scales.scalePoint(),\n        realScaleType: 'point'\n      };\n    }\n\n    if (type === 'category') {\n      return {\n        scale: d3Scales.scaleBand(),\n        realScaleType: 'band'\n      };\n    }\n\n    return {\n      scale: d3Scales.scaleLinear(),\n      realScaleType: 'linear'\n    };\n  }\n\n  if (_isString(scale)) {\n    var name = \"scale\".concat(_upperFirst(scale));\n    return {\n      scale: (d3Scales[name] || d3Scales.scalePoint)(),\n      realScaleType: d3Scales[name] ? name : 'point'\n    };\n  }\n\n  return _isFunction(scale) ? {\n    scale: scale\n  } : {\n    scale: d3Scales.scalePoint(),\n    realScaleType: 'point'\n  };\n};\nvar EPS = 1e-4;\nexport var checkDomainOfScale = function checkDomainOfScale(scale) {\n  var domain = scale.domain();\n\n  if (!domain || domain.length <= 2) {\n    return;\n  }\n\n  var len = domain.length;\n  var range = scale.range();\n  var min = Math.min(range[0], range[1]) - EPS;\n  var max = Math.max(range[0], range[1]) + EPS;\n  var first = scale(domain[0]);\n  var last = scale(domain[len - 1]);\n\n  if (first < min || first > max || last < min || last > max) {\n    scale.domain([domain[0], domain[len - 1]]);\n  }\n};\nexport var findPositionOfBar = function findPositionOfBar(barPosition, child) {\n  if (!barPosition) {\n    return null;\n  }\n\n  for (var i = 0, len = barPosition.length; i < len; i++) {\n    if (barPosition[i].item === child) {\n      return barPosition[i].position;\n    }\n  }\n\n  return null;\n};\nexport var truncateByDomain = function truncateByDomain(value, domain) {\n  if (!domain || domain.length !== 2 || !isNumber(domain[0]) || !isNumber(domain[1])) {\n    return value;\n  }\n\n  var min = Math.min(domain[0], domain[1]);\n  var max = Math.max(domain[0], domain[1]);\n  var result = [value[0], value[1]];\n\n  if (!isNumber(value[0]) || value[0] < min) {\n    result[0] = min;\n  }\n\n  if (!isNumber(value[1]) || value[1] > max) {\n    result[1] = max;\n  }\n\n  if (result[0] > max) {\n    result[0] = max;\n  }\n\n  if (result[1] < min) {\n    result[1] = min;\n  }\n\n  return result;\n};\n/* eslint no-param-reassign: 0 */\n\nexport var offsetSign = function offsetSign(series) {\n  var n = series.length;\n\n  if (n <= 0) {\n    return;\n  }\n\n  for (var j = 0, m = series[0].length; j < m; ++j) {\n    var positive = 0;\n    var negative = 0;\n\n    for (var i = 0; i < n; ++i) {\n      var value = _isNaN(series[i][j][1]) ? series[i][j][0] : series[i][j][1];\n      /* eslint-disable prefer-destructuring */\n\n      if (value >= 0) {\n        series[i][j][0] = positive;\n        series[i][j][1] = positive + value;\n        positive = series[i][j][1];\n      } else {\n        series[i][j][0] = negative;\n        series[i][j][1] = negative + value;\n        negative = series[i][j][1];\n      }\n      /* eslint-enable prefer-destructuring */\n\n    }\n  }\n};\nexport var offsetPositive = function offsetPositive(series) {\n  var n = series.length;\n\n  if (n <= 0) {\n    return;\n  }\n\n  for (var j = 0, m = series[0].length; j < m; ++j) {\n    var positive = 0;\n\n    for (var i = 0; i < n; ++i) {\n      var value = _isNaN(series[i][j][1]) ? series[i][j][0] : series[i][j][1];\n      /* eslint-disable prefer-destructuring */\n\n      if (value >= 0) {\n        series[i][j][0] = positive;\n        series[i][j][1] = positive + value;\n        positive = series[i][j][1];\n      } else {\n        series[i][j][0] = 0;\n        series[i][j][1] = 0;\n      }\n      /* eslint-enable prefer-destructuring */\n\n    }\n  }\n};\nvar STACK_OFFSET_MAP = {\n  sign: offsetSign,\n  expand: stackOffsetExpand,\n  none: stackOffsetNone,\n  silhouette: stackOffsetSilhouette,\n  wiggle: stackOffsetWiggle,\n  positive: offsetPositive\n};\nexport var getStackedData = function getStackedData(data, stackItems, offsetType) {\n  var dataKeys = stackItems.map(function (item) {\n    return item.props.dataKey;\n  });\n  var stack = shapeStack().keys(dataKeys).value(function (d, key) {\n    return +getValueByDataKey(d, key, 0);\n  }).order(stackOrderNone).offset(STACK_OFFSET_MAP[offsetType]);\n  return stack(data);\n};\nexport var getStackGroupsByAxisId = function getStackGroupsByAxisId(data, _items, numericAxisId, cateAxisId, offsetType, reverseStackOrder) {\n  if (!data) {\n    return null;\n  } // reversing items to affect render order (for layering)\n\n\n  var items = reverseStackOrder ? _items.reverse() : _items;\n  var stackGroups = items.reduce(function (result, item) {\n    var _item$props3 = item.props,\n        stackId = _item$props3.stackId,\n        hide = _item$props3.hide;\n\n    if (hide) {\n      return result;\n    }\n\n    var axisId = item.props[numericAxisId];\n    var parentGroup = result[axisId] || {\n      hasStack: false,\n      stackGroups: {}\n    };\n\n    if (isNumOrStr(stackId)) {\n      var childGroup = parentGroup.stackGroups[stackId] || {\n        numericAxisId: numericAxisId,\n        cateAxisId: cateAxisId,\n        items: []\n      };\n      childGroup.items.push(item);\n      parentGroup.hasStack = true;\n      parentGroup.stackGroups[stackId] = childGroup;\n    } else {\n      parentGroup.stackGroups[uniqueId('_stackId_')] = {\n        numericAxisId: numericAxisId,\n        cateAxisId: cateAxisId,\n        items: [item]\n      };\n    }\n\n    return _objectSpread(_objectSpread({}, result), {}, _defineProperty({}, axisId, parentGroup));\n  }, {});\n  return Object.keys(stackGroups).reduce(function (result, axisId) {\n    var group = stackGroups[axisId];\n\n    if (group.hasStack) {\n      group.stackGroups = Object.keys(group.stackGroups).reduce(function (res, stackId) {\n        var g = group.stackGroups[stackId];\n        return _objectSpread(_objectSpread({}, res), {}, _defineProperty({}, stackId, {\n          numericAxisId: numericAxisId,\n          cateAxisId: cateAxisId,\n          items: g.items,\n          stackedData: getStackedData(data, g.items, offsetType)\n        }));\n      }, {});\n    }\n\n    return _objectSpread(_objectSpread({}, result), {}, _defineProperty({}, axisId, group));\n  }, {});\n};\n/**\n * Configure the scale function of axis\n * @param {Object} scale The scale function\n * @param {Object} opts  The configuration of axis\n * @return {Object}      null\n */\n\nexport var getTicksOfScale = function getTicksOfScale(scale, opts) {\n  var realScaleType = opts.realScaleType,\n      type = opts.type,\n      tickCount = opts.tickCount,\n      originalDomain = opts.originalDomain,\n      allowDecimals = opts.allowDecimals;\n  var scaleType = realScaleType || opts.scale;\n\n  if (scaleType !== 'auto' && scaleType !== 'linear') {\n    return null;\n  }\n\n  if (tickCount && type === 'number' && originalDomain && (originalDomain[0] === 'auto' || originalDomain[1] === 'auto')) {\n    // Calculate the ticks by the number of grid when the axis is a number axis\n    var domain = scale.domain();\n\n    if (!domain.length) {\n      return null;\n    }\n\n    var tickValues = getNiceTickValues(domain, tickCount, allowDecimals);\n    scale.domain([_min(tickValues), _max(tickValues)]);\n    return {\n      niceTicks: tickValues\n    };\n  }\n\n  if (tickCount && type === 'number') {\n    var _domain = scale.domain();\n\n    var _tickValues = getTickValuesFixedDomain(_domain, tickCount, allowDecimals);\n\n    return {\n      niceTicks: _tickValues\n    };\n  }\n\n  return null;\n};\nexport var getCateCoordinateOfLine = function getCateCoordinateOfLine(_ref7) {\n  var axis = _ref7.axis,\n      ticks = _ref7.ticks,\n      bandSize = _ref7.bandSize,\n      entry = _ref7.entry,\n      index = _ref7.index,\n      dataKey = _ref7.dataKey;\n\n  if (axis.type === 'category') {\n    // find coordinate of category axis by the value of category\n    if (!axis.allowDuplicatedCategory && axis.dataKey && !_isNil(entry[axis.dataKey])) {\n      var matchedTick = findEntryInArray(ticks, 'value', entry[axis.dataKey]);\n\n      if (matchedTick) {\n        return matchedTick.coordinate + bandSize / 2;\n      }\n    }\n\n    return ticks[index] ? ticks[index].coordinate + bandSize / 2 : null;\n  }\n\n  var value = getValueByDataKey(entry, !_isNil(dataKey) ? dataKey : axis.dataKey);\n  return !_isNil(value) ? axis.scale(value) : null;\n};\nexport var getCateCoordinateOfBar = function getCateCoordinateOfBar(_ref8) {\n  var axis = _ref8.axis,\n      ticks = _ref8.ticks,\n      offset = _ref8.offset,\n      bandSize = _ref8.bandSize,\n      entry = _ref8.entry,\n      index = _ref8.index;\n\n  if (axis.type === 'category') {\n    return ticks[index] ? ticks[index].coordinate + offset : null;\n  }\n\n  var value = getValueByDataKey(entry, axis.dataKey, axis.domain[index]);\n  return !_isNil(value) ? axis.scale(value) - bandSize / 2 + offset : null;\n};\nexport var getBaseValueOfBar = function getBaseValueOfBar(_ref9) {\n  var numericAxis = _ref9.numericAxis;\n  var domain = numericAxis.scale.domain();\n\n  if (numericAxis.type === 'number') {\n    var min = Math.min(domain[0], domain[1]);\n    var max = Math.max(domain[0], domain[1]);\n\n    if (min <= 0 && max >= 0) {\n      return 0;\n    }\n\n    if (max < 0) {\n      return max;\n    }\n\n    return min;\n  }\n\n  return domain[0];\n};\nexport var getStackedDataOfItem = function getStackedDataOfItem(item, stackGroups) {\n  var stackId = item.props.stackId;\n\n  if (isNumOrStr(stackId)) {\n    var group = stackGroups[stackId];\n\n    if (group && group.items.length) {\n      var itemIndex = -1;\n\n      for (var i = 0, len = group.items.length; i < len; i++) {\n        if (group.items[i] === item) {\n          itemIndex = i;\n          break;\n        }\n      }\n\n      return itemIndex >= 0 ? group.stackedData[itemIndex] : null;\n    }\n  }\n\n  return null;\n};\n\nvar getDomainOfSingle = function getDomainOfSingle(data) {\n  return data.reduce(function (result, entry) {\n    return [_min(entry.concat([result[0]]).filter(isNumber)), _max(entry.concat([result[1]]).filter(isNumber))];\n  }, [Infinity, -Infinity]);\n};\n\nexport var getDomainOfStackGroups = function getDomainOfStackGroups(stackGroups, startIndex, endIndex) {\n  return Object.keys(stackGroups).reduce(function (result, stackId) {\n    var group = stackGroups[stackId];\n    var stackedData = group.stackedData;\n    var domain = stackedData.reduce(function (res, entry) {\n      var s = getDomainOfSingle(entry.slice(startIndex, endIndex + 1));\n      return [Math.min(res[0], s[0]), Math.max(res[1], s[1])];\n    }, [Infinity, -Infinity]);\n    return [Math.min(domain[0], result[0]), Math.max(domain[1], result[1])];\n  }, [Infinity, -Infinity]).map(function (result) {\n    return result === Infinity || result === -Infinity ? 0 : result;\n  });\n};\nexport var MIN_VALUE_REG = /^dataMin[\\s]*-[\\s]*([0-9]+([.]{1}[0-9]+){0,1})$/;\nexport var MAX_VALUE_REG = /^dataMax[\\s]*\\+[\\s]*([0-9]+([.]{1}[0-9]+){0,1})$/;\nexport var parseSpecifiedDomain = function parseSpecifiedDomain(specifiedDomain, dataDomain, allowDataOverflow) {\n  if (_isFunction(specifiedDomain)) {\n    return specifiedDomain(dataDomain, allowDataOverflow);\n  }\n\n  if (!_isArray(specifiedDomain)) {\n    return dataDomain;\n  }\n\n  var domain = [];\n  /* eslint-disable prefer-destructuring */\n\n  if (isNumber(specifiedDomain[0])) {\n    domain[0] = allowDataOverflow ? specifiedDomain[0] : Math.min(specifiedDomain[0], dataDomain[0]);\n  } else if (MIN_VALUE_REG.test(specifiedDomain[0])) {\n    var value = +MIN_VALUE_REG.exec(specifiedDomain[0])[1];\n    domain[0] = dataDomain[0] - value;\n  } else if (_isFunction(specifiedDomain[0])) {\n    domain[0] = specifiedDomain[0](dataDomain[0]);\n  } else {\n    domain[0] = dataDomain[0];\n  }\n\n  if (isNumber(specifiedDomain[1])) {\n    domain[1] = allowDataOverflow ? specifiedDomain[1] : Math.max(specifiedDomain[1], dataDomain[1]);\n  } else if (MAX_VALUE_REG.test(specifiedDomain[1])) {\n    var _value = +MAX_VALUE_REG.exec(specifiedDomain[1])[1];\n\n    domain[1] = dataDomain[1] + _value;\n  } else if (_isFunction(specifiedDomain[1])) {\n    domain[1] = specifiedDomain[1](dataDomain[1]);\n  } else {\n    domain[1] = dataDomain[1];\n  }\n  /* eslint-enable prefer-destructuring */\n\n\n  return domain;\n};\n/**\n * Calculate the size between two category\n * @param  {Object} axis  The options of axis\n * @param  {Array}  ticks The ticks of axis\n * @param  {Boolean} isBar if items in axis are bars\n * @return {Number} Size\n */\n\nexport var getBandSizeOfAxis = function getBandSizeOfAxis(axis, ticks, isBar) {\n  if (axis && axis.scale && axis.scale.bandwidth) {\n    var bandWidth = axis.scale.bandwidth();\n\n    if (!isBar || bandWidth > 0) {\n      return bandWidth;\n    }\n  }\n\n  if (axis && ticks && ticks.length >= 2) {\n    var orderedTicks = _sortBy(ticks, function (o) {\n      return o.coordinate;\n    });\n\n    var bandSize = Infinity;\n\n    for (var i = 1, len = orderedTicks.length; i < len; i++) {\n      var cur = orderedTicks[i];\n      var prev = orderedTicks[i - 1];\n      bandSize = Math.min((cur.coordinate || 0) - (prev.coordinate || 0), bandSize);\n    }\n\n    return bandSize === Infinity ? 0 : bandSize;\n  }\n\n  return isBar ? undefined : 0;\n};\n/**\n * parse the domain of a category axis when a domain is specified\n * @param   {Array}        specifiedDomain  The domain specified by users\n * @param   {Array}        calculatedDomain The domain calculated by dateKey\n * @param   {ReactElement} axisChild        The axis element\n * @returns {Array}        domains\n */\n\nexport var parseDomainOfCategoryAxis = function parseDomainOfCategoryAxis(specifiedDomain, calculatedDomain, axisChild) {\n  if (!specifiedDomain || !specifiedDomain.length) {\n    return calculatedDomain;\n  }\n\n  if (_isEqual(specifiedDomain, _get(axisChild, 'type.defaultProps.domain'))) {\n    return calculatedDomain;\n  }\n\n  return specifiedDomain;\n};\nexport var getTooltipItem = function getTooltipItem(graphicalItem, payload) {\n  var _graphicalItem$props = graphicalItem.props,\n      dataKey = _graphicalItem$props.dataKey,\n      name = _graphicalItem$props.name,\n      unit = _graphicalItem$props.unit,\n      formatter = _graphicalItem$props.formatter,\n      tooltipType = _graphicalItem$props.tooltipType,\n      chartType = _graphicalItem$props.chartType;\n  return _objectSpread(_objectSpread({}, filterProps(graphicalItem)), {}, {\n    dataKey: dataKey,\n    unit: unit,\n    formatter: formatter,\n    name: name || dataKey,\n    color: getMainColorOfGraphicItem(graphicalItem),\n    value: getValueByDataKey(payload, dataKey),\n    type: tooltipType,\n    payload: payload,\n    chartType: chartType\n  });\n};","map":{"version":3,"names":["_isEqual","_sortBy","_upperFirst","_isString","_isNaN","_isArray","_max","_min","_flatMap","_isFunction","_get","_isNil","_typeof","obj","Symbol","iterator","constructor","prototype","_toConsumableArray","arr","_arrayWithoutHoles","_iterableToArray","_unsupportedIterableToArray","_nonIterableSpread","TypeError","o","minLen","_arrayLikeToArray","n","Object","toString","call","slice","name","Array","from","test","iter","isArray","len","length","i","arr2","ownKeys","object","enumerableOnly","keys","getOwnPropertySymbols","symbols","filter","sym","getOwnPropertyDescriptor","enumerable","push","apply","_objectSpread","target","arguments","source","forEach","key","_defineProperty","getOwnPropertyDescriptors","defineProperties","defineProperty","value","_toPropertyKey","configurable","writable","arg","_toPrimitive","String","input","hint","prim","toPrimitive","undefined","res","Number","d3Scales","stack","shapeStack","stackOffsetExpand","stackOffsetNone","stackOffsetSilhouette","stackOffsetWiggle","stackOrderNone","getNiceTickValues","getTickValuesFixedDomain","ErrorBar","Legend","findEntryInArray","getPercentValue","isNumber","isNumOrStr","mathSign","uniqueId","filterProps","findAllByType","findChildByType","getDisplayName","getValueByDataKey","dataKey","defaultValue","getDomainOfDataByKey","data","type","filterNil","flattenData","entry","domain","parseFloat","Infinity","validateData","map","Date","calculateActiveTickIndex","coordinate","_ticks$length","ticks","unsortedTicks","axis","index","axisType","Math","abs","range","before","cur","after","sameDirectionCoord","diffInterval","curInRange","min","max","afterInRange","sameInterval","_i","getMainColorOfGraphicItem","item","_ref","displayName","_item$props","props","stroke","fill","result","getLegendProps","_ref2","children","formattedGraphicalItems","legendWidth","legendContent","legendItem","legendData","payload","reduce","_ref3","sectors","concat","iconType","legendType","color","_ref4","_item$props2","hide","inactive","getWithHeight","getBarSizeList","_ref5","globalSize","barSize","_ref5$stackGroups","stackGroups","numericAxisIds","sgs","stackIds","j","sLen","_sgs$stackIds$j","items","cateAxisId","barItems","indexOf","selfSize","cateId","stackList","getBarPosition","_ref6","barGap","barCategoryGap","bandSize","_ref6$sizeList","sizeList","maxBarSize","realBarGap","useFull","fullBarSize","sum","offset","prev","size","newRes","position","_offset","originalSize","appendOffsetOfLegend","legendBox","width","margin","left","right","legendProps","newOffset","box","align","verticalAlign","layout","height","isErrorBarRelevantForAxis","direction","getDomainOfErrorBars","errorBars","errorBarChild","entryValue","mainValue","errorDomain","prevErrorArr","k","errorValue","lowerValue","upperValue","parseErrorBarsOfAxis","domains","getDomainOfItemsWithSameAxis","tag","isCategoricalAxis","getCoordinatesOfGrid","hasMin","hasMax","values","getTicksOfAxis","isGrid","isAll","scale","duplicateDomain","offsetForBand","realScaleType","bandwidth","niceTicks","scaleContent","row","isCategorical","categoricalDomain","tickCount","combineEventHandlers","defaultHandler","parentHandler","childHandler","customizedHandler","arg1","arg2","arg3","arg4","parseScale","chartType","hasBar","scaleBand","scaleLinear","scalePoint","EPS","checkDomainOfScale","first","last","findPositionOfBar","barPosition","child","truncateByDomain","offsetSign","series","m","positive","negative","offsetPositive","STACK_OFFSET_MAP","sign","expand","none","silhouette","wiggle","getStackedData","stackItems","offsetType","dataKeys","d","order","getStackGroupsByAxisId","_items","numericAxisId","reverseStackOrder","reverse","_item$props3","stackId","axisId","parentGroup","hasStack","childGroup","group","g","stackedData","getTicksOfScale","opts","originalDomain","allowDecimals","scaleType","tickValues","_domain","_tickValues","getCateCoordinateOfLine","_ref7","allowDuplicatedCategory","matchedTick","getCateCoordinateOfBar","_ref8","getBaseValueOfBar","_ref9","numericAxis","getStackedDataOfItem","itemIndex","getDomainOfSingle","getDomainOfStackGroups","startIndex","endIndex","s","MIN_VALUE_REG","MAX_VALUE_REG","parseSpecifiedDomain","specifiedDomain","dataDomain","allowDataOverflow","exec","_value","getBandSizeOfAxis","isBar","bandWidth","orderedTicks","parseDomainOfCategoryAxis","calculatedDomain","axisChild","getTooltipItem","graphicalItem","_graphicalItem$props","unit","formatter","tooltipType"],"sources":["/Users/jstanton/Coding/FieldDock/FieldDockMain/node_modules/recharts/es6/util/ChartUtils.js"],"sourcesContent":["import _isEqual from \"lodash/isEqual\";\nimport _sortBy from \"lodash/sortBy\";\nimport _upperFirst from \"lodash/upperFirst\";\nimport _isString from \"lodash/isString\";\nimport _isNaN from \"lodash/isNaN\";\nimport _isArray from \"lodash/isArray\";\nimport _max from \"lodash/max\";\nimport _min from \"lodash/min\";\nimport _flatMap from \"lodash/flatMap\";\nimport _isFunction from \"lodash/isFunction\";\nimport _get from \"lodash/get\";\nimport _isNil from \"lodash/isNil\";\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _iterableToArray(iter) { if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter); }\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nfunction _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return _typeof(key) === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (_typeof(input) !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (_typeof(res) !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\nimport * as d3Scales from 'victory-vendor/d3-scale';\nimport { stack as shapeStack, stackOffsetExpand, stackOffsetNone, stackOffsetSilhouette, stackOffsetWiggle, stackOrderNone } from 'victory-vendor/d3-shape';\nimport { getNiceTickValues, getTickValuesFixedDomain } from 'recharts-scale';\nimport { ErrorBar } from '../cartesian/ErrorBar';\nimport { Legend } from '../component/Legend';\nimport { findEntryInArray, getPercentValue, isNumber, isNumOrStr, mathSign, uniqueId } from './DataUtils';\nimport { filterProps, findAllByType, findChildByType, getDisplayName } from './ReactUtils';\n// TODO: Cause of circular dependency. Needs refactor.\n// import { RadiusAxisProps, AngleAxisProps } from '../polar/types';\n\nexport function getValueByDataKey(obj, dataKey, defaultValue) {\n  if (_isNil(obj) || _isNil(dataKey)) {\n    return defaultValue;\n  }\n  if (isNumOrStr(dataKey)) {\n    return _get(obj, dataKey, defaultValue);\n  }\n  if (_isFunction(dataKey)) {\n    return dataKey(obj);\n  }\n  return defaultValue;\n}\n/**\n * Get domain of data by key\n * @param  {Array}   data      The data displayed in the chart\n * @param  {String}  key       The unique key of a group of data\n * @param  {String}  type      The type of axis\n * @param  {Boolean} filterNil Whether or not filter nil values\n * @return {Array} Domain of data\n */\nexport function getDomainOfDataByKey(data, key, type, filterNil) {\n  var flattenData = _flatMap(data, function (entry) {\n    return getValueByDataKey(entry, key);\n  });\n  if (type === 'number') {\n    var domain = flattenData.filter(function (entry) {\n      return isNumber(entry) || parseFloat(entry);\n    });\n    return domain.length ? [_min(domain), _max(domain)] : [Infinity, -Infinity];\n  }\n  var validateData = filterNil ? flattenData.filter(function (entry) {\n    return !_isNil(entry);\n  }) : flattenData;\n\n  // 支持Date类型的x轴\n  return validateData.map(function (entry) {\n    return isNumOrStr(entry) || entry instanceof Date ? entry : '';\n  });\n}\nexport var calculateActiveTickIndex = function calculateActiveTickIndex(coordinate) {\n  var _ticks$length;\n  var ticks = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n  var unsortedTicks = arguments.length > 2 ? arguments[2] : undefined;\n  var axis = arguments.length > 3 ? arguments[3] : undefined;\n  var index = -1;\n  var len = (_ticks$length = ticks === null || ticks === void 0 ? void 0 : ticks.length) !== null && _ticks$length !== void 0 ? _ticks$length : 0;\n\n  // if there are 1 or less ticks ticks then the active tick is at index 0\n  if (len <= 1) {\n    return 0;\n  }\n  if (axis && axis.axisType === 'angleAxis' && Math.abs(Math.abs(axis.range[1] - axis.range[0]) - 360) <= 1e-6) {\n    var range = axis.range;\n    // ticks are distributed in a circle\n    for (var i = 0; i < len; i++) {\n      var before = i > 0 ? unsortedTicks[i - 1].coordinate : unsortedTicks[len - 1].coordinate;\n      var cur = unsortedTicks[i].coordinate;\n      var after = i >= len - 1 ? unsortedTicks[0].coordinate : unsortedTicks[i + 1].coordinate;\n      var sameDirectionCoord = void 0;\n      if (mathSign(cur - before) !== mathSign(after - cur)) {\n        var diffInterval = [];\n        if (mathSign(after - cur) === mathSign(range[1] - range[0])) {\n          sameDirectionCoord = after;\n          var curInRange = cur + range[1] - range[0];\n          diffInterval[0] = Math.min(curInRange, (curInRange + before) / 2);\n          diffInterval[1] = Math.max(curInRange, (curInRange + before) / 2);\n        } else {\n          sameDirectionCoord = before;\n          var afterInRange = after + range[1] - range[0];\n          diffInterval[0] = Math.min(cur, (afterInRange + cur) / 2);\n          diffInterval[1] = Math.max(cur, (afterInRange + cur) / 2);\n        }\n        var sameInterval = [Math.min(cur, (sameDirectionCoord + cur) / 2), Math.max(cur, (sameDirectionCoord + cur) / 2)];\n        if (coordinate > sameInterval[0] && coordinate <= sameInterval[1] || coordinate >= diffInterval[0] && coordinate <= diffInterval[1]) {\n          index = unsortedTicks[i].index;\n          break;\n        }\n      } else {\n        var min = Math.min(before, after);\n        var max = Math.max(before, after);\n        if (coordinate > (min + cur) / 2 && coordinate <= (max + cur) / 2) {\n          index = unsortedTicks[i].index;\n          break;\n        }\n      }\n    }\n  } else {\n    // ticks are distributed in a single direction\n    for (var _i = 0; _i < len; _i++) {\n      if (_i === 0 && coordinate <= (ticks[_i].coordinate + ticks[_i + 1].coordinate) / 2 || _i > 0 && _i < len - 1 && coordinate > (ticks[_i].coordinate + ticks[_i - 1].coordinate) / 2 && coordinate <= (ticks[_i].coordinate + ticks[_i + 1].coordinate) / 2 || _i === len - 1 && coordinate > (ticks[_i].coordinate + ticks[_i - 1].coordinate) / 2) {\n        index = ticks[_i].index;\n        break;\n      }\n    }\n  }\n  return index;\n};\n\n/**\n * Get the main color of each graphic item\n * @param  {ReactElement} item A graphic item\n * @return {String}            Color\n */\nexport var getMainColorOfGraphicItem = function getMainColorOfGraphicItem(item) {\n  var _ref = item,\n    displayName = _ref.type.displayName; // TODO: check if displayName is valid.\n  var _item$props = item.props,\n    stroke = _item$props.stroke,\n    fill = _item$props.fill;\n  var result;\n  switch (displayName) {\n    case 'Line':\n      result = stroke;\n      break;\n    case 'Area':\n    case 'Radar':\n      result = stroke && stroke !== 'none' ? stroke : fill;\n      break;\n    default:\n      result = fill;\n      break;\n  }\n  return result;\n};\nexport var getLegendProps = function getLegendProps(_ref2) {\n  var children = _ref2.children,\n    formattedGraphicalItems = _ref2.formattedGraphicalItems,\n    legendWidth = _ref2.legendWidth,\n    legendContent = _ref2.legendContent;\n  var legendItem = findChildByType(children, Legend);\n  if (!legendItem) {\n    return null;\n  }\n  var legendData;\n  if (legendItem.props && legendItem.props.payload) {\n    legendData = legendItem.props && legendItem.props.payload;\n  } else if (legendContent === 'children') {\n    legendData = (formattedGraphicalItems || []).reduce(function (result, _ref3) {\n      var item = _ref3.item,\n        props = _ref3.props;\n      var data = props.sectors || props.data || [];\n      return result.concat(data.map(function (entry) {\n        return {\n          type: legendItem.props.iconType || item.props.legendType,\n          value: entry.name,\n          color: entry.fill,\n          payload: entry\n        };\n      }));\n    }, []);\n  } else {\n    legendData = (formattedGraphicalItems || []).map(function (_ref4) {\n      var item = _ref4.item;\n      var _item$props2 = item.props,\n        dataKey = _item$props2.dataKey,\n        name = _item$props2.name,\n        legendType = _item$props2.legendType,\n        hide = _item$props2.hide;\n      return {\n        inactive: hide,\n        dataKey: dataKey,\n        type: legendItem.props.iconType || legendType || 'square',\n        color: getMainColorOfGraphicItem(item),\n        value: name || dataKey,\n        payload: item.props\n      };\n    });\n  }\n  return _objectSpread(_objectSpread(_objectSpread({}, legendItem.props), Legend.getWithHeight(legendItem, legendWidth)), {}, {\n    payload: legendData,\n    item: legendItem\n  });\n};\n/**\n * Calculate the size of all groups for stacked bar graph\n * @param  {Object} stackGroups The items grouped by axisId and stackId\n * @return {Object} The size of all groups\n */\nexport var getBarSizeList = function getBarSizeList(_ref5) {\n  var globalSize = _ref5.barSize,\n    _ref5$stackGroups = _ref5.stackGroups,\n    stackGroups = _ref5$stackGroups === void 0 ? {} : _ref5$stackGroups;\n  if (!stackGroups) {\n    return {};\n  }\n  var result = {};\n  var numericAxisIds = Object.keys(stackGroups);\n  for (var i = 0, len = numericAxisIds.length; i < len; i++) {\n    var sgs = stackGroups[numericAxisIds[i]].stackGroups;\n    var stackIds = Object.keys(sgs);\n    for (var j = 0, sLen = stackIds.length; j < sLen; j++) {\n      var _sgs$stackIds$j = sgs[stackIds[j]],\n        items = _sgs$stackIds$j.items,\n        cateAxisId = _sgs$stackIds$j.cateAxisId;\n      var barItems = items.filter(function (item) {\n        return getDisplayName(item.type).indexOf('Bar') >= 0;\n      });\n      if (barItems && barItems.length) {\n        var selfSize = barItems[0].props.barSize;\n        var cateId = barItems[0].props[cateAxisId];\n        if (!result[cateId]) {\n          result[cateId] = [];\n        }\n        result[cateId].push({\n          item: barItems[0],\n          stackList: barItems.slice(1),\n          barSize: _isNil(selfSize) ? globalSize : selfSize\n        });\n      }\n    }\n  }\n  return result;\n};\n\n/**\n * Calculate the size of each bar and the gap between two bars\n * @param  {Number} bandSize  The size of each category\n * @param  {sizeList} sizeList  The size of all groups\n * @param  {maxBarSize} maxBarSize The maximum size of bar\n * @return {Number} The size of each bar and the gap between two bars\n */\nexport var getBarPosition = function getBarPosition(_ref6) {\n  var barGap = _ref6.barGap,\n    barCategoryGap = _ref6.barCategoryGap,\n    bandSize = _ref6.bandSize,\n    _ref6$sizeList = _ref6.sizeList,\n    sizeList = _ref6$sizeList === void 0 ? [] : _ref6$sizeList,\n    maxBarSize = _ref6.maxBarSize;\n  var len = sizeList.length;\n  if (len < 1) return null;\n  var realBarGap = getPercentValue(barGap, bandSize, 0, true);\n  var result;\n\n  // whether or not is barSize setted by user\n  if (sizeList[0].barSize === +sizeList[0].barSize) {\n    var useFull = false;\n    var fullBarSize = bandSize / len;\n    var sum = sizeList.reduce(function (res, entry) {\n      return res + entry.barSize || 0;\n    }, 0);\n    sum += (len - 1) * realBarGap;\n    if (sum >= bandSize) {\n      sum -= (len - 1) * realBarGap;\n      realBarGap = 0;\n    }\n    if (sum >= bandSize && fullBarSize > 0) {\n      useFull = true;\n      fullBarSize *= 0.9;\n      sum = len * fullBarSize;\n    }\n    var offset = (bandSize - sum) / 2 >> 0;\n    var prev = {\n      offset: offset - realBarGap,\n      size: 0\n    };\n    result = sizeList.reduce(function (res, entry) {\n      var newRes = [].concat(_toConsumableArray(res), [{\n        item: entry.item,\n        position: {\n          offset: prev.offset + prev.size + realBarGap,\n          size: useFull ? fullBarSize : entry.barSize\n        }\n      }]);\n      prev = newRes[newRes.length - 1].position;\n      if (entry.stackList && entry.stackList.length) {\n        entry.stackList.forEach(function (item) {\n          newRes.push({\n            item: item,\n            position: prev\n          });\n        });\n      }\n      return newRes;\n    }, []);\n  } else {\n    var _offset = getPercentValue(barCategoryGap, bandSize, 0, true);\n    if (bandSize - 2 * _offset - (len - 1) * realBarGap <= 0) {\n      realBarGap = 0;\n    }\n    var originalSize = (bandSize - 2 * _offset - (len - 1) * realBarGap) / len;\n    if (originalSize > 1) {\n      originalSize >>= 0;\n    }\n    var size = maxBarSize === +maxBarSize ? Math.min(originalSize, maxBarSize) : originalSize;\n    result = sizeList.reduce(function (res, entry, i) {\n      var newRes = [].concat(_toConsumableArray(res), [{\n        item: entry.item,\n        position: {\n          offset: _offset + (originalSize + realBarGap) * i + (originalSize - size) / 2,\n          size: size\n        }\n      }]);\n      if (entry.stackList && entry.stackList.length) {\n        entry.stackList.forEach(function (item) {\n          newRes.push({\n            item: item,\n            position: newRes[newRes.length - 1].position\n          });\n        });\n      }\n      return newRes;\n    }, []);\n  }\n  return result;\n};\nexport var appendOffsetOfLegend = function appendOffsetOfLegend(offset, items, props, legendBox) {\n  var children = props.children,\n    width = props.width,\n    margin = props.margin;\n  var legendWidth = width - (margin.left || 0) - (margin.right || 0);\n  // const legendHeight = height - (margin.top || 0) - (margin.bottom || 0);\n  var legendProps = getLegendProps({\n    children: children,\n    legendWidth: legendWidth\n  });\n  var newOffset = offset;\n  if (legendProps) {\n    var box = legendBox || {};\n    var align = legendProps.align,\n      verticalAlign = legendProps.verticalAlign,\n      layout = legendProps.layout;\n    if ((layout === 'vertical' || layout === 'horizontal' && verticalAlign === 'middle') && isNumber(offset[align])) {\n      newOffset = _objectSpread(_objectSpread({}, offset), {}, _defineProperty({}, align, newOffset[align] + (box.width || 0)));\n    }\n    if ((layout === 'horizontal' || layout === 'vertical' && align === 'center') && isNumber(offset[verticalAlign])) {\n      newOffset = _objectSpread(_objectSpread({}, offset), {}, _defineProperty({}, verticalAlign, newOffset[verticalAlign] + (box.height || 0)));\n    }\n  }\n  return newOffset;\n};\nvar isErrorBarRelevantForAxis = function isErrorBarRelevantForAxis(layout, axisType, direction) {\n  if (_isNil(axisType)) {\n    return true;\n  }\n  if (layout === 'horizontal') {\n    return axisType === 'yAxis';\n  }\n  if (layout === 'vertical') {\n    return axisType === 'xAxis';\n  }\n  if (direction === 'x') {\n    return axisType === 'xAxis';\n  }\n  if (direction === 'y') {\n    return axisType === 'yAxis';\n  }\n  return true;\n};\nexport var getDomainOfErrorBars = function getDomainOfErrorBars(data, item, dataKey, layout, axisType) {\n  var children = item.props.children;\n  var errorBars = findAllByType(children, ErrorBar).filter(function (errorBarChild) {\n    return isErrorBarRelevantForAxis(layout, axisType, errorBarChild.props.direction);\n  });\n  if (errorBars && errorBars.length) {\n    var keys = errorBars.map(function (errorBarChild) {\n      return errorBarChild.props.dataKey;\n    });\n    return data.reduce(function (result, entry) {\n      var entryValue = getValueByDataKey(entry, dataKey, 0);\n      var mainValue = _isArray(entryValue) ? [_min(entryValue), _max(entryValue)] : [entryValue, entryValue];\n      var errorDomain = keys.reduce(function (prevErrorArr, k) {\n        var errorValue = getValueByDataKey(entry, k, 0);\n        var lowerValue = mainValue[0] - Math.abs(_isArray(errorValue) ? errorValue[0] : errorValue);\n        var upperValue = mainValue[1] + Math.abs(_isArray(errorValue) ? errorValue[1] : errorValue);\n        return [Math.min(lowerValue, prevErrorArr[0]), Math.max(upperValue, prevErrorArr[1])];\n      }, [Infinity, -Infinity]);\n      return [Math.min(errorDomain[0], result[0]), Math.max(errorDomain[1], result[1])];\n    }, [Infinity, -Infinity]);\n  }\n  return null;\n};\nexport var parseErrorBarsOfAxis = function parseErrorBarsOfAxis(data, items, dataKey, axisType, layout) {\n  var domains = items.map(function (item) {\n    return getDomainOfErrorBars(data, item, dataKey, layout, axisType);\n  }).filter(function (entry) {\n    return !_isNil(entry);\n  });\n  if (domains && domains.length) {\n    return domains.reduce(function (result, entry) {\n      return [Math.min(result[0], entry[0]), Math.max(result[1], entry[1])];\n    }, [Infinity, -Infinity]);\n  }\n  return null;\n};\n\n/**\n * Get domain of data by the configuration of item element\n * @param  {Array}   data      The data displayed in the chart\n * @param  {Array}   items     The instances of item\n * @param  {String}  type      The type of axis, number - Number Axis, category - Category Axis\n * @param  {LayoutType} layout The type of layout\n * @param  {Boolean} filterNil Whether or not filter nil values\n * @return {Array}        Domain\n */\nexport var getDomainOfItemsWithSameAxis = function getDomainOfItemsWithSameAxis(data, items, type, layout, filterNil) {\n  var domains = items.map(function (item) {\n    var dataKey = item.props.dataKey;\n    if (type === 'number' && dataKey) {\n      return getDomainOfErrorBars(data, item, dataKey, layout) || getDomainOfDataByKey(data, dataKey, type, filterNil);\n    }\n    return getDomainOfDataByKey(data, dataKey, type, filterNil);\n  });\n  if (type === 'number') {\n    // Calculate the domain of number axis\n    return domains.reduce(function (result, entry) {\n      return [Math.min(result[0], entry[0]), Math.max(result[1], entry[1])];\n    }, [Infinity, -Infinity]);\n  }\n  var tag = {};\n  // Get the union set of category axis\n  return domains.reduce(function (result, entry) {\n    for (var i = 0, len = entry.length; i < len; i++) {\n      if (!tag[entry[i]]) {\n        tag[entry[i]] = true;\n        result.push(entry[i]);\n      }\n    }\n    return result;\n  }, []);\n};\nexport var isCategoricalAxis = function isCategoricalAxis(layout, axisType) {\n  return layout === 'horizontal' && axisType === 'xAxis' || layout === 'vertical' && axisType === 'yAxis' || layout === 'centric' && axisType === 'angleAxis' || layout === 'radial' && axisType === 'radiusAxis';\n};\n\n/**\n * Calculate the Coordinates of grid\n * @param  {Array} ticks The ticks in axis\n * @param {Number} min   The minimun value of axis\n * @param {Number} max   The maximun value of axis\n * @return {Array}       Coordinates\n */\nexport var getCoordinatesOfGrid = function getCoordinatesOfGrid(ticks, min, max) {\n  var hasMin, hasMax;\n  var values = ticks.map(function (entry) {\n    if (entry.coordinate === min) {\n      hasMin = true;\n    }\n    if (entry.coordinate === max) {\n      hasMax = true;\n    }\n    return entry.coordinate;\n  });\n  if (!hasMin) {\n    values.push(min);\n  }\n  if (!hasMax) {\n    values.push(max);\n  }\n  return values;\n};\n\n/**\n * Get the ticks of an axis\n * @param  {Object}  axis The configuration of an axis\n * @param {Boolean} isGrid Whether or not are the ticks in grid\n * @param {Boolean} isAll Return the ticks of all the points or not\n * @return {Array}  Ticks\n */\nexport var getTicksOfAxis = function getTicksOfAxis(axis, isGrid, isAll) {\n  if (!axis) return null;\n  var scale = axis.scale;\n  var duplicateDomain = axis.duplicateDomain,\n    type = axis.type,\n    range = axis.range;\n  var offsetForBand = axis.realScaleType === 'scaleBand' ? scale.bandwidth() / 2 : 2;\n  var offset = (isGrid || isAll) && type === 'category' && scale.bandwidth ? scale.bandwidth() / offsetForBand : 0;\n  offset = axis.axisType === 'angleAxis' && (range === null || range === void 0 ? void 0 : range.length) >= 2 ? mathSign(range[0] - range[1]) * 2 * offset : offset;\n\n  // The ticks set by user should only affect the ticks adjacent to axis line\n  if (isGrid && (axis.ticks || axis.niceTicks)) {\n    var result = (axis.ticks || axis.niceTicks).map(function (entry) {\n      var scaleContent = duplicateDomain ? duplicateDomain.indexOf(entry) : entry;\n      return {\n        // If the scaleContent is not a number, the coordinate will be NaN.\n        // That could be the case for example with a PointScale and a string as domain.\n        coordinate: scale(scaleContent) + offset,\n        value: entry,\n        offset: offset\n      };\n    });\n    return result.filter(function (row) {\n      return !_isNaN(row.coordinate);\n    });\n  }\n\n  // When axis is a categorial axis, but the type of axis is number or the scale of axis is not \"auto\"\n  if (axis.isCategorical && axis.categoricalDomain) {\n    return axis.categoricalDomain.map(function (entry, index) {\n      return {\n        coordinate: scale(entry) + offset,\n        value: entry,\n        index: index,\n        offset: offset\n      };\n    });\n  }\n  if (scale.ticks && !isAll) {\n    return scale.ticks(axis.tickCount).map(function (entry) {\n      return {\n        coordinate: scale(entry) + offset,\n        value: entry,\n        offset: offset\n      };\n    });\n  }\n\n  // When axis has duplicated text, serial numbers are used to generate scale\n  return scale.domain().map(function (entry, index) {\n    return {\n      coordinate: scale(entry) + offset,\n      value: duplicateDomain ? duplicateDomain[entry] : entry,\n      index: index,\n      offset: offset\n    };\n  });\n};\n\n/**\n * combine the handlers\n * @param  {Function} defaultHandler Internal private handler\n * @param  {Function} parentHandler  Handler function specified in parent component\n * @param  {Function} childHandler   Handler function specified in child component\n * @return {Function}                The combined handler\n */\nexport var combineEventHandlers = function combineEventHandlers(defaultHandler, parentHandler, childHandler) {\n  var customizedHandler;\n  if (_isFunction(childHandler)) {\n    customizedHandler = childHandler;\n  } else if (_isFunction(parentHandler)) {\n    customizedHandler = parentHandler;\n  }\n  if (_isFunction(defaultHandler) || customizedHandler) {\n    return function (arg1, arg2, arg3, arg4) {\n      if (_isFunction(defaultHandler)) {\n        defaultHandler(arg1, arg2, arg3, arg4);\n      }\n      if (_isFunction(customizedHandler)) {\n        customizedHandler(arg1, arg2, arg3, arg4);\n      }\n    };\n  }\n  return null;\n};\n/**\n * Parse the scale function of axis\n * @param  {Object}   axis          The option of axis\n * @param  {String}   chartType     The displayName of chart\n * @param  {Boolean}  hasBar        if it has a bar\n * @return {Function}               The scale function\n */\nexport var parseScale = function parseScale(axis, chartType, hasBar) {\n  var scale = axis.scale,\n    type = axis.type,\n    layout = axis.layout,\n    axisType = axis.axisType;\n  if (scale === 'auto') {\n    if (layout === 'radial' && axisType === 'radiusAxis') {\n      return {\n        scale: d3Scales.scaleBand(),\n        realScaleType: 'band'\n      };\n    }\n    if (layout === 'radial' && axisType === 'angleAxis') {\n      return {\n        scale: d3Scales.scaleLinear(),\n        realScaleType: 'linear'\n      };\n    }\n    if (type === 'category' && chartType && (chartType.indexOf('LineChart') >= 0 || chartType.indexOf('AreaChart') >= 0 || chartType.indexOf('ComposedChart') >= 0 && !hasBar)) {\n      return {\n        scale: d3Scales.scalePoint(),\n        realScaleType: 'point'\n      };\n    }\n    if (type === 'category') {\n      return {\n        scale: d3Scales.scaleBand(),\n        realScaleType: 'band'\n      };\n    }\n    return {\n      scale: d3Scales.scaleLinear(),\n      realScaleType: 'linear'\n    };\n  }\n  if (_isString(scale)) {\n    var name = \"scale\".concat(_upperFirst(scale));\n    return {\n      scale: (d3Scales[name] || d3Scales.scalePoint)(),\n      realScaleType: d3Scales[name] ? name : 'point'\n    };\n  }\n  return _isFunction(scale) ? {\n    scale: scale\n  } : {\n    scale: d3Scales.scalePoint(),\n    realScaleType: 'point'\n  };\n};\nvar EPS = 1e-4;\nexport var checkDomainOfScale = function checkDomainOfScale(scale) {\n  var domain = scale.domain();\n  if (!domain || domain.length <= 2) {\n    return;\n  }\n  var len = domain.length;\n  var range = scale.range();\n  var min = Math.min(range[0], range[1]) - EPS;\n  var max = Math.max(range[0], range[1]) + EPS;\n  var first = scale(domain[0]);\n  var last = scale(domain[len - 1]);\n  if (first < min || first > max || last < min || last > max) {\n    scale.domain([domain[0], domain[len - 1]]);\n  }\n};\nexport var findPositionOfBar = function findPositionOfBar(barPosition, child) {\n  if (!barPosition) {\n    return null;\n  }\n  for (var i = 0, len = barPosition.length; i < len; i++) {\n    if (barPosition[i].item === child) {\n      return barPosition[i].position;\n    }\n  }\n  return null;\n};\nexport var truncateByDomain = function truncateByDomain(value, domain) {\n  if (!domain || domain.length !== 2 || !isNumber(domain[0]) || !isNumber(domain[1])) {\n    return value;\n  }\n  var min = Math.min(domain[0], domain[1]);\n  var max = Math.max(domain[0], domain[1]);\n  var result = [value[0], value[1]];\n  if (!isNumber(value[0]) || value[0] < min) {\n    result[0] = min;\n  }\n  if (!isNumber(value[1]) || value[1] > max) {\n    result[1] = max;\n  }\n  if (result[0] > max) {\n    result[0] = max;\n  }\n  if (result[1] < min) {\n    result[1] = min;\n  }\n  return result;\n};\n\n/* eslint no-param-reassign: 0 */\nexport var offsetSign = function offsetSign(series) {\n  var n = series.length;\n  if (n <= 0) {\n    return;\n  }\n  for (var j = 0, m = series[0].length; j < m; ++j) {\n    var positive = 0;\n    var negative = 0;\n    for (var i = 0; i < n; ++i) {\n      var value = _isNaN(series[i][j][1]) ? series[i][j][0] : series[i][j][1];\n\n      /* eslint-disable prefer-destructuring */\n      if (value >= 0) {\n        series[i][j][0] = positive;\n        series[i][j][1] = positive + value;\n        positive = series[i][j][1];\n      } else {\n        series[i][j][0] = negative;\n        series[i][j][1] = negative + value;\n        negative = series[i][j][1];\n      }\n      /* eslint-enable prefer-destructuring */\n    }\n  }\n};\n\nexport var offsetPositive = function offsetPositive(series) {\n  var n = series.length;\n  if (n <= 0) {\n    return;\n  }\n  for (var j = 0, m = series[0].length; j < m; ++j) {\n    var positive = 0;\n    for (var i = 0; i < n; ++i) {\n      var value = _isNaN(series[i][j][1]) ? series[i][j][0] : series[i][j][1];\n\n      /* eslint-disable prefer-destructuring */\n      if (value >= 0) {\n        series[i][j][0] = positive;\n        series[i][j][1] = positive + value;\n        positive = series[i][j][1];\n      } else {\n        series[i][j][0] = 0;\n        series[i][j][1] = 0;\n      }\n      /* eslint-enable prefer-destructuring */\n    }\n  }\n};\n\nvar STACK_OFFSET_MAP = {\n  sign: offsetSign,\n  expand: stackOffsetExpand,\n  none: stackOffsetNone,\n  silhouette: stackOffsetSilhouette,\n  wiggle: stackOffsetWiggle,\n  positive: offsetPositive\n};\nexport var getStackedData = function getStackedData(data, stackItems, offsetType) {\n  var dataKeys = stackItems.map(function (item) {\n    return item.props.dataKey;\n  });\n  var stack = shapeStack().keys(dataKeys).value(function (d, key) {\n    return +getValueByDataKey(d, key, 0);\n  }).order(stackOrderNone).offset(STACK_OFFSET_MAP[offsetType]);\n  return stack(data);\n};\nexport var getStackGroupsByAxisId = function getStackGroupsByAxisId(data, _items, numericAxisId, cateAxisId, offsetType, reverseStackOrder) {\n  if (!data) {\n    return null;\n  }\n\n  // reversing items to affect render order (for layering)\n  var items = reverseStackOrder ? _items.reverse() : _items;\n  var stackGroups = items.reduce(function (result, item) {\n    var _item$props3 = item.props,\n      stackId = _item$props3.stackId,\n      hide = _item$props3.hide;\n    if (hide) {\n      return result;\n    }\n    var axisId = item.props[numericAxisId];\n    var parentGroup = result[axisId] || {\n      hasStack: false,\n      stackGroups: {}\n    };\n    if (isNumOrStr(stackId)) {\n      var childGroup = parentGroup.stackGroups[stackId] || {\n        numericAxisId: numericAxisId,\n        cateAxisId: cateAxisId,\n        items: []\n      };\n      childGroup.items.push(item);\n      parentGroup.hasStack = true;\n      parentGroup.stackGroups[stackId] = childGroup;\n    } else {\n      parentGroup.stackGroups[uniqueId('_stackId_')] = {\n        numericAxisId: numericAxisId,\n        cateAxisId: cateAxisId,\n        items: [item]\n      };\n    }\n    return _objectSpread(_objectSpread({}, result), {}, _defineProperty({}, axisId, parentGroup));\n  }, {});\n  return Object.keys(stackGroups).reduce(function (result, axisId) {\n    var group = stackGroups[axisId];\n    if (group.hasStack) {\n      group.stackGroups = Object.keys(group.stackGroups).reduce(function (res, stackId) {\n        var g = group.stackGroups[stackId];\n        return _objectSpread(_objectSpread({}, res), {}, _defineProperty({}, stackId, {\n          numericAxisId: numericAxisId,\n          cateAxisId: cateAxisId,\n          items: g.items,\n          stackedData: getStackedData(data, g.items, offsetType)\n        }));\n      }, {});\n    }\n    return _objectSpread(_objectSpread({}, result), {}, _defineProperty({}, axisId, group));\n  }, {});\n};\n\n/**\n * Configure the scale function of axis\n * @param {Object} scale The scale function\n * @param {Object} opts  The configuration of axis\n * @return {Object}      null\n */\nexport var getTicksOfScale = function getTicksOfScale(scale, opts) {\n  var realScaleType = opts.realScaleType,\n    type = opts.type,\n    tickCount = opts.tickCount,\n    originalDomain = opts.originalDomain,\n    allowDecimals = opts.allowDecimals;\n  var scaleType = realScaleType || opts.scale;\n  if (scaleType !== 'auto' && scaleType !== 'linear') {\n    return null;\n  }\n  if (tickCount && type === 'number' && originalDomain && (originalDomain[0] === 'auto' || originalDomain[1] === 'auto')) {\n    // Calculate the ticks by the number of grid when the axis is a number axis\n    var domain = scale.domain();\n    if (!domain.length) {\n      return null;\n    }\n    var tickValues = getNiceTickValues(domain, tickCount, allowDecimals);\n    scale.domain([_min(tickValues), _max(tickValues)]);\n    return {\n      niceTicks: tickValues\n    };\n  }\n  if (tickCount && type === 'number') {\n    var _domain = scale.domain();\n    var _tickValues = getTickValuesFixedDomain(_domain, tickCount, allowDecimals);\n    return {\n      niceTicks: _tickValues\n    };\n  }\n  return null;\n};\nexport var getCateCoordinateOfLine = function getCateCoordinateOfLine(_ref7) {\n  var axis = _ref7.axis,\n    ticks = _ref7.ticks,\n    bandSize = _ref7.bandSize,\n    entry = _ref7.entry,\n    index = _ref7.index,\n    dataKey = _ref7.dataKey;\n  if (axis.type === 'category') {\n    // find coordinate of category axis by the value of category\n    if (!axis.allowDuplicatedCategory && axis.dataKey && !_isNil(entry[axis.dataKey])) {\n      var matchedTick = findEntryInArray(ticks, 'value', entry[axis.dataKey]);\n      if (matchedTick) {\n        return matchedTick.coordinate + bandSize / 2;\n      }\n    }\n    return ticks[index] ? ticks[index].coordinate + bandSize / 2 : null;\n  }\n  var value = getValueByDataKey(entry, !_isNil(dataKey) ? dataKey : axis.dataKey);\n  return !_isNil(value) ? axis.scale(value) : null;\n};\nexport var getCateCoordinateOfBar = function getCateCoordinateOfBar(_ref8) {\n  var axis = _ref8.axis,\n    ticks = _ref8.ticks,\n    offset = _ref8.offset,\n    bandSize = _ref8.bandSize,\n    entry = _ref8.entry,\n    index = _ref8.index;\n  if (axis.type === 'category') {\n    return ticks[index] ? ticks[index].coordinate + offset : null;\n  }\n  var value = getValueByDataKey(entry, axis.dataKey, axis.domain[index]);\n  return !_isNil(value) ? axis.scale(value) - bandSize / 2 + offset : null;\n};\nexport var getBaseValueOfBar = function getBaseValueOfBar(_ref9) {\n  var numericAxis = _ref9.numericAxis;\n  var domain = numericAxis.scale.domain();\n  if (numericAxis.type === 'number') {\n    var min = Math.min(domain[0], domain[1]);\n    var max = Math.max(domain[0], domain[1]);\n    if (min <= 0 && max >= 0) {\n      return 0;\n    }\n    if (max < 0) {\n      return max;\n    }\n    return min;\n  }\n  return domain[0];\n};\nexport var getStackedDataOfItem = function getStackedDataOfItem(item, stackGroups) {\n  var stackId = item.props.stackId;\n  if (isNumOrStr(stackId)) {\n    var group = stackGroups[stackId];\n    if (group && group.items.length) {\n      var itemIndex = -1;\n      for (var i = 0, len = group.items.length; i < len; i++) {\n        if (group.items[i] === item) {\n          itemIndex = i;\n          break;\n        }\n      }\n      return itemIndex >= 0 ? group.stackedData[itemIndex] : null;\n    }\n  }\n  return null;\n};\nvar getDomainOfSingle = function getDomainOfSingle(data) {\n  return data.reduce(function (result, entry) {\n    return [_min(entry.concat([result[0]]).filter(isNumber)), _max(entry.concat([result[1]]).filter(isNumber))];\n  }, [Infinity, -Infinity]);\n};\nexport var getDomainOfStackGroups = function getDomainOfStackGroups(stackGroups, startIndex, endIndex) {\n  return Object.keys(stackGroups).reduce(function (result, stackId) {\n    var group = stackGroups[stackId];\n    var stackedData = group.stackedData;\n    var domain = stackedData.reduce(function (res, entry) {\n      var s = getDomainOfSingle(entry.slice(startIndex, endIndex + 1));\n      return [Math.min(res[0], s[0]), Math.max(res[1], s[1])];\n    }, [Infinity, -Infinity]);\n    return [Math.min(domain[0], result[0]), Math.max(domain[1], result[1])];\n  }, [Infinity, -Infinity]).map(function (result) {\n    return result === Infinity || result === -Infinity ? 0 : result;\n  });\n};\nexport var MIN_VALUE_REG = /^dataMin[\\s]*-[\\s]*([0-9]+([.]{1}[0-9]+){0,1})$/;\nexport var MAX_VALUE_REG = /^dataMax[\\s]*\\+[\\s]*([0-9]+([.]{1}[0-9]+){0,1})$/;\nexport var parseSpecifiedDomain = function parseSpecifiedDomain(specifiedDomain, dataDomain, allowDataOverflow) {\n  if (_isFunction(specifiedDomain)) {\n    return specifiedDomain(dataDomain, allowDataOverflow);\n  }\n  if (!_isArray(specifiedDomain)) {\n    return dataDomain;\n  }\n  var domain = [];\n\n  /* eslint-disable prefer-destructuring */\n  if (isNumber(specifiedDomain[0])) {\n    domain[0] = allowDataOverflow ? specifiedDomain[0] : Math.min(specifiedDomain[0], dataDomain[0]);\n  } else if (MIN_VALUE_REG.test(specifiedDomain[0])) {\n    var value = +MIN_VALUE_REG.exec(specifiedDomain[0])[1];\n    domain[0] = dataDomain[0] - value;\n  } else if (_isFunction(specifiedDomain[0])) {\n    domain[0] = specifiedDomain[0](dataDomain[0]);\n  } else {\n    domain[0] = dataDomain[0];\n  }\n  if (isNumber(specifiedDomain[1])) {\n    domain[1] = allowDataOverflow ? specifiedDomain[1] : Math.max(specifiedDomain[1], dataDomain[1]);\n  } else if (MAX_VALUE_REG.test(specifiedDomain[1])) {\n    var _value = +MAX_VALUE_REG.exec(specifiedDomain[1])[1];\n    domain[1] = dataDomain[1] + _value;\n  } else if (_isFunction(specifiedDomain[1])) {\n    domain[1] = specifiedDomain[1](dataDomain[1]);\n  } else {\n    domain[1] = dataDomain[1];\n  }\n  /* eslint-enable prefer-destructuring */\n\n  return domain;\n};\n\n/**\n * Calculate the size between two category\n * @param  {Object} axis  The options of axis\n * @param  {Array}  ticks The ticks of axis\n * @param  {Boolean} isBar if items in axis are bars\n * @return {Number} Size\n */\nexport var getBandSizeOfAxis = function getBandSizeOfAxis(axis, ticks, isBar) {\n  if (axis && axis.scale && axis.scale.bandwidth) {\n    var bandWidth = axis.scale.bandwidth();\n    if (!isBar || bandWidth > 0) {\n      return bandWidth;\n    }\n  }\n  if (axis && ticks && ticks.length >= 2) {\n    var orderedTicks = _sortBy(ticks, function (o) {\n      return o.coordinate;\n    });\n    var bandSize = Infinity;\n    for (var i = 1, len = orderedTicks.length; i < len; i++) {\n      var cur = orderedTicks[i];\n      var prev = orderedTicks[i - 1];\n      bandSize = Math.min((cur.coordinate || 0) - (prev.coordinate || 0), bandSize);\n    }\n    return bandSize === Infinity ? 0 : bandSize;\n  }\n  return isBar ? undefined : 0;\n};\n/**\n * parse the domain of a category axis when a domain is specified\n * @param   {Array}        specifiedDomain  The domain specified by users\n * @param   {Array}        calculatedDomain The domain calculated by dateKey\n * @param   {ReactElement} axisChild        The axis element\n * @returns {Array}        domains\n */\nexport var parseDomainOfCategoryAxis = function parseDomainOfCategoryAxis(specifiedDomain, calculatedDomain, axisChild) {\n  if (!specifiedDomain || !specifiedDomain.length) {\n    return calculatedDomain;\n  }\n  if (_isEqual(specifiedDomain, _get(axisChild, 'type.defaultProps.domain'))) {\n    return calculatedDomain;\n  }\n  return specifiedDomain;\n};\nexport var getTooltipItem = function getTooltipItem(graphicalItem, payload) {\n  var _graphicalItem$props = graphicalItem.props,\n    dataKey = _graphicalItem$props.dataKey,\n    name = _graphicalItem$props.name,\n    unit = _graphicalItem$props.unit,\n    formatter = _graphicalItem$props.formatter,\n    tooltipType = _graphicalItem$props.tooltipType,\n    chartType = _graphicalItem$props.chartType;\n  return _objectSpread(_objectSpread({}, filterProps(graphicalItem)), {}, {\n    dataKey: dataKey,\n    unit: unit,\n    formatter: formatter,\n    name: name || dataKey,\n    color: getMainColorOfGraphicItem(graphicalItem),\n    value: getValueByDataKey(payload, dataKey),\n    type: tooltipType,\n    payload: payload,\n    chartType: chartType\n  });\n};"],"mappings":"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"},"metadata":{},"sourceType":"module"}