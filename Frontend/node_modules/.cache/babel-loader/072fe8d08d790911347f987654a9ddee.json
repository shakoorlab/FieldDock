{"ast":null,"code":"/* replacement start */\n\nconst process = require('process/')\n\n/* replacement end */\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n;\n\n'use strict';\nconst {\n  ArrayPrototypeIndexOf,\n  NumberIsInteger,\n  NumberIsNaN,\n  NumberParseInt,\n  ObjectDefineProperties,\n  ObjectKeys,\n  ObjectSetPrototypeOf,\n  Promise,\n  SafeSet,\n  SymbolAsyncIterator,\n  Symbol\n} = require('../../ours/primordials');\nmodule.exports = Readable;\nReadable.ReadableState = ReadableState;\nconst {\n  EventEmitter: EE\n} = require('events');\nconst {\n  Stream,\n  prependListener\n} = require('./legacy');\nconst {\n  Buffer\n} = require('buffer');\nconst {\n  addAbortSignal\n} = require('./add-abort-signal');\nconst eos = require('./end-of-stream');\nlet debug = require('../../ours/util').debuglog('stream', fn => {\n  debug = fn;\n});\nconst BufferList = require('./buffer_list');\nconst destroyImpl = require('./destroy');\nconst {\n  getHighWaterMark,\n  getDefaultHighWaterMark\n} = require('./state');\nconst {\n  aggregateTwoErrors,\n  codes: {\n    ERR_INVALID_ARG_TYPE,\n    ERR_METHOD_NOT_IMPLEMENTED,\n    ERR_OUT_OF_RANGE,\n    ERR_STREAM_PUSH_AFTER_EOF,\n    ERR_STREAM_UNSHIFT_AFTER_END_EVENT\n  }\n} = require('../../ours/errors');\nconst {\n  validateObject\n} = require('../validators');\nconst kPaused = Symbol('kPaused');\nconst {\n  StringDecoder\n} = require('string_decoder');\nconst from = require('./from');\nObjectSetPrototypeOf(Readable.prototype, Stream.prototype);\nObjectSetPrototypeOf(Readable, Stream);\nconst nop = () => {};\nconst {\n  errorOrDestroy\n} = destroyImpl;\nfunction ReadableState(options, stream, isDuplex) {\n  // Duplex streams are both readable and writable, but share\n  // the same options object.\n  // However, some cases require setting options to different\n  // values for the readable and the writable sides of the duplex stream.\n  // These options can be provided separately as readableXXX and writableXXX.\n  if (typeof isDuplex !== 'boolean') isDuplex = stream instanceof require('./duplex');\n\n  // Object stream flag. Used to make read(n) ignore n and to\n  // make all the buffer merging and length checks go away.\n  this.objectMode = !!(options && options.objectMode);\n  if (isDuplex) this.objectMode = this.objectMode || !!(options && options.readableObjectMode);\n\n  // The point at which it stops calling _read() to fill the buffer\n  // Note: 0 is a valid value, means \"don't call _read preemptively ever\"\n  this.highWaterMark = options ? getHighWaterMark(this, options, 'readableHighWaterMark', isDuplex) : getDefaultHighWaterMark(false);\n\n  // A linked list is used to store data chunks instead of an array because the\n  // linked list can remove elements from the beginning faster than\n  // array.shift().\n  this.buffer = new BufferList();\n  this.length = 0;\n  this.pipes = [];\n  this.flowing = null;\n  this.ended = false;\n  this.endEmitted = false;\n  this.reading = false;\n\n  // Stream is still being constructed and cannot be\n  // destroyed until construction finished or failed.\n  // Async construction is opt in, therefore we start as\n  // constructed.\n  this.constructed = true;\n\n  // A flag to be able to tell if the event 'readable'/'data' is emitted\n  // immediately, or on a later tick.  We set this to true at first, because\n  // any actions that shouldn't happen until \"later\" should generally also\n  // not happen before the first read call.\n  this.sync = true;\n\n  // Whenever we return null, then we set a flag to say\n  // that we're awaiting a 'readable' event emission.\n  this.needReadable = false;\n  this.emittedReadable = false;\n  this.readableListening = false;\n  this.resumeScheduled = false;\n  this[kPaused] = null;\n\n  // True if the error was already emitted and should not be thrown again.\n  this.errorEmitted = false;\n\n  // Should close be emitted on destroy. Defaults to true.\n  this.emitClose = !options || options.emitClose !== false;\n\n  // Should .destroy() be called after 'end' (and potentially 'finish').\n  this.autoDestroy = !options || options.autoDestroy !== false;\n\n  // Has it been destroyed.\n  this.destroyed = false;\n\n  // Indicates whether the stream has errored. When true no further\n  // _read calls, 'data' or 'readable' events should occur. This is needed\n  // since when autoDestroy is disabled we need a way to tell whether the\n  // stream has failed.\n  this.errored = null;\n\n  // Indicates whether the stream has finished destroying.\n  this.closed = false;\n\n  // True if close has been emitted or would have been emitted\n  // depending on emitClose.\n  this.closeEmitted = false;\n\n  // Crypto is kind of old and crusty.  Historically, its default string\n  // encoding is 'binary' so we have to make this configurable.\n  // Everything else in the universe uses 'utf8', though.\n  this.defaultEncoding = options && options.defaultEncoding || 'utf8';\n\n  // Ref the piped dest which we need a drain event on it\n  // type: null | Writable | Set<Writable>.\n  this.awaitDrainWriters = null;\n  this.multiAwaitDrain = false;\n\n  // If true, a maybeReadMore has been scheduled.\n  this.readingMore = false;\n  this.dataEmitted = false;\n  this.decoder = null;\n  this.encoding = null;\n  if (options && options.encoding) {\n    this.decoder = new StringDecoder(options.encoding);\n    this.encoding = options.encoding;\n  }\n}\nfunction Readable(options) {\n  if (!(this instanceof Readable)) return new Readable(options);\n\n  // Checking for a Stream.Duplex instance is faster here instead of inside\n  // the ReadableState constructor, at least with V8 6.5.\n  const isDuplex = this instanceof require('./duplex');\n  this._readableState = new ReadableState(options, this, isDuplex);\n  if (options) {\n    if (typeof options.read === 'function') this._read = options.read;\n    if (typeof options.destroy === 'function') this._destroy = options.destroy;\n    if (typeof options.construct === 'function') this._construct = options.construct;\n    if (options.signal && !isDuplex) addAbortSignal(options.signal, this);\n  }\n  Stream.call(this, options);\n  destroyImpl.construct(this, () => {\n    if (this._readableState.needReadable) {\n      maybeReadMore(this, this._readableState);\n    }\n  });\n}\nReadable.prototype.destroy = destroyImpl.destroy;\nReadable.prototype._undestroy = destroyImpl.undestroy;\nReadable.prototype._destroy = function (err, cb) {\n  cb(err);\n};\nReadable.prototype[EE.captureRejectionSymbol] = function (err) {\n  this.destroy(err);\n};\n\n// Manually shove something into the read() buffer.\n// This returns true if the highWaterMark has not been hit yet,\n// similar to how Writable.write() returns true if you should\n// write() some more.\nReadable.prototype.push = function (chunk, encoding) {\n  return readableAddChunk(this, chunk, encoding, false);\n};\n\n// Unshift should *always* be something directly out of read().\nReadable.prototype.unshift = function (chunk, encoding) {\n  return readableAddChunk(this, chunk, encoding, true);\n};\nfunction readableAddChunk(stream, chunk, encoding, addToFront) {\n  debug('readableAddChunk', chunk);\n  const state = stream._readableState;\n  let err;\n  if (!state.objectMode) {\n    if (typeof chunk === 'string') {\n      encoding = encoding || state.defaultEncoding;\n      if (state.encoding !== encoding) {\n        if (addToFront && state.encoding) {\n          // When unshifting, if state.encoding is set, we have to save\n          // the string in the BufferList with the state encoding.\n          chunk = Buffer.from(chunk, encoding).toString(state.encoding);\n        } else {\n          chunk = Buffer.from(chunk, encoding);\n          encoding = '';\n        }\n      }\n    } else if (chunk instanceof Buffer) {\n      encoding = '';\n    } else if (Stream._isUint8Array(chunk)) {\n      chunk = Stream._uint8ArrayToBuffer(chunk);\n      encoding = '';\n    } else if (chunk != null) {\n      err = new ERR_INVALID_ARG_TYPE('chunk', ['string', 'Buffer', 'Uint8Array'], chunk);\n    }\n  }\n  if (err) {\n    errorOrDestroy(stream, err);\n  } else if (chunk === null) {\n    state.reading = false;\n    onEofChunk(stream, state);\n  } else if (state.objectMode || chunk && chunk.length > 0) {\n    if (addToFront) {\n      if (state.endEmitted) errorOrDestroy(stream, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());else if (state.destroyed || state.errored) return false;else addChunk(stream, state, chunk, true);\n    } else if (state.ended) {\n      errorOrDestroy(stream, new ERR_STREAM_PUSH_AFTER_EOF());\n    } else if (state.destroyed || state.errored) {\n      return false;\n    } else {\n      state.reading = false;\n      if (state.decoder && !encoding) {\n        chunk = state.decoder.write(chunk);\n        if (state.objectMode || chunk.length !== 0) addChunk(stream, state, chunk, false);else maybeReadMore(stream, state);\n      } else {\n        addChunk(stream, state, chunk, false);\n      }\n    }\n  } else if (!addToFront) {\n    state.reading = false;\n    maybeReadMore(stream, state);\n  }\n\n  // We can push more data if we are below the highWaterMark.\n  // Also, if we have no data yet, we can stand some more bytes.\n  // This is to work around cases where hwm=0, such as the repl.\n  return !state.ended && (state.length < state.highWaterMark || state.length === 0);\n}\nfunction addChunk(stream, state, chunk, addToFront) {\n  if (state.flowing && state.length === 0 && !state.sync && stream.listenerCount('data') > 0) {\n    // Use the guard to avoid creating `Set()` repeatedly\n    // when we have multiple pipes.\n    if (state.multiAwaitDrain) {\n      state.awaitDrainWriters.clear();\n    } else {\n      state.awaitDrainWriters = null;\n    }\n    state.dataEmitted = true;\n    stream.emit('data', chunk);\n  } else {\n    // Update the buffer info.\n    state.length += state.objectMode ? 1 : chunk.length;\n    if (addToFront) state.buffer.unshift(chunk);else state.buffer.push(chunk);\n    if (state.needReadable) emitReadable(stream);\n  }\n  maybeReadMore(stream, state);\n}\nReadable.prototype.isPaused = function () {\n  const state = this._readableState;\n  return state[kPaused] === true || state.flowing === false;\n};\n\n// Backwards compatibility.\nReadable.prototype.setEncoding = function (enc) {\n  const decoder = new StringDecoder(enc);\n  this._readableState.decoder = decoder;\n  // If setEncoding(null), decoder.encoding equals utf8.\n  this._readableState.encoding = this._readableState.decoder.encoding;\n  const buffer = this._readableState.buffer;\n  // Iterate over current buffer to convert already stored Buffers:\n  let content = '';\n  for (const data of buffer) {\n    content += decoder.write(data);\n  }\n  buffer.clear();\n  if (content !== '') buffer.push(content);\n  this._readableState.length = content.length;\n  return this;\n};\n\n// Don't raise the hwm > 1GB.\nconst MAX_HWM = 0x40000000;\nfunction computeNewHighWaterMark(n) {\n  if (n > MAX_HWM) {\n    throw new ERR_OUT_OF_RANGE('size', '<= 1GiB', n);\n  } else {\n    // Get the next highest power of 2 to prevent increasing hwm excessively in\n    // tiny amounts.\n    n--;\n    n |= n >>> 1;\n    n |= n >>> 2;\n    n |= n >>> 4;\n    n |= n >>> 8;\n    n |= n >>> 16;\n    n++;\n  }\n  return n;\n}\n\n// This function is designed to be inlinable, so please take care when making\n// changes to the function body.\nfunction howMuchToRead(n, state) {\n  if (n <= 0 || state.length === 0 && state.ended) return 0;\n  if (state.objectMode) return 1;\n  if (NumberIsNaN(n)) {\n    // Only flow one buffer at a time.\n    if (state.flowing && state.length) return state.buffer.first().length;\n    return state.length;\n  }\n  if (n <= state.length) return n;\n  return state.ended ? state.length : 0;\n}\n\n// You can override either this method, or the async _read(n) below.\nReadable.prototype.read = function (n) {\n  debug('read', n);\n  // Same as parseInt(undefined, 10), however V8 7.3 performance regressed\n  // in this scenario, so we are doing it manually.\n  if (n === undefined) {\n    n = NaN;\n  } else if (!NumberIsInteger(n)) {\n    n = NumberParseInt(n, 10);\n  }\n  const state = this._readableState;\n  const nOrig = n;\n\n  // If we're asking for more than the current hwm, then raise the hwm.\n  if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);\n  if (n !== 0) state.emittedReadable = false;\n\n  // If we're doing read(0) to trigger a readable event, but we\n  // already have a bunch of data in the buffer, then just trigger\n  // the 'readable' event and move on.\n  if (n === 0 && state.needReadable && ((state.highWaterMark !== 0 ? state.length >= state.highWaterMark : state.length > 0) || state.ended)) {\n    debug('read: emitReadable', state.length, state.ended);\n    if (state.length === 0 && state.ended) endReadable(this);else emitReadable(this);\n    return null;\n  }\n  n = howMuchToRead(n, state);\n\n  // If we've ended, and we're now clear, then finish it up.\n  if (n === 0 && state.ended) {\n    if (state.length === 0) endReadable(this);\n    return null;\n  }\n\n  // All the actual chunk generation logic needs to be\n  // *below* the call to _read.  The reason is that in certain\n  // synthetic stream cases, such as passthrough streams, _read\n  // may be a completely synchronous operation which may change\n  // the state of the read buffer, providing enough data when\n  // before there was *not* enough.\n  //\n  // So, the steps are:\n  // 1. Figure out what the state of things will be after we do\n  // a read from the buffer.\n  //\n  // 2. If that resulting state will trigger a _read, then call _read.\n  // Note that this may be asynchronous, or synchronous.  Yes, it is\n  // deeply ugly to write APIs this way, but that still doesn't mean\n  // that the Readable class should behave improperly, as streams are\n  // designed to be sync/async agnostic.\n  // Take note if the _read call is sync or async (ie, if the read call\n  // has returned yet), so that we know whether or not it's safe to emit\n  // 'readable' etc.\n  //\n  // 3. Actually pull the requested chunks out of the buffer and return.\n\n  // if we need a readable event, then we need to do some reading.\n  let doRead = state.needReadable;\n  debug('need readable', doRead);\n\n  // If we currently have less than the highWaterMark, then also read some.\n  if (state.length === 0 || state.length - n < state.highWaterMark) {\n    doRead = true;\n    debug('length less than watermark', doRead);\n  }\n\n  // However, if we've ended, then there's no point, if we're already\n  // reading, then it's unnecessary, if we're constructing we have to wait,\n  // and if we're destroyed or errored, then it's not allowed,\n  if (state.ended || state.reading || state.destroyed || state.errored || !state.constructed) {\n    doRead = false;\n    debug('reading, ended or constructing', doRead);\n  } else if (doRead) {\n    debug('do read');\n    state.reading = true;\n    state.sync = true;\n    // If the length is currently zero, then we *need* a readable event.\n    if (state.length === 0) state.needReadable = true;\n\n    // Call internal read method\n    try {\n      this._read(state.highWaterMark);\n    } catch (err) {\n      errorOrDestroy(this, err);\n    }\n    state.sync = false;\n    // If _read pushed data synchronously, then `reading` will be false,\n    // and we need to re-evaluate how much data we can return to the user.\n    if (!state.reading) n = howMuchToRead(nOrig, state);\n  }\n  let ret;\n  if (n > 0) ret = fromList(n, state);else ret = null;\n  if (ret === null) {\n    state.needReadable = state.length <= state.highWaterMark;\n    n = 0;\n  } else {\n    state.length -= n;\n    if (state.multiAwaitDrain) {\n      state.awaitDrainWriters.clear();\n    } else {\n      state.awaitDrainWriters = null;\n    }\n  }\n  if (state.length === 0) {\n    // If we have nothing in the buffer, then we want to know\n    // as soon as we *do* get something into the buffer.\n    if (!state.ended) state.needReadable = true;\n\n    // If we tried to read() past the EOF, then emit end on the next tick.\n    if (nOrig !== n && state.ended) endReadable(this);\n  }\n  if (ret !== null && !state.errorEmitted && !state.closeEmitted) {\n    state.dataEmitted = true;\n    this.emit('data', ret);\n  }\n  return ret;\n};\nfunction onEofChunk(stream, state) {\n  debug('onEofChunk');\n  if (state.ended) return;\n  if (state.decoder) {\n    const chunk = state.decoder.end();\n    if (chunk && chunk.length) {\n      state.buffer.push(chunk);\n      state.length += state.objectMode ? 1 : chunk.length;\n    }\n  }\n  state.ended = true;\n  if (state.sync) {\n    // If we are sync, wait until next tick to emit the data.\n    // Otherwise we risk emitting data in the flow()\n    // the readable code triggers during a read() call.\n    emitReadable(stream);\n  } else {\n    // Emit 'readable' now to make sure it gets picked up.\n    state.needReadable = false;\n    state.emittedReadable = true;\n    // We have to emit readable now that we are EOF. Modules\n    // in the ecosystem (e.g. dicer) rely on this event being sync.\n    emitReadable_(stream);\n  }\n}\n\n// Don't emit readable right away in sync mode, because this can trigger\n// another read() call => stack overflow.  This way, it might trigger\n// a nextTick recursion warning, but that's not so bad.\nfunction emitReadable(stream) {\n  const state = stream._readableState;\n  debug('emitReadable', state.needReadable, state.emittedReadable);\n  state.needReadable = false;\n  if (!state.emittedReadable) {\n    debug('emitReadable', state.flowing);\n    state.emittedReadable = true;\n    process.nextTick(emitReadable_, stream);\n  }\n}\nfunction emitReadable_(stream) {\n  const state = stream._readableState;\n  debug('emitReadable_', state.destroyed, state.length, state.ended);\n  if (!state.destroyed && !state.errored && (state.length || state.ended)) {\n    stream.emit('readable');\n    state.emittedReadable = false;\n  }\n\n  // The stream needs another readable event if:\n  // 1. It is not flowing, as the flow mechanism will take\n  //    care of it.\n  // 2. It is not ended.\n  // 3. It is below the highWaterMark, so we can schedule\n  //    another readable later.\n  state.needReadable = !state.flowing && !state.ended && state.length <= state.highWaterMark;\n  flow(stream);\n}\n\n// At this point, the user has presumably seen the 'readable' event,\n// and called read() to consume some data.  that may have triggered\n// in turn another _read(n) call, in which case reading = true if\n// it's in progress.\n// However, if we're not ended, or reading, and the length < hwm,\n// then go ahead and try to read some more preemptively.\nfunction maybeReadMore(stream, state) {\n  if (!state.readingMore && state.constructed) {\n    state.readingMore = true;\n    process.nextTick(maybeReadMore_, stream, state);\n  }\n}\nfunction maybeReadMore_(stream, state) {\n  // Attempt to read more data if we should.\n  //\n  // The conditions for reading more data are (one of):\n  // - Not enough data buffered (state.length < state.highWaterMark). The loop\n  //   is responsible for filling the buffer with enough data if such data\n  //   is available. If highWaterMark is 0 and we are not in the flowing mode\n  //   we should _not_ attempt to buffer any extra data. We'll get more data\n  //   when the stream consumer calls read() instead.\n  // - No data in the buffer, and the stream is in flowing mode. In this mode\n  //   the loop below is responsible for ensuring read() is called. Failing to\n  //   call read here would abort the flow and there's no other mechanism for\n  //   continuing the flow if the stream consumer has just subscribed to the\n  //   'data' event.\n  //\n  // In addition to the above conditions to keep reading data, the following\n  // conditions prevent the data from being read:\n  // - The stream has ended (state.ended).\n  // - There is already a pending 'read' operation (state.reading). This is a\n  //   case where the stream has called the implementation defined _read()\n  //   method, but they are processing the call asynchronously and have _not_\n  //   called push() with new data. In this case we skip performing more\n  //   read()s. The execution ends in this method again after the _read() ends\n  //   up calling push() with more data.\n  while (!state.reading && !state.ended && (state.length < state.highWaterMark || state.flowing && state.length === 0)) {\n    const len = state.length;\n    debug('maybeReadMore read 0');\n    stream.read(0);\n    if (len === state.length)\n      // Didn't get any data, stop spinning.\n      break;\n  }\n  state.readingMore = false;\n}\n\n// Abstract method.  to be overridden in specific implementation classes.\n// call cb(er, data) where data is <= n in length.\n// for virtual (non-string, non-buffer) streams, \"length\" is somewhat\n// arbitrary, and perhaps not very meaningful.\nReadable.prototype._read = function (n) {\n  throw new ERR_METHOD_NOT_IMPLEMENTED('_read()');\n};\nReadable.prototype.pipe = function (dest, pipeOpts) {\n  const src = this;\n  const state = this._readableState;\n  if (state.pipes.length === 1) {\n    if (!state.multiAwaitDrain) {\n      state.multiAwaitDrain = true;\n      state.awaitDrainWriters = new SafeSet(state.awaitDrainWriters ? [state.awaitDrainWriters] : []);\n    }\n  }\n  state.pipes.push(dest);\n  debug('pipe count=%d opts=%j', state.pipes.length, pipeOpts);\n  const doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;\n  const endFn = doEnd ? onend : unpipe;\n  if (state.endEmitted) process.nextTick(endFn);else src.once('end', endFn);\n  dest.on('unpipe', onunpipe);\n  function onunpipe(readable, unpipeInfo) {\n    debug('onunpipe');\n    if (readable === src) {\n      if (unpipeInfo && unpipeInfo.hasUnpiped === false) {\n        unpipeInfo.hasUnpiped = true;\n        cleanup();\n      }\n    }\n  }\n  function onend() {\n    debug('onend');\n    dest.end();\n  }\n  let ondrain;\n  let cleanedUp = false;\n  function cleanup() {\n    debug('cleanup');\n    // Cleanup event handlers once the pipe is broken.\n    dest.removeListener('close', onclose);\n    dest.removeListener('finish', onfinish);\n    if (ondrain) {\n      dest.removeListener('drain', ondrain);\n    }\n    dest.removeListener('error', onerror);\n    dest.removeListener('unpipe', onunpipe);\n    src.removeListener('end', onend);\n    src.removeListener('end', unpipe);\n    src.removeListener('data', ondata);\n    cleanedUp = true;\n\n    // If the reader is waiting for a drain event from this\n    // specific writer, then it would cause it to never start\n    // flowing again.\n    // So, if this is awaiting a drain, then we just call it now.\n    // If we don't know, then assume that we are waiting for one.\n    if (ondrain && state.awaitDrainWriters && (!dest._writableState || dest._writableState.needDrain)) ondrain();\n  }\n  function pause() {\n    // If the user unpiped during `dest.write()`, it is possible\n    // to get stuck in a permanently paused state if that write\n    // also returned false.\n    // => Check whether `dest` is still a piping destination.\n    if (!cleanedUp) {\n      if (state.pipes.length === 1 && state.pipes[0] === dest) {\n        debug('false write response, pause', 0);\n        state.awaitDrainWriters = dest;\n        state.multiAwaitDrain = false;\n      } else if (state.pipes.length > 1 && state.pipes.includes(dest)) {\n        debug('false write response, pause', state.awaitDrainWriters.size);\n        state.awaitDrainWriters.add(dest);\n      }\n      src.pause();\n    }\n    if (!ondrain) {\n      // When the dest drains, it reduces the awaitDrain counter\n      // on the source.  This would be more elegant with a .once()\n      // handler in flow(), but adding and removing repeatedly is\n      // too slow.\n      ondrain = pipeOnDrain(src, dest);\n      dest.on('drain', ondrain);\n    }\n  }\n  src.on('data', ondata);\n  function ondata(chunk) {\n    debug('ondata');\n    const ret = dest.write(chunk);\n    debug('dest.write', ret);\n    if (ret === false) {\n      pause();\n    }\n  }\n\n  // If the dest has an error, then stop piping into it.\n  // However, don't suppress the throwing behavior for this.\n  function onerror(er) {\n    debug('onerror', er);\n    unpipe();\n    dest.removeListener('error', onerror);\n    if (dest.listenerCount('error') === 0) {\n      const s = dest._writableState || dest._readableState;\n      if (s && !s.errorEmitted) {\n        // User incorrectly emitted 'error' directly on the stream.\n        errorOrDestroy(dest, er);\n      } else {\n        dest.emit('error', er);\n      }\n    }\n  }\n\n  // Make sure our error handler is attached before userland ones.\n  prependListener(dest, 'error', onerror);\n\n  // Both close and finish should trigger unpipe, but only once.\n  function onclose() {\n    dest.removeListener('finish', onfinish);\n    unpipe();\n  }\n  dest.once('close', onclose);\n  function onfinish() {\n    debug('onfinish');\n    dest.removeListener('close', onclose);\n    unpipe();\n  }\n  dest.once('finish', onfinish);\n  function unpipe() {\n    debug('unpipe');\n    src.unpipe(dest);\n  }\n\n  // Tell the dest that it's being piped to.\n  dest.emit('pipe', src);\n\n  // Start the flow if it hasn't been started already.\n\n  if (dest.writableNeedDrain === true) {\n    if (state.flowing) {\n      pause();\n    }\n  } else if (!state.flowing) {\n    debug('pipe resume');\n    src.resume();\n  }\n  return dest;\n};\nfunction pipeOnDrain(src, dest) {\n  return function pipeOnDrainFunctionResult() {\n    const state = src._readableState;\n\n    // `ondrain` will call directly,\n    // `this` maybe not a reference to dest,\n    // so we use the real dest here.\n    if (state.awaitDrainWriters === dest) {\n      debug('pipeOnDrain', 1);\n      state.awaitDrainWriters = null;\n    } else if (state.multiAwaitDrain) {\n      debug('pipeOnDrain', state.awaitDrainWriters.size);\n      state.awaitDrainWriters.delete(dest);\n    }\n    if ((!state.awaitDrainWriters || state.awaitDrainWriters.size === 0) && src.listenerCount('data')) {\n      src.resume();\n    }\n  };\n}\nReadable.prototype.unpipe = function (dest) {\n  const state = this._readableState;\n  const unpipeInfo = {\n    hasUnpiped: false\n  };\n\n  // If we're not piping anywhere, then do nothing.\n  if (state.pipes.length === 0) return this;\n  if (!dest) {\n    // remove all.\n    const dests = state.pipes;\n    state.pipes = [];\n    this.pause();\n    for (let i = 0; i < dests.length; i++) dests[i].emit('unpipe', this, {\n      hasUnpiped: false\n    });\n    return this;\n  }\n\n  // Try to find the right one.\n  const index = ArrayPrototypeIndexOf(state.pipes, dest);\n  if (index === -1) return this;\n  state.pipes.splice(index, 1);\n  if (state.pipes.length === 0) this.pause();\n  dest.emit('unpipe', this, unpipeInfo);\n  return this;\n};\n\n// Set up data events if they are asked for\n// Ensure readable listeners eventually get something.\nReadable.prototype.on = function (ev, fn) {\n  const res = Stream.prototype.on.call(this, ev, fn);\n  const state = this._readableState;\n  if (ev === 'data') {\n    // Update readableListening so that resume() may be a no-op\n    // a few lines down. This is needed to support once('readable').\n    state.readableListening = this.listenerCount('readable') > 0;\n\n    // Try start flowing on next tick if stream isn't explicitly paused.\n    if (state.flowing !== false) this.resume();\n  } else if (ev === 'readable') {\n    if (!state.endEmitted && !state.readableListening) {\n      state.readableListening = state.needReadable = true;\n      state.flowing = false;\n      state.emittedReadable = false;\n      debug('on readable', state.length, state.reading);\n      if (state.length) {\n        emitReadable(this);\n      } else if (!state.reading) {\n        process.nextTick(nReadingNextTick, this);\n      }\n    }\n  }\n  return res;\n};\nReadable.prototype.addListener = Readable.prototype.on;\nReadable.prototype.removeListener = function (ev, fn) {\n  const res = Stream.prototype.removeListener.call(this, ev, fn);\n  if (ev === 'readable') {\n    // We need to check if there is someone still listening to\n    // readable and reset the state. However this needs to happen\n    // after readable has been emitted but before I/O (nextTick) to\n    // support once('readable', fn) cycles. This means that calling\n    // resume within the same tick will have no\n    // effect.\n    process.nextTick(updateReadableListening, this);\n  }\n  return res;\n};\nReadable.prototype.off = Readable.prototype.removeListener;\nReadable.prototype.removeAllListeners = function (ev) {\n  const res = Stream.prototype.removeAllListeners.apply(this, arguments);\n  if (ev === 'readable' || ev === undefined) {\n    // We need to check if there is someone still listening to\n    // readable and reset the state. However this needs to happen\n    // after readable has been emitted but before I/O (nextTick) to\n    // support once('readable', fn) cycles. This means that calling\n    // resume within the same tick will have no\n    // effect.\n    process.nextTick(updateReadableListening, this);\n  }\n  return res;\n};\nfunction updateReadableListening(self) {\n  const state = self._readableState;\n  state.readableListening = self.listenerCount('readable') > 0;\n  if (state.resumeScheduled && state[kPaused] === false) {\n    // Flowing needs to be set to true now, otherwise\n    // the upcoming resume will not flow.\n    state.flowing = true;\n\n    // Crude way to check if we should resume.\n  } else if (self.listenerCount('data') > 0) {\n    self.resume();\n  } else if (!state.readableListening) {\n    state.flowing = null;\n  }\n}\nfunction nReadingNextTick(self) {\n  debug('readable nexttick read 0');\n  self.read(0);\n}\n\n// pause() and resume() are remnants of the legacy readable stream API\n// If the user uses them, then switch into old mode.\nReadable.prototype.resume = function () {\n  const state = this._readableState;\n  if (!state.flowing) {\n    debug('resume');\n    // We flow only if there is no one listening\n    // for readable, but we still have to call\n    // resume().\n    state.flowing = !state.readableListening;\n    resume(this, state);\n  }\n  state[kPaused] = false;\n  return this;\n};\nfunction resume(stream, state) {\n  if (!state.resumeScheduled) {\n    state.resumeScheduled = true;\n    process.nextTick(resume_, stream, state);\n  }\n}\nfunction resume_(stream, state) {\n  debug('resume', state.reading);\n  if (!state.reading) {\n    stream.read(0);\n  }\n  state.resumeScheduled = false;\n  stream.emit('resume');\n  flow(stream);\n  if (state.flowing && !state.reading) stream.read(0);\n}\nReadable.prototype.pause = function () {\n  debug('call pause flowing=%j', this._readableState.flowing);\n  if (this._readableState.flowing !== false) {\n    debug('pause');\n    this._readableState.flowing = false;\n    this.emit('pause');\n  }\n  this._readableState[kPaused] = true;\n  return this;\n};\nfunction flow(stream) {\n  const state = stream._readableState;\n  debug('flow', state.flowing);\n  while (state.flowing && stream.read() !== null);\n}\n\n// Wrap an old-style stream as the async data source.\n// This is *not* part of the readable stream interface.\n// It is an ugly unfortunate mess of history.\nReadable.prototype.wrap = function (stream) {\n  let paused = false;\n\n  // TODO (ronag): Should this.destroy(err) emit\n  // 'error' on the wrapped stream? Would require\n  // a static factory method, e.g. Readable.wrap(stream).\n\n  stream.on('data', chunk => {\n    if (!this.push(chunk) && stream.pause) {\n      paused = true;\n      stream.pause();\n    }\n  });\n  stream.on('end', () => {\n    this.push(null);\n  });\n  stream.on('error', err => {\n    errorOrDestroy(this, err);\n  });\n  stream.on('close', () => {\n    this.destroy();\n  });\n  stream.on('destroy', () => {\n    this.destroy();\n  });\n  this._read = () => {\n    if (paused && stream.resume) {\n      paused = false;\n      stream.resume();\n    }\n  };\n\n  // Proxy all the other methods. Important when wrapping filters and duplexes.\n  const streamKeys = ObjectKeys(stream);\n  for (let j = 1; j < streamKeys.length; j++) {\n    const i = streamKeys[j];\n    if (this[i] === undefined && typeof stream[i] === 'function') {\n      this[i] = stream[i].bind(stream);\n    }\n  }\n  return this;\n};\nReadable.prototype[SymbolAsyncIterator] = function () {\n  return streamToAsyncIterator(this);\n};\nReadable.prototype.iterator = function (options) {\n  if (options !== undefined) {\n    validateObject(options, 'options');\n  }\n  return streamToAsyncIterator(this, options);\n};\nfunction streamToAsyncIterator(stream, options) {\n  if (typeof stream.read !== 'function') {\n    stream = Readable.wrap(stream, {\n      objectMode: true\n    });\n  }\n  const iter = createAsyncIterator(stream, options);\n  iter.stream = stream;\n  return iter;\n}\nasync function* createAsyncIterator(stream, options) {\n  let callback = nop;\n  function next(resolve) {\n    if (this === stream) {\n      callback();\n      callback = nop;\n    } else {\n      callback = resolve;\n    }\n  }\n  stream.on('readable', next);\n  let error;\n  const cleanup = eos(stream, {\n    writable: false\n  }, err => {\n    error = err ? aggregateTwoErrors(error, err) : null;\n    callback();\n    callback = nop;\n  });\n  try {\n    while (true) {\n      const chunk = stream.destroyed ? null : stream.read();\n      if (chunk !== null) {\n        yield chunk;\n      } else if (error) {\n        throw error;\n      } else if (error === null) {\n        return;\n      } else {\n        await new Promise(next);\n      }\n    }\n  } catch (err) {\n    error = aggregateTwoErrors(error, err);\n    throw error;\n  } finally {\n    if ((error || (options === null || options === undefined ? undefined : options.destroyOnReturn) !== false) && (error === undefined || stream._readableState.autoDestroy)) {\n      destroyImpl.destroyer(stream, null);\n    } else {\n      stream.off('readable', next);\n      cleanup();\n    }\n  }\n}\n\n// Making it explicit these properties are not enumerable\n// because otherwise some prototype manipulation in\n// userland will fail.\nObjectDefineProperties(Readable.prototype, {\n  readable: {\n    __proto__: null,\n    get() {\n      const r = this._readableState;\n      // r.readable === false means that this is part of a Duplex stream\n      // where the readable side was disabled upon construction.\n      // Compat. The user might manually disable readable side through\n      // deprecated setter.\n      return !!r && r.readable !== false && !r.destroyed && !r.errorEmitted && !r.endEmitted;\n    },\n    set(val) {\n      // Backwards compat.\n      if (this._readableState) {\n        this._readableState.readable = !!val;\n      }\n    }\n  },\n  readableDidRead: {\n    __proto__: null,\n    enumerable: false,\n    get: function () {\n      return this._readableState.dataEmitted;\n    }\n  },\n  readableAborted: {\n    __proto__: null,\n    enumerable: false,\n    get: function () {\n      return !!(this._readableState.readable !== false && (this._readableState.destroyed || this._readableState.errored) && !this._readableState.endEmitted);\n    }\n  },\n  readableHighWaterMark: {\n    __proto__: null,\n    enumerable: false,\n    get: function () {\n      return this._readableState.highWaterMark;\n    }\n  },\n  readableBuffer: {\n    __proto__: null,\n    enumerable: false,\n    get: function () {\n      return this._readableState && this._readableState.buffer;\n    }\n  },\n  readableFlowing: {\n    __proto__: null,\n    enumerable: false,\n    get: function () {\n      return this._readableState.flowing;\n    },\n    set: function (state) {\n      if (this._readableState) {\n        this._readableState.flowing = state;\n      }\n    }\n  },\n  readableLength: {\n    __proto__: null,\n    enumerable: false,\n    get() {\n      return this._readableState.length;\n    }\n  },\n  readableObjectMode: {\n    __proto__: null,\n    enumerable: false,\n    get() {\n      return this._readableState ? this._readableState.objectMode : false;\n    }\n  },\n  readableEncoding: {\n    __proto__: null,\n    enumerable: false,\n    get() {\n      return this._readableState ? this._readableState.encoding : null;\n    }\n  },\n  errored: {\n    __proto__: null,\n    enumerable: false,\n    get() {\n      return this._readableState ? this._readableState.errored : null;\n    }\n  },\n  closed: {\n    __proto__: null,\n    get() {\n      return this._readableState ? this._readableState.closed : false;\n    }\n  },\n  destroyed: {\n    __proto__: null,\n    enumerable: false,\n    get() {\n      return this._readableState ? this._readableState.destroyed : false;\n    },\n    set(value) {\n      // We ignore the value if the stream\n      // has not been initialized yet.\n      if (!this._readableState) {\n        return;\n      }\n\n      // Backward compatibility, the user is explicitly\n      // managing destroyed.\n      this._readableState.destroyed = value;\n    }\n  },\n  readableEnded: {\n    __proto__: null,\n    enumerable: false,\n    get() {\n      return this._readableState ? this._readableState.endEmitted : false;\n    }\n  }\n});\nObjectDefineProperties(ReadableState.prototype, {\n  // Legacy getter for `pipesCount`.\n  pipesCount: {\n    __proto__: null,\n    get() {\n      return this.pipes.length;\n    }\n  },\n  // Legacy property for `paused`.\n  paused: {\n    __proto__: null,\n    get() {\n      return this[kPaused] !== false;\n    },\n    set(value) {\n      this[kPaused] = !!value;\n    }\n  }\n});\n\n// Exposed for testing purposes only.\nReadable._fromList = fromList;\n\n// Pluck off n bytes from an array of buffers.\n// Length is the combined lengths of all the buffers in the list.\n// This function is designed to be inlinable, so please take care when making\n// changes to the function body.\nfunction fromList(n, state) {\n  // nothing buffered.\n  if (state.length === 0) return null;\n  let ret;\n  if (state.objectMode) ret = state.buffer.shift();else if (!n || n >= state.length) {\n    // Read it all, truncate the list.\n    if (state.decoder) ret = state.buffer.join('');else if (state.buffer.length === 1) ret = state.buffer.first();else ret = state.buffer.concat(state.length);\n    state.buffer.clear();\n  } else {\n    // read part of list.\n    ret = state.buffer.consume(n, state.decoder);\n  }\n  return ret;\n}\nfunction endReadable(stream) {\n  const state = stream._readableState;\n  debug('endReadable', state.endEmitted);\n  if (!state.endEmitted) {\n    state.ended = true;\n    process.nextTick(endReadableNT, state, stream);\n  }\n}\nfunction endReadableNT(state, stream) {\n  debug('endReadableNT', state.endEmitted, state.length);\n\n  // Check that we didn't get one last unshift.\n  if (!state.errored && !state.closeEmitted && !state.endEmitted && state.length === 0) {\n    state.endEmitted = true;\n    stream.emit('end');\n    if (stream.writable && stream.allowHalfOpen === false) {\n      process.nextTick(endWritableNT, stream);\n    } else if (state.autoDestroy) {\n      // In case of duplex streams we need a way to detect\n      // if the writable side is ready for autoDestroy as well.\n      const wState = stream._writableState;\n      const autoDestroy = !wState || wState.autoDestroy && (\n      // We don't expect the writable to ever 'finish'\n      // if writable is explicitly set to false.\n      wState.finished || wState.writable === false);\n      if (autoDestroy) {\n        stream.destroy();\n      }\n    }\n  }\n}\nfunction endWritableNT(stream) {\n  const writable = stream.writable && !stream.writableEnded && !stream.destroyed;\n  if (writable) {\n    stream.end();\n  }\n}\nReadable.from = function (iterable, opts) {\n  return from(Readable, iterable, opts);\n};\nlet webStreamsAdapters;\n\n// Lazy to avoid circular references\nfunction lazyWebStreams() {\n  if (webStreamsAdapters === undefined) webStreamsAdapters = {};\n  return webStreamsAdapters;\n}\nReadable.fromWeb = function (readableStream, options) {\n  return lazyWebStreams().newStreamReadableFromReadableStream(readableStream, options);\n};\nReadable.toWeb = function (streamReadable, options) {\n  return lazyWebStreams().newReadableStreamFromStreamReadable(streamReadable, options);\n};\nReadable.wrap = function (src, options) {\n  var _ref, _src$readableObjectMo;\n  return new Readable({\n    objectMode: (_ref = (_src$readableObjectMo = src.readableObjectMode) !== null && _src$readableObjectMo !== undefined ? _src$readableObjectMo : src.objectMode) !== null && _ref !== undefined ? _ref : true,\n    ...options,\n    destroy(err, callback) {\n      destroyImpl.destroyer(src, err);\n      callback(err);\n    }\n  }).wrap(src);\n};","map":{"version":3,"names":["process","require","ArrayPrototypeIndexOf","NumberIsInteger","NumberIsNaN","NumberParseInt","ObjectDefineProperties","ObjectKeys","ObjectSetPrototypeOf","Promise","SafeSet","SymbolAsyncIterator","Symbol","module","exports","Readable","ReadableState","EventEmitter","EE","Stream","prependListener","Buffer","addAbortSignal","eos","debug","debuglog","fn","BufferList","destroyImpl","getHighWaterMark","getDefaultHighWaterMark","aggregateTwoErrors","codes","ERR_INVALID_ARG_TYPE","ERR_METHOD_NOT_IMPLEMENTED","ERR_OUT_OF_RANGE","ERR_STREAM_PUSH_AFTER_EOF","ERR_STREAM_UNSHIFT_AFTER_END_EVENT","validateObject","kPaused","StringDecoder","from","prototype","nop","errorOrDestroy","options","stream","isDuplex","objectMode","readableObjectMode","highWaterMark","buffer","length","pipes","flowing","ended","endEmitted","reading","constructed","sync","needReadable","emittedReadable","readableListening","resumeScheduled","errorEmitted","emitClose","autoDestroy","destroyed","errored","closed","closeEmitted","defaultEncoding","awaitDrainWriters","multiAwaitDrain","readingMore","dataEmitted","decoder","encoding","_readableState","read","_read","destroy","_destroy","construct","_construct","signal","call","maybeReadMore","_undestroy","undestroy","err","cb","captureRejectionSymbol","push","chunk","readableAddChunk","unshift","addToFront","state","toString","_isUint8Array","_uint8ArrayToBuffer","onEofChunk","addChunk","write","listenerCount","clear","emit","emitReadable","isPaused","setEncoding","enc","content","data","MAX_HWM","computeNewHighWaterMark","n","howMuchToRead","first","undefined","NaN","nOrig","endReadable","doRead","ret","fromList","end","emitReadable_","nextTick","flow","maybeReadMore_","len","pipe","dest","pipeOpts","src","doEnd","stdout","stderr","endFn","onend","unpipe","once","on","onunpipe","readable","unpipeInfo","hasUnpiped","cleanup","ondrain","cleanedUp","removeListener","onclose","onfinish","onerror","ondata","_writableState","needDrain","pause","includes","size","add","pipeOnDrain","er","s","writableNeedDrain","resume","pipeOnDrainFunctionResult","delete","dests","i","index","splice","ev","res","nReadingNextTick","addListener","updateReadableListening","off","removeAllListeners","apply","arguments","self","resume_","wrap","paused","streamKeys","j","bind","streamToAsyncIterator","iterator","iter","createAsyncIterator","callback","next","resolve","error","writable","destroyOnReturn","destroyer","__proto__","get","r","set","val","readableDidRead","enumerable","readableAborted","readableHighWaterMark","readableBuffer","readableFlowing","readableLength","readableEncoding","value","readableEnded","pipesCount","_fromList","shift","join","concat","consume","endReadableNT","allowHalfOpen","endWritableNT","wState","finished","writableEnded","iterable","opts","webStreamsAdapters","lazyWebStreams","fromWeb","readableStream","newStreamReadableFromReadableStream","toWeb","streamReadable","newReadableStreamFromStreamReadable","_ref","_src$readableObjectMo"],"sources":["/Users/jstanton/Coding/FieldDock/FieldDockMain/node_modules/mqtt/node_modules/readable-stream/lib/internal/streams/readable.js"],"sourcesContent":["/* replacement start */\n\nconst process = require('process/')\n\n/* replacement end */\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n;('use strict')\nconst {\n  ArrayPrototypeIndexOf,\n  NumberIsInteger,\n  NumberIsNaN,\n  NumberParseInt,\n  ObjectDefineProperties,\n  ObjectKeys,\n  ObjectSetPrototypeOf,\n  Promise,\n  SafeSet,\n  SymbolAsyncIterator,\n  Symbol\n} = require('../../ours/primordials')\nmodule.exports = Readable\nReadable.ReadableState = ReadableState\nconst { EventEmitter: EE } = require('events')\nconst { Stream, prependListener } = require('./legacy')\nconst { Buffer } = require('buffer')\nconst { addAbortSignal } = require('./add-abort-signal')\nconst eos = require('./end-of-stream')\nlet debug = require('../../ours/util').debuglog('stream', (fn) => {\n  debug = fn\n})\nconst BufferList = require('./buffer_list')\nconst destroyImpl = require('./destroy')\nconst { getHighWaterMark, getDefaultHighWaterMark } = require('./state')\nconst {\n  aggregateTwoErrors,\n  codes: {\n    ERR_INVALID_ARG_TYPE,\n    ERR_METHOD_NOT_IMPLEMENTED,\n    ERR_OUT_OF_RANGE,\n    ERR_STREAM_PUSH_AFTER_EOF,\n    ERR_STREAM_UNSHIFT_AFTER_END_EVENT\n  }\n} = require('../../ours/errors')\nconst { validateObject } = require('../validators')\nconst kPaused = Symbol('kPaused')\nconst { StringDecoder } = require('string_decoder')\nconst from = require('./from')\nObjectSetPrototypeOf(Readable.prototype, Stream.prototype)\nObjectSetPrototypeOf(Readable, Stream)\nconst nop = () => {}\nconst { errorOrDestroy } = destroyImpl\nfunction ReadableState(options, stream, isDuplex) {\n  // Duplex streams are both readable and writable, but share\n  // the same options object.\n  // However, some cases require setting options to different\n  // values for the readable and the writable sides of the duplex stream.\n  // These options can be provided separately as readableXXX and writableXXX.\n  if (typeof isDuplex !== 'boolean') isDuplex = stream instanceof require('./duplex')\n\n  // Object stream flag. Used to make read(n) ignore n and to\n  // make all the buffer merging and length checks go away.\n  this.objectMode = !!(options && options.objectMode)\n  if (isDuplex) this.objectMode = this.objectMode || !!(options && options.readableObjectMode)\n\n  // The point at which it stops calling _read() to fill the buffer\n  // Note: 0 is a valid value, means \"don't call _read preemptively ever\"\n  this.highWaterMark = options\n    ? getHighWaterMark(this, options, 'readableHighWaterMark', isDuplex)\n    : getDefaultHighWaterMark(false)\n\n  // A linked list is used to store data chunks instead of an array because the\n  // linked list can remove elements from the beginning faster than\n  // array.shift().\n  this.buffer = new BufferList()\n  this.length = 0\n  this.pipes = []\n  this.flowing = null\n  this.ended = false\n  this.endEmitted = false\n  this.reading = false\n\n  // Stream is still being constructed and cannot be\n  // destroyed until construction finished or failed.\n  // Async construction is opt in, therefore we start as\n  // constructed.\n  this.constructed = true\n\n  // A flag to be able to tell if the event 'readable'/'data' is emitted\n  // immediately, or on a later tick.  We set this to true at first, because\n  // any actions that shouldn't happen until \"later\" should generally also\n  // not happen before the first read call.\n  this.sync = true\n\n  // Whenever we return null, then we set a flag to say\n  // that we're awaiting a 'readable' event emission.\n  this.needReadable = false\n  this.emittedReadable = false\n  this.readableListening = false\n  this.resumeScheduled = false\n  this[kPaused] = null\n\n  // True if the error was already emitted and should not be thrown again.\n  this.errorEmitted = false\n\n  // Should close be emitted on destroy. Defaults to true.\n  this.emitClose = !options || options.emitClose !== false\n\n  // Should .destroy() be called after 'end' (and potentially 'finish').\n  this.autoDestroy = !options || options.autoDestroy !== false\n\n  // Has it been destroyed.\n  this.destroyed = false\n\n  // Indicates whether the stream has errored. When true no further\n  // _read calls, 'data' or 'readable' events should occur. This is needed\n  // since when autoDestroy is disabled we need a way to tell whether the\n  // stream has failed.\n  this.errored = null\n\n  // Indicates whether the stream has finished destroying.\n  this.closed = false\n\n  // True if close has been emitted or would have been emitted\n  // depending on emitClose.\n  this.closeEmitted = false\n\n  // Crypto is kind of old and crusty.  Historically, its default string\n  // encoding is 'binary' so we have to make this configurable.\n  // Everything else in the universe uses 'utf8', though.\n  this.defaultEncoding = (options && options.defaultEncoding) || 'utf8'\n\n  // Ref the piped dest which we need a drain event on it\n  // type: null | Writable | Set<Writable>.\n  this.awaitDrainWriters = null\n  this.multiAwaitDrain = false\n\n  // If true, a maybeReadMore has been scheduled.\n  this.readingMore = false\n  this.dataEmitted = false\n  this.decoder = null\n  this.encoding = null\n  if (options && options.encoding) {\n    this.decoder = new StringDecoder(options.encoding)\n    this.encoding = options.encoding\n  }\n}\nfunction Readable(options) {\n  if (!(this instanceof Readable)) return new Readable(options)\n\n  // Checking for a Stream.Duplex instance is faster here instead of inside\n  // the ReadableState constructor, at least with V8 6.5.\n  const isDuplex = this instanceof require('./duplex')\n  this._readableState = new ReadableState(options, this, isDuplex)\n  if (options) {\n    if (typeof options.read === 'function') this._read = options.read\n    if (typeof options.destroy === 'function') this._destroy = options.destroy\n    if (typeof options.construct === 'function') this._construct = options.construct\n    if (options.signal && !isDuplex) addAbortSignal(options.signal, this)\n  }\n  Stream.call(this, options)\n  destroyImpl.construct(this, () => {\n    if (this._readableState.needReadable) {\n      maybeReadMore(this, this._readableState)\n    }\n  })\n}\nReadable.prototype.destroy = destroyImpl.destroy\nReadable.prototype._undestroy = destroyImpl.undestroy\nReadable.prototype._destroy = function (err, cb) {\n  cb(err)\n}\nReadable.prototype[EE.captureRejectionSymbol] = function (err) {\n  this.destroy(err)\n}\n\n// Manually shove something into the read() buffer.\n// This returns true if the highWaterMark has not been hit yet,\n// similar to how Writable.write() returns true if you should\n// write() some more.\nReadable.prototype.push = function (chunk, encoding) {\n  return readableAddChunk(this, chunk, encoding, false)\n}\n\n// Unshift should *always* be something directly out of read().\nReadable.prototype.unshift = function (chunk, encoding) {\n  return readableAddChunk(this, chunk, encoding, true)\n}\nfunction readableAddChunk(stream, chunk, encoding, addToFront) {\n  debug('readableAddChunk', chunk)\n  const state = stream._readableState\n  let err\n  if (!state.objectMode) {\n    if (typeof chunk === 'string') {\n      encoding = encoding || state.defaultEncoding\n      if (state.encoding !== encoding) {\n        if (addToFront && state.encoding) {\n          // When unshifting, if state.encoding is set, we have to save\n          // the string in the BufferList with the state encoding.\n          chunk = Buffer.from(chunk, encoding).toString(state.encoding)\n        } else {\n          chunk = Buffer.from(chunk, encoding)\n          encoding = ''\n        }\n      }\n    } else if (chunk instanceof Buffer) {\n      encoding = ''\n    } else if (Stream._isUint8Array(chunk)) {\n      chunk = Stream._uint8ArrayToBuffer(chunk)\n      encoding = ''\n    } else if (chunk != null) {\n      err = new ERR_INVALID_ARG_TYPE('chunk', ['string', 'Buffer', 'Uint8Array'], chunk)\n    }\n  }\n  if (err) {\n    errorOrDestroy(stream, err)\n  } else if (chunk === null) {\n    state.reading = false\n    onEofChunk(stream, state)\n  } else if (state.objectMode || (chunk && chunk.length > 0)) {\n    if (addToFront) {\n      if (state.endEmitted) errorOrDestroy(stream, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT())\n      else if (state.destroyed || state.errored) return false\n      else addChunk(stream, state, chunk, true)\n    } else if (state.ended) {\n      errorOrDestroy(stream, new ERR_STREAM_PUSH_AFTER_EOF())\n    } else if (state.destroyed || state.errored) {\n      return false\n    } else {\n      state.reading = false\n      if (state.decoder && !encoding) {\n        chunk = state.decoder.write(chunk)\n        if (state.objectMode || chunk.length !== 0) addChunk(stream, state, chunk, false)\n        else maybeReadMore(stream, state)\n      } else {\n        addChunk(stream, state, chunk, false)\n      }\n    }\n  } else if (!addToFront) {\n    state.reading = false\n    maybeReadMore(stream, state)\n  }\n\n  // We can push more data if we are below the highWaterMark.\n  // Also, if we have no data yet, we can stand some more bytes.\n  // This is to work around cases where hwm=0, such as the repl.\n  return !state.ended && (state.length < state.highWaterMark || state.length === 0)\n}\nfunction addChunk(stream, state, chunk, addToFront) {\n  if (state.flowing && state.length === 0 && !state.sync && stream.listenerCount('data') > 0) {\n    // Use the guard to avoid creating `Set()` repeatedly\n    // when we have multiple pipes.\n    if (state.multiAwaitDrain) {\n      state.awaitDrainWriters.clear()\n    } else {\n      state.awaitDrainWriters = null\n    }\n    state.dataEmitted = true\n    stream.emit('data', chunk)\n  } else {\n    // Update the buffer info.\n    state.length += state.objectMode ? 1 : chunk.length\n    if (addToFront) state.buffer.unshift(chunk)\n    else state.buffer.push(chunk)\n    if (state.needReadable) emitReadable(stream)\n  }\n  maybeReadMore(stream, state)\n}\nReadable.prototype.isPaused = function () {\n  const state = this._readableState\n  return state[kPaused] === true || state.flowing === false\n}\n\n// Backwards compatibility.\nReadable.prototype.setEncoding = function (enc) {\n  const decoder = new StringDecoder(enc)\n  this._readableState.decoder = decoder\n  // If setEncoding(null), decoder.encoding equals utf8.\n  this._readableState.encoding = this._readableState.decoder.encoding\n  const buffer = this._readableState.buffer\n  // Iterate over current buffer to convert already stored Buffers:\n  let content = ''\n  for (const data of buffer) {\n    content += decoder.write(data)\n  }\n  buffer.clear()\n  if (content !== '') buffer.push(content)\n  this._readableState.length = content.length\n  return this\n}\n\n// Don't raise the hwm > 1GB.\nconst MAX_HWM = 0x40000000\nfunction computeNewHighWaterMark(n) {\n  if (n > MAX_HWM) {\n    throw new ERR_OUT_OF_RANGE('size', '<= 1GiB', n)\n  } else {\n    // Get the next highest power of 2 to prevent increasing hwm excessively in\n    // tiny amounts.\n    n--\n    n |= n >>> 1\n    n |= n >>> 2\n    n |= n >>> 4\n    n |= n >>> 8\n    n |= n >>> 16\n    n++\n  }\n  return n\n}\n\n// This function is designed to be inlinable, so please take care when making\n// changes to the function body.\nfunction howMuchToRead(n, state) {\n  if (n <= 0 || (state.length === 0 && state.ended)) return 0\n  if (state.objectMode) return 1\n  if (NumberIsNaN(n)) {\n    // Only flow one buffer at a time.\n    if (state.flowing && state.length) return state.buffer.first().length\n    return state.length\n  }\n  if (n <= state.length) return n\n  return state.ended ? state.length : 0\n}\n\n// You can override either this method, or the async _read(n) below.\nReadable.prototype.read = function (n) {\n  debug('read', n)\n  // Same as parseInt(undefined, 10), however V8 7.3 performance regressed\n  // in this scenario, so we are doing it manually.\n  if (n === undefined) {\n    n = NaN\n  } else if (!NumberIsInteger(n)) {\n    n = NumberParseInt(n, 10)\n  }\n  const state = this._readableState\n  const nOrig = n\n\n  // If we're asking for more than the current hwm, then raise the hwm.\n  if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n)\n  if (n !== 0) state.emittedReadable = false\n\n  // If we're doing read(0) to trigger a readable event, but we\n  // already have a bunch of data in the buffer, then just trigger\n  // the 'readable' event and move on.\n  if (\n    n === 0 &&\n    state.needReadable &&\n    ((state.highWaterMark !== 0 ? state.length >= state.highWaterMark : state.length > 0) || state.ended)\n  ) {\n    debug('read: emitReadable', state.length, state.ended)\n    if (state.length === 0 && state.ended) endReadable(this)\n    else emitReadable(this)\n    return null\n  }\n  n = howMuchToRead(n, state)\n\n  // If we've ended, and we're now clear, then finish it up.\n  if (n === 0 && state.ended) {\n    if (state.length === 0) endReadable(this)\n    return null\n  }\n\n  // All the actual chunk generation logic needs to be\n  // *below* the call to _read.  The reason is that in certain\n  // synthetic stream cases, such as passthrough streams, _read\n  // may be a completely synchronous operation which may change\n  // the state of the read buffer, providing enough data when\n  // before there was *not* enough.\n  //\n  // So, the steps are:\n  // 1. Figure out what the state of things will be after we do\n  // a read from the buffer.\n  //\n  // 2. If that resulting state will trigger a _read, then call _read.\n  // Note that this may be asynchronous, or synchronous.  Yes, it is\n  // deeply ugly to write APIs this way, but that still doesn't mean\n  // that the Readable class should behave improperly, as streams are\n  // designed to be sync/async agnostic.\n  // Take note if the _read call is sync or async (ie, if the read call\n  // has returned yet), so that we know whether or not it's safe to emit\n  // 'readable' etc.\n  //\n  // 3. Actually pull the requested chunks out of the buffer and return.\n\n  // if we need a readable event, then we need to do some reading.\n  let doRead = state.needReadable\n  debug('need readable', doRead)\n\n  // If we currently have less than the highWaterMark, then also read some.\n  if (state.length === 0 || state.length - n < state.highWaterMark) {\n    doRead = true\n    debug('length less than watermark', doRead)\n  }\n\n  // However, if we've ended, then there's no point, if we're already\n  // reading, then it's unnecessary, if we're constructing we have to wait,\n  // and if we're destroyed or errored, then it's not allowed,\n  if (state.ended || state.reading || state.destroyed || state.errored || !state.constructed) {\n    doRead = false\n    debug('reading, ended or constructing', doRead)\n  } else if (doRead) {\n    debug('do read')\n    state.reading = true\n    state.sync = true\n    // If the length is currently zero, then we *need* a readable event.\n    if (state.length === 0) state.needReadable = true\n\n    // Call internal read method\n    try {\n      this._read(state.highWaterMark)\n    } catch (err) {\n      errorOrDestroy(this, err)\n    }\n    state.sync = false\n    // If _read pushed data synchronously, then `reading` will be false,\n    // and we need to re-evaluate how much data we can return to the user.\n    if (!state.reading) n = howMuchToRead(nOrig, state)\n  }\n  let ret\n  if (n > 0) ret = fromList(n, state)\n  else ret = null\n  if (ret === null) {\n    state.needReadable = state.length <= state.highWaterMark\n    n = 0\n  } else {\n    state.length -= n\n    if (state.multiAwaitDrain) {\n      state.awaitDrainWriters.clear()\n    } else {\n      state.awaitDrainWriters = null\n    }\n  }\n  if (state.length === 0) {\n    // If we have nothing in the buffer, then we want to know\n    // as soon as we *do* get something into the buffer.\n    if (!state.ended) state.needReadable = true\n\n    // If we tried to read() past the EOF, then emit end on the next tick.\n    if (nOrig !== n && state.ended) endReadable(this)\n  }\n  if (ret !== null && !state.errorEmitted && !state.closeEmitted) {\n    state.dataEmitted = true\n    this.emit('data', ret)\n  }\n  return ret\n}\nfunction onEofChunk(stream, state) {\n  debug('onEofChunk')\n  if (state.ended) return\n  if (state.decoder) {\n    const chunk = state.decoder.end()\n    if (chunk && chunk.length) {\n      state.buffer.push(chunk)\n      state.length += state.objectMode ? 1 : chunk.length\n    }\n  }\n  state.ended = true\n  if (state.sync) {\n    // If we are sync, wait until next tick to emit the data.\n    // Otherwise we risk emitting data in the flow()\n    // the readable code triggers during a read() call.\n    emitReadable(stream)\n  } else {\n    // Emit 'readable' now to make sure it gets picked up.\n    state.needReadable = false\n    state.emittedReadable = true\n    // We have to emit readable now that we are EOF. Modules\n    // in the ecosystem (e.g. dicer) rely on this event being sync.\n    emitReadable_(stream)\n  }\n}\n\n// Don't emit readable right away in sync mode, because this can trigger\n// another read() call => stack overflow.  This way, it might trigger\n// a nextTick recursion warning, but that's not so bad.\nfunction emitReadable(stream) {\n  const state = stream._readableState\n  debug('emitReadable', state.needReadable, state.emittedReadable)\n  state.needReadable = false\n  if (!state.emittedReadable) {\n    debug('emitReadable', state.flowing)\n    state.emittedReadable = true\n    process.nextTick(emitReadable_, stream)\n  }\n}\nfunction emitReadable_(stream) {\n  const state = stream._readableState\n  debug('emitReadable_', state.destroyed, state.length, state.ended)\n  if (!state.destroyed && !state.errored && (state.length || state.ended)) {\n    stream.emit('readable')\n    state.emittedReadable = false\n  }\n\n  // The stream needs another readable event if:\n  // 1. It is not flowing, as the flow mechanism will take\n  //    care of it.\n  // 2. It is not ended.\n  // 3. It is below the highWaterMark, so we can schedule\n  //    another readable later.\n  state.needReadable = !state.flowing && !state.ended && state.length <= state.highWaterMark\n  flow(stream)\n}\n\n// At this point, the user has presumably seen the 'readable' event,\n// and called read() to consume some data.  that may have triggered\n// in turn another _read(n) call, in which case reading = true if\n// it's in progress.\n// However, if we're not ended, or reading, and the length < hwm,\n// then go ahead and try to read some more preemptively.\nfunction maybeReadMore(stream, state) {\n  if (!state.readingMore && state.constructed) {\n    state.readingMore = true\n    process.nextTick(maybeReadMore_, stream, state)\n  }\n}\nfunction maybeReadMore_(stream, state) {\n  // Attempt to read more data if we should.\n  //\n  // The conditions for reading more data are (one of):\n  // - Not enough data buffered (state.length < state.highWaterMark). The loop\n  //   is responsible for filling the buffer with enough data if such data\n  //   is available. If highWaterMark is 0 and we are not in the flowing mode\n  //   we should _not_ attempt to buffer any extra data. We'll get more data\n  //   when the stream consumer calls read() instead.\n  // - No data in the buffer, and the stream is in flowing mode. In this mode\n  //   the loop below is responsible for ensuring read() is called. Failing to\n  //   call read here would abort the flow and there's no other mechanism for\n  //   continuing the flow if the stream consumer has just subscribed to the\n  //   'data' event.\n  //\n  // In addition to the above conditions to keep reading data, the following\n  // conditions prevent the data from being read:\n  // - The stream has ended (state.ended).\n  // - There is already a pending 'read' operation (state.reading). This is a\n  //   case where the stream has called the implementation defined _read()\n  //   method, but they are processing the call asynchronously and have _not_\n  //   called push() with new data. In this case we skip performing more\n  //   read()s. The execution ends in this method again after the _read() ends\n  //   up calling push() with more data.\n  while (\n    !state.reading &&\n    !state.ended &&\n    (state.length < state.highWaterMark || (state.flowing && state.length === 0))\n  ) {\n    const len = state.length\n    debug('maybeReadMore read 0')\n    stream.read(0)\n    if (len === state.length)\n      // Didn't get any data, stop spinning.\n      break\n  }\n  state.readingMore = false\n}\n\n// Abstract method.  to be overridden in specific implementation classes.\n// call cb(er, data) where data is <= n in length.\n// for virtual (non-string, non-buffer) streams, \"length\" is somewhat\n// arbitrary, and perhaps not very meaningful.\nReadable.prototype._read = function (n) {\n  throw new ERR_METHOD_NOT_IMPLEMENTED('_read()')\n}\nReadable.prototype.pipe = function (dest, pipeOpts) {\n  const src = this\n  const state = this._readableState\n  if (state.pipes.length === 1) {\n    if (!state.multiAwaitDrain) {\n      state.multiAwaitDrain = true\n      state.awaitDrainWriters = new SafeSet(state.awaitDrainWriters ? [state.awaitDrainWriters] : [])\n    }\n  }\n  state.pipes.push(dest)\n  debug('pipe count=%d opts=%j', state.pipes.length, pipeOpts)\n  const doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr\n  const endFn = doEnd ? onend : unpipe\n  if (state.endEmitted) process.nextTick(endFn)\n  else src.once('end', endFn)\n  dest.on('unpipe', onunpipe)\n  function onunpipe(readable, unpipeInfo) {\n    debug('onunpipe')\n    if (readable === src) {\n      if (unpipeInfo && unpipeInfo.hasUnpiped === false) {\n        unpipeInfo.hasUnpiped = true\n        cleanup()\n      }\n    }\n  }\n  function onend() {\n    debug('onend')\n    dest.end()\n  }\n  let ondrain\n  let cleanedUp = false\n  function cleanup() {\n    debug('cleanup')\n    // Cleanup event handlers once the pipe is broken.\n    dest.removeListener('close', onclose)\n    dest.removeListener('finish', onfinish)\n    if (ondrain) {\n      dest.removeListener('drain', ondrain)\n    }\n    dest.removeListener('error', onerror)\n    dest.removeListener('unpipe', onunpipe)\n    src.removeListener('end', onend)\n    src.removeListener('end', unpipe)\n    src.removeListener('data', ondata)\n    cleanedUp = true\n\n    // If the reader is waiting for a drain event from this\n    // specific writer, then it would cause it to never start\n    // flowing again.\n    // So, if this is awaiting a drain, then we just call it now.\n    // If we don't know, then assume that we are waiting for one.\n    if (ondrain && state.awaitDrainWriters && (!dest._writableState || dest._writableState.needDrain)) ondrain()\n  }\n  function pause() {\n    // If the user unpiped during `dest.write()`, it is possible\n    // to get stuck in a permanently paused state if that write\n    // also returned false.\n    // => Check whether `dest` is still a piping destination.\n    if (!cleanedUp) {\n      if (state.pipes.length === 1 && state.pipes[0] === dest) {\n        debug('false write response, pause', 0)\n        state.awaitDrainWriters = dest\n        state.multiAwaitDrain = false\n      } else if (state.pipes.length > 1 && state.pipes.includes(dest)) {\n        debug('false write response, pause', state.awaitDrainWriters.size)\n        state.awaitDrainWriters.add(dest)\n      }\n      src.pause()\n    }\n    if (!ondrain) {\n      // When the dest drains, it reduces the awaitDrain counter\n      // on the source.  This would be more elegant with a .once()\n      // handler in flow(), but adding and removing repeatedly is\n      // too slow.\n      ondrain = pipeOnDrain(src, dest)\n      dest.on('drain', ondrain)\n    }\n  }\n  src.on('data', ondata)\n  function ondata(chunk) {\n    debug('ondata')\n    const ret = dest.write(chunk)\n    debug('dest.write', ret)\n    if (ret === false) {\n      pause()\n    }\n  }\n\n  // If the dest has an error, then stop piping into it.\n  // However, don't suppress the throwing behavior for this.\n  function onerror(er) {\n    debug('onerror', er)\n    unpipe()\n    dest.removeListener('error', onerror)\n    if (dest.listenerCount('error') === 0) {\n      const s = dest._writableState || dest._readableState\n      if (s && !s.errorEmitted) {\n        // User incorrectly emitted 'error' directly on the stream.\n        errorOrDestroy(dest, er)\n      } else {\n        dest.emit('error', er)\n      }\n    }\n  }\n\n  // Make sure our error handler is attached before userland ones.\n  prependListener(dest, 'error', onerror)\n\n  // Both close and finish should trigger unpipe, but only once.\n  function onclose() {\n    dest.removeListener('finish', onfinish)\n    unpipe()\n  }\n  dest.once('close', onclose)\n  function onfinish() {\n    debug('onfinish')\n    dest.removeListener('close', onclose)\n    unpipe()\n  }\n  dest.once('finish', onfinish)\n  function unpipe() {\n    debug('unpipe')\n    src.unpipe(dest)\n  }\n\n  // Tell the dest that it's being piped to.\n  dest.emit('pipe', src)\n\n  // Start the flow if it hasn't been started already.\n\n  if (dest.writableNeedDrain === true) {\n    if (state.flowing) {\n      pause()\n    }\n  } else if (!state.flowing) {\n    debug('pipe resume')\n    src.resume()\n  }\n  return dest\n}\nfunction pipeOnDrain(src, dest) {\n  return function pipeOnDrainFunctionResult() {\n    const state = src._readableState\n\n    // `ondrain` will call directly,\n    // `this` maybe not a reference to dest,\n    // so we use the real dest here.\n    if (state.awaitDrainWriters === dest) {\n      debug('pipeOnDrain', 1)\n      state.awaitDrainWriters = null\n    } else if (state.multiAwaitDrain) {\n      debug('pipeOnDrain', state.awaitDrainWriters.size)\n      state.awaitDrainWriters.delete(dest)\n    }\n    if ((!state.awaitDrainWriters || state.awaitDrainWriters.size === 0) && src.listenerCount('data')) {\n      src.resume()\n    }\n  }\n}\nReadable.prototype.unpipe = function (dest) {\n  const state = this._readableState\n  const unpipeInfo = {\n    hasUnpiped: false\n  }\n\n  // If we're not piping anywhere, then do nothing.\n  if (state.pipes.length === 0) return this\n  if (!dest) {\n    // remove all.\n    const dests = state.pipes\n    state.pipes = []\n    this.pause()\n    for (let i = 0; i < dests.length; i++)\n      dests[i].emit('unpipe', this, {\n        hasUnpiped: false\n      })\n    return this\n  }\n\n  // Try to find the right one.\n  const index = ArrayPrototypeIndexOf(state.pipes, dest)\n  if (index === -1) return this\n  state.pipes.splice(index, 1)\n  if (state.pipes.length === 0) this.pause()\n  dest.emit('unpipe', this, unpipeInfo)\n  return this\n}\n\n// Set up data events if they are asked for\n// Ensure readable listeners eventually get something.\nReadable.prototype.on = function (ev, fn) {\n  const res = Stream.prototype.on.call(this, ev, fn)\n  const state = this._readableState\n  if (ev === 'data') {\n    // Update readableListening so that resume() may be a no-op\n    // a few lines down. This is needed to support once('readable').\n    state.readableListening = this.listenerCount('readable') > 0\n\n    // Try start flowing on next tick if stream isn't explicitly paused.\n    if (state.flowing !== false) this.resume()\n  } else if (ev === 'readable') {\n    if (!state.endEmitted && !state.readableListening) {\n      state.readableListening = state.needReadable = true\n      state.flowing = false\n      state.emittedReadable = false\n      debug('on readable', state.length, state.reading)\n      if (state.length) {\n        emitReadable(this)\n      } else if (!state.reading) {\n        process.nextTick(nReadingNextTick, this)\n      }\n    }\n  }\n  return res\n}\nReadable.prototype.addListener = Readable.prototype.on\nReadable.prototype.removeListener = function (ev, fn) {\n  const res = Stream.prototype.removeListener.call(this, ev, fn)\n  if (ev === 'readable') {\n    // We need to check if there is someone still listening to\n    // readable and reset the state. However this needs to happen\n    // after readable has been emitted but before I/O (nextTick) to\n    // support once('readable', fn) cycles. This means that calling\n    // resume within the same tick will have no\n    // effect.\n    process.nextTick(updateReadableListening, this)\n  }\n  return res\n}\nReadable.prototype.off = Readable.prototype.removeListener\nReadable.prototype.removeAllListeners = function (ev) {\n  const res = Stream.prototype.removeAllListeners.apply(this, arguments)\n  if (ev === 'readable' || ev === undefined) {\n    // We need to check if there is someone still listening to\n    // readable and reset the state. However this needs to happen\n    // after readable has been emitted but before I/O (nextTick) to\n    // support once('readable', fn) cycles. This means that calling\n    // resume within the same tick will have no\n    // effect.\n    process.nextTick(updateReadableListening, this)\n  }\n  return res\n}\nfunction updateReadableListening(self) {\n  const state = self._readableState\n  state.readableListening = self.listenerCount('readable') > 0\n  if (state.resumeScheduled && state[kPaused] === false) {\n    // Flowing needs to be set to true now, otherwise\n    // the upcoming resume will not flow.\n    state.flowing = true\n\n    // Crude way to check if we should resume.\n  } else if (self.listenerCount('data') > 0) {\n    self.resume()\n  } else if (!state.readableListening) {\n    state.flowing = null\n  }\n}\nfunction nReadingNextTick(self) {\n  debug('readable nexttick read 0')\n  self.read(0)\n}\n\n// pause() and resume() are remnants of the legacy readable stream API\n// If the user uses them, then switch into old mode.\nReadable.prototype.resume = function () {\n  const state = this._readableState\n  if (!state.flowing) {\n    debug('resume')\n    // We flow only if there is no one listening\n    // for readable, but we still have to call\n    // resume().\n    state.flowing = !state.readableListening\n    resume(this, state)\n  }\n  state[kPaused] = false\n  return this\n}\nfunction resume(stream, state) {\n  if (!state.resumeScheduled) {\n    state.resumeScheduled = true\n    process.nextTick(resume_, stream, state)\n  }\n}\nfunction resume_(stream, state) {\n  debug('resume', state.reading)\n  if (!state.reading) {\n    stream.read(0)\n  }\n  state.resumeScheduled = false\n  stream.emit('resume')\n  flow(stream)\n  if (state.flowing && !state.reading) stream.read(0)\n}\nReadable.prototype.pause = function () {\n  debug('call pause flowing=%j', this._readableState.flowing)\n  if (this._readableState.flowing !== false) {\n    debug('pause')\n    this._readableState.flowing = false\n    this.emit('pause')\n  }\n  this._readableState[kPaused] = true\n  return this\n}\nfunction flow(stream) {\n  const state = stream._readableState\n  debug('flow', state.flowing)\n  while (state.flowing && stream.read() !== null);\n}\n\n// Wrap an old-style stream as the async data source.\n// This is *not* part of the readable stream interface.\n// It is an ugly unfortunate mess of history.\nReadable.prototype.wrap = function (stream) {\n  let paused = false\n\n  // TODO (ronag): Should this.destroy(err) emit\n  // 'error' on the wrapped stream? Would require\n  // a static factory method, e.g. Readable.wrap(stream).\n\n  stream.on('data', (chunk) => {\n    if (!this.push(chunk) && stream.pause) {\n      paused = true\n      stream.pause()\n    }\n  })\n  stream.on('end', () => {\n    this.push(null)\n  })\n  stream.on('error', (err) => {\n    errorOrDestroy(this, err)\n  })\n  stream.on('close', () => {\n    this.destroy()\n  })\n  stream.on('destroy', () => {\n    this.destroy()\n  })\n  this._read = () => {\n    if (paused && stream.resume) {\n      paused = false\n      stream.resume()\n    }\n  }\n\n  // Proxy all the other methods. Important when wrapping filters and duplexes.\n  const streamKeys = ObjectKeys(stream)\n  for (let j = 1; j < streamKeys.length; j++) {\n    const i = streamKeys[j]\n    if (this[i] === undefined && typeof stream[i] === 'function') {\n      this[i] = stream[i].bind(stream)\n    }\n  }\n  return this\n}\nReadable.prototype[SymbolAsyncIterator] = function () {\n  return streamToAsyncIterator(this)\n}\nReadable.prototype.iterator = function (options) {\n  if (options !== undefined) {\n    validateObject(options, 'options')\n  }\n  return streamToAsyncIterator(this, options)\n}\nfunction streamToAsyncIterator(stream, options) {\n  if (typeof stream.read !== 'function') {\n    stream = Readable.wrap(stream, {\n      objectMode: true\n    })\n  }\n  const iter = createAsyncIterator(stream, options)\n  iter.stream = stream\n  return iter\n}\nasync function* createAsyncIterator(stream, options) {\n  let callback = nop\n  function next(resolve) {\n    if (this === stream) {\n      callback()\n      callback = nop\n    } else {\n      callback = resolve\n    }\n  }\n  stream.on('readable', next)\n  let error\n  const cleanup = eos(\n    stream,\n    {\n      writable: false\n    },\n    (err) => {\n      error = err ? aggregateTwoErrors(error, err) : null\n      callback()\n      callback = nop\n    }\n  )\n  try {\n    while (true) {\n      const chunk = stream.destroyed ? null : stream.read()\n      if (chunk !== null) {\n        yield chunk\n      } else if (error) {\n        throw error\n      } else if (error === null) {\n        return\n      } else {\n        await new Promise(next)\n      }\n    }\n  } catch (err) {\n    error = aggregateTwoErrors(error, err)\n    throw error\n  } finally {\n    if (\n      (error || (options === null || options === undefined ? undefined : options.destroyOnReturn) !== false) &&\n      (error === undefined || stream._readableState.autoDestroy)\n    ) {\n      destroyImpl.destroyer(stream, null)\n    } else {\n      stream.off('readable', next)\n      cleanup()\n    }\n  }\n}\n\n// Making it explicit these properties are not enumerable\n// because otherwise some prototype manipulation in\n// userland will fail.\nObjectDefineProperties(Readable.prototype, {\n  readable: {\n    __proto__: null,\n    get() {\n      const r = this._readableState\n      // r.readable === false means that this is part of a Duplex stream\n      // where the readable side was disabled upon construction.\n      // Compat. The user might manually disable readable side through\n      // deprecated setter.\n      return !!r && r.readable !== false && !r.destroyed && !r.errorEmitted && !r.endEmitted\n    },\n    set(val) {\n      // Backwards compat.\n      if (this._readableState) {\n        this._readableState.readable = !!val\n      }\n    }\n  },\n  readableDidRead: {\n    __proto__: null,\n    enumerable: false,\n    get: function () {\n      return this._readableState.dataEmitted\n    }\n  },\n  readableAborted: {\n    __proto__: null,\n    enumerable: false,\n    get: function () {\n      return !!(\n        this._readableState.readable !== false &&\n        (this._readableState.destroyed || this._readableState.errored) &&\n        !this._readableState.endEmitted\n      )\n    }\n  },\n  readableHighWaterMark: {\n    __proto__: null,\n    enumerable: false,\n    get: function () {\n      return this._readableState.highWaterMark\n    }\n  },\n  readableBuffer: {\n    __proto__: null,\n    enumerable: false,\n    get: function () {\n      return this._readableState && this._readableState.buffer\n    }\n  },\n  readableFlowing: {\n    __proto__: null,\n    enumerable: false,\n    get: function () {\n      return this._readableState.flowing\n    },\n    set: function (state) {\n      if (this._readableState) {\n        this._readableState.flowing = state\n      }\n    }\n  },\n  readableLength: {\n    __proto__: null,\n    enumerable: false,\n    get() {\n      return this._readableState.length\n    }\n  },\n  readableObjectMode: {\n    __proto__: null,\n    enumerable: false,\n    get() {\n      return this._readableState ? this._readableState.objectMode : false\n    }\n  },\n  readableEncoding: {\n    __proto__: null,\n    enumerable: false,\n    get() {\n      return this._readableState ? this._readableState.encoding : null\n    }\n  },\n  errored: {\n    __proto__: null,\n    enumerable: false,\n    get() {\n      return this._readableState ? this._readableState.errored : null\n    }\n  },\n  closed: {\n    __proto__: null,\n    get() {\n      return this._readableState ? this._readableState.closed : false\n    }\n  },\n  destroyed: {\n    __proto__: null,\n    enumerable: false,\n    get() {\n      return this._readableState ? this._readableState.destroyed : false\n    },\n    set(value) {\n      // We ignore the value if the stream\n      // has not been initialized yet.\n      if (!this._readableState) {\n        return\n      }\n\n      // Backward compatibility, the user is explicitly\n      // managing destroyed.\n      this._readableState.destroyed = value\n    }\n  },\n  readableEnded: {\n    __proto__: null,\n    enumerable: false,\n    get() {\n      return this._readableState ? this._readableState.endEmitted : false\n    }\n  }\n})\nObjectDefineProperties(ReadableState.prototype, {\n  // Legacy getter for `pipesCount`.\n  pipesCount: {\n    __proto__: null,\n    get() {\n      return this.pipes.length\n    }\n  },\n  // Legacy property for `paused`.\n  paused: {\n    __proto__: null,\n    get() {\n      return this[kPaused] !== false\n    },\n    set(value) {\n      this[kPaused] = !!value\n    }\n  }\n})\n\n// Exposed for testing purposes only.\nReadable._fromList = fromList\n\n// Pluck off n bytes from an array of buffers.\n// Length is the combined lengths of all the buffers in the list.\n// This function is designed to be inlinable, so please take care when making\n// changes to the function body.\nfunction fromList(n, state) {\n  // nothing buffered.\n  if (state.length === 0) return null\n  let ret\n  if (state.objectMode) ret = state.buffer.shift()\n  else if (!n || n >= state.length) {\n    // Read it all, truncate the list.\n    if (state.decoder) ret = state.buffer.join('')\n    else if (state.buffer.length === 1) ret = state.buffer.first()\n    else ret = state.buffer.concat(state.length)\n    state.buffer.clear()\n  } else {\n    // read part of list.\n    ret = state.buffer.consume(n, state.decoder)\n  }\n  return ret\n}\nfunction endReadable(stream) {\n  const state = stream._readableState\n  debug('endReadable', state.endEmitted)\n  if (!state.endEmitted) {\n    state.ended = true\n    process.nextTick(endReadableNT, state, stream)\n  }\n}\nfunction endReadableNT(state, stream) {\n  debug('endReadableNT', state.endEmitted, state.length)\n\n  // Check that we didn't get one last unshift.\n  if (!state.errored && !state.closeEmitted && !state.endEmitted && state.length === 0) {\n    state.endEmitted = true\n    stream.emit('end')\n    if (stream.writable && stream.allowHalfOpen === false) {\n      process.nextTick(endWritableNT, stream)\n    } else if (state.autoDestroy) {\n      // In case of duplex streams we need a way to detect\n      // if the writable side is ready for autoDestroy as well.\n      const wState = stream._writableState\n      const autoDestroy =\n        !wState ||\n        (wState.autoDestroy &&\n          // We don't expect the writable to ever 'finish'\n          // if writable is explicitly set to false.\n          (wState.finished || wState.writable === false))\n      if (autoDestroy) {\n        stream.destroy()\n      }\n    }\n  }\n}\nfunction endWritableNT(stream) {\n  const writable = stream.writable && !stream.writableEnded && !stream.destroyed\n  if (writable) {\n    stream.end()\n  }\n}\nReadable.from = function (iterable, opts) {\n  return from(Readable, iterable, opts)\n}\nlet webStreamsAdapters\n\n// Lazy to avoid circular references\nfunction lazyWebStreams() {\n  if (webStreamsAdapters === undefined) webStreamsAdapters = {}\n  return webStreamsAdapters\n}\nReadable.fromWeb = function (readableStream, options) {\n  return lazyWebStreams().newStreamReadableFromReadableStream(readableStream, options)\n}\nReadable.toWeb = function (streamReadable, options) {\n  return lazyWebStreams().newReadableStreamFromStreamReadable(streamReadable, options)\n}\nReadable.wrap = function (src, options) {\n  var _ref, _src$readableObjectMo\n  return new Readable({\n    objectMode:\n      (_ref =\n        (_src$readableObjectMo = src.readableObjectMode) !== null && _src$readableObjectMo !== undefined\n          ? _src$readableObjectMo\n          : src.objectMode) !== null && _ref !== undefined\n        ? _ref\n        : true,\n    ...options,\n    destroy(err, callback) {\n      destroyImpl.destroyer(src, err)\n      callback(err)\n    }\n  }).wrap(src)\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}