{"ast":null,"code":"'use strict';\n\nconst {\n  StringPrototypeSlice,\n  SymbolIterator,\n  TypedArrayPrototypeSet,\n  Uint8Array\n} = require('../../ours/primordials');\nconst {\n  Buffer\n} = require('buffer');\nconst {\n  inspect\n} = require('../../ours/util');\nmodule.exports = class BufferList {\n  constructor() {\n    this.head = null;\n    this.tail = null;\n    this.length = 0;\n  }\n  push(v) {\n    const entry = {\n      data: v,\n      next: null\n    };\n    if (this.length > 0) this.tail.next = entry;else this.head = entry;\n    this.tail = entry;\n    ++this.length;\n  }\n  unshift(v) {\n    const entry = {\n      data: v,\n      next: this.head\n    };\n    if (this.length === 0) this.tail = entry;\n    this.head = entry;\n    ++this.length;\n  }\n  shift() {\n    if (this.length === 0) return;\n    const ret = this.head.data;\n    if (this.length === 1) this.head = this.tail = null;else this.head = this.head.next;\n    --this.length;\n    return ret;\n  }\n  clear() {\n    this.head = this.tail = null;\n    this.length = 0;\n  }\n  join(s) {\n    if (this.length === 0) return '';\n    let p = this.head;\n    let ret = '' + p.data;\n    while ((p = p.next) !== null) ret += s + p.data;\n    return ret;\n  }\n  concat(n) {\n    if (this.length === 0) return Buffer.alloc(0);\n    const ret = Buffer.allocUnsafe(n >>> 0);\n    let p = this.head;\n    let i = 0;\n    while (p) {\n      TypedArrayPrototypeSet(ret, p.data, i);\n      i += p.data.length;\n      p = p.next;\n    }\n    return ret;\n  }\n\n  // Consumes a specified amount of bytes or characters from the buffered data.\n  consume(n, hasStrings) {\n    const data = this.head.data;\n    if (n < data.length) {\n      // `slice` is the same for buffers and strings.\n      const slice = data.slice(0, n);\n      this.head.data = data.slice(n);\n      return slice;\n    }\n    if (n === data.length) {\n      // First chunk is a perfect match.\n      return this.shift();\n    }\n    // Result spans more than one buffer.\n    return hasStrings ? this._getString(n) : this._getBuffer(n);\n  }\n  first() {\n    return this.head.data;\n  }\n  *[SymbolIterator]() {\n    for (let p = this.head; p; p = p.next) {\n      yield p.data;\n    }\n  }\n\n  // Consumes a specified amount of characters from the buffered data.\n  _getString(n) {\n    let ret = '';\n    let p = this.head;\n    let c = 0;\n    do {\n      const str = p.data;\n      if (n > str.length) {\n        ret += str;\n        n -= str.length;\n      } else {\n        if (n === str.length) {\n          ret += str;\n          ++c;\n          if (p.next) this.head = p.next;else this.head = this.tail = null;\n        } else {\n          ret += StringPrototypeSlice(str, 0, n);\n          this.head = p;\n          p.data = StringPrototypeSlice(str, n);\n        }\n        break;\n      }\n      ++c;\n    } while ((p = p.next) !== null);\n    this.length -= c;\n    return ret;\n  }\n\n  // Consumes a specified amount of bytes from the buffered data.\n  _getBuffer(n) {\n    const ret = Buffer.allocUnsafe(n);\n    const retLen = n;\n    let p = this.head;\n    let c = 0;\n    do {\n      const buf = p.data;\n      if (n > buf.length) {\n        TypedArrayPrototypeSet(ret, buf, retLen - n);\n        n -= buf.length;\n      } else {\n        if (n === buf.length) {\n          TypedArrayPrototypeSet(ret, buf, retLen - n);\n          ++c;\n          if (p.next) this.head = p.next;else this.head = this.tail = null;\n        } else {\n          TypedArrayPrototypeSet(ret, new Uint8Array(buf.buffer, buf.byteOffset, n), retLen - n);\n          this.head = p;\n          p.data = buf.slice(n);\n        }\n        break;\n      }\n      ++c;\n    } while ((p = p.next) !== null);\n    this.length -= c;\n    return ret;\n  }\n\n  // Make sure the linked list only shows the minimal necessary information.\n  [Symbol.for('nodejs.util.inspect.custom')](_, options) {\n    return inspect(this, {\n      ...options,\n      // Only inspect one level.\n      depth: 0,\n      // It should not recurse.\n      customInspect: false\n    });\n  }\n};","map":{"version":3,"names":["StringPrototypeSlice","SymbolIterator","TypedArrayPrototypeSet","Uint8Array","require","Buffer","inspect","module","exports","BufferList","constructor","head","tail","length","push","v","entry","data","next","unshift","shift","ret","clear","join","s","p","concat","n","alloc","allocUnsafe","i","consume","hasStrings","slice","_getString","_getBuffer","first","c","str","retLen","buf","buffer","byteOffset","Symbol","for","_","options","depth","customInspect"],"sources":["/Users/jstanton/Coding/FieldDock/FieldDockMain/node_modules/mqtt/node_modules/readable-stream/lib/internal/streams/buffer_list.js"],"sourcesContent":["'use strict'\n\nconst { StringPrototypeSlice, SymbolIterator, TypedArrayPrototypeSet, Uint8Array } = require('../../ours/primordials')\nconst { Buffer } = require('buffer')\nconst { inspect } = require('../../ours/util')\nmodule.exports = class BufferList {\n  constructor() {\n    this.head = null\n    this.tail = null\n    this.length = 0\n  }\n  push(v) {\n    const entry = {\n      data: v,\n      next: null\n    }\n    if (this.length > 0) this.tail.next = entry\n    else this.head = entry\n    this.tail = entry\n    ++this.length\n  }\n  unshift(v) {\n    const entry = {\n      data: v,\n      next: this.head\n    }\n    if (this.length === 0) this.tail = entry\n    this.head = entry\n    ++this.length\n  }\n  shift() {\n    if (this.length === 0) return\n    const ret = this.head.data\n    if (this.length === 1) this.head = this.tail = null\n    else this.head = this.head.next\n    --this.length\n    return ret\n  }\n  clear() {\n    this.head = this.tail = null\n    this.length = 0\n  }\n  join(s) {\n    if (this.length === 0) return ''\n    let p = this.head\n    let ret = '' + p.data\n    while ((p = p.next) !== null) ret += s + p.data\n    return ret\n  }\n  concat(n) {\n    if (this.length === 0) return Buffer.alloc(0)\n    const ret = Buffer.allocUnsafe(n >>> 0)\n    let p = this.head\n    let i = 0\n    while (p) {\n      TypedArrayPrototypeSet(ret, p.data, i)\n      i += p.data.length\n      p = p.next\n    }\n    return ret\n  }\n\n  // Consumes a specified amount of bytes or characters from the buffered data.\n  consume(n, hasStrings) {\n    const data = this.head.data\n    if (n < data.length) {\n      // `slice` is the same for buffers and strings.\n      const slice = data.slice(0, n)\n      this.head.data = data.slice(n)\n      return slice\n    }\n    if (n === data.length) {\n      // First chunk is a perfect match.\n      return this.shift()\n    }\n    // Result spans more than one buffer.\n    return hasStrings ? this._getString(n) : this._getBuffer(n)\n  }\n  first() {\n    return this.head.data\n  }\n  *[SymbolIterator]() {\n    for (let p = this.head; p; p = p.next) {\n      yield p.data\n    }\n  }\n\n  // Consumes a specified amount of characters from the buffered data.\n  _getString(n) {\n    let ret = ''\n    let p = this.head\n    let c = 0\n    do {\n      const str = p.data\n      if (n > str.length) {\n        ret += str\n        n -= str.length\n      } else {\n        if (n === str.length) {\n          ret += str\n          ++c\n          if (p.next) this.head = p.next\n          else this.head = this.tail = null\n        } else {\n          ret += StringPrototypeSlice(str, 0, n)\n          this.head = p\n          p.data = StringPrototypeSlice(str, n)\n        }\n        break\n      }\n      ++c\n    } while ((p = p.next) !== null)\n    this.length -= c\n    return ret\n  }\n\n  // Consumes a specified amount of bytes from the buffered data.\n  _getBuffer(n) {\n    const ret = Buffer.allocUnsafe(n)\n    const retLen = n\n    let p = this.head\n    let c = 0\n    do {\n      const buf = p.data\n      if (n > buf.length) {\n        TypedArrayPrototypeSet(ret, buf, retLen - n)\n        n -= buf.length\n      } else {\n        if (n === buf.length) {\n          TypedArrayPrototypeSet(ret, buf, retLen - n)\n          ++c\n          if (p.next) this.head = p.next\n          else this.head = this.tail = null\n        } else {\n          TypedArrayPrototypeSet(ret, new Uint8Array(buf.buffer, buf.byteOffset, n), retLen - n)\n          this.head = p\n          p.data = buf.slice(n)\n        }\n        break\n      }\n      ++c\n    } while ((p = p.next) !== null)\n    this.length -= c\n    return ret\n  }\n\n  // Make sure the linked list only shows the minimal necessary information.\n  [Symbol.for('nodejs.util.inspect.custom')](_, options) {\n    return inspect(this, {\n      ...options,\n      // Only inspect one level.\n      depth: 0,\n      // It should not recurse.\n      customInspect: false\n    })\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}